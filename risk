#!/usr/bin/env zsh

version_command() {
  echo "$version"
}

risk_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk - RISKS Dom0 management application\n"
    echo

  else
    printf "risk - RISKS Dom0 management application\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk [OPTIONS] COMMAND\n"
  printf "  risk [COMMAND] --help | -h\n"
  printf "  risk --version\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Manage the hush partition attach/detach from qubes\n" "$(red "hush")    "
  printf "  %s   Manage backup devices attach/detach from qubes\n" "$(red "backup")  "
  printf "  %s   Create, manage and use identities and/or use their machines\n" "$(red "identity")"
  printf "  %s   Close identity, infrastructure and detach hush/backup at once\n" "$(red "slam")    "
  printf "  %s   Create, configure, manage and use VPN gateways for an identity.\n" "$(red "vpn")     "
  printf "  %s   Manage qubes (identity settings, update/enable/disable, etc)\n" "$(red "qube")    "
  printf "  %s   Execute a command in a VM belong to an identity.\n" "$(red "use")     "
  printf "  %s   Browse, bookmark, verify and manage URLS/links\n" "$(red "url")     "
  printf "  %s   Manage the risk global configuration\n" "$(red "config")  "
  printf "  %s   Show help about a command\n" "$(red "help")    "
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--verbose, -v"
    printf "    Show verbose logging\n"
    echo

    printf "  %s\n" "--log-file, -l LOGFILE"
    printf "    Path to log file\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version"
    printf "    Show version number\n"
    echo

  fi
}

risk_hush_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk hush - Manage the hush partition attach/detach from qubes\n"
    echo

  else
    printf "risk hush - Manage the hush partition attach/detach from qubes\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk hush COMMAND\n"
  printf "  risk hush [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Attach the hush device to a qube. Accepts optional args to override default hush/vault\n" "$(red "attach")"
  printf "  %s   Detach the hush device from its current qube, making sure it's not in a read-write state\n" "$(red "detach")"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_hush_attach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk hush attach - Attach the hush device to a qube. Accepts optional args to override default hush/vault\n"
    echo

  else
    printf "risk hush attach - Attach the hush device to a qube. Accepts optional args to override default hush/vault\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk hush attach [DEVICE] [VAULT_VM] [OPTIONS]\n"
  printf "  risk hush attach --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--mount, -m"
    printf "    Mount the hush device in the vault (prompts for password)\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "DEVICE")"
    printf "    (optional) qubes path to device to use as hush (defaults to SDCARD_BLOCK)\n"
    echo

    printf "  %s\n" "$(blue "VAULT_VM")"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

risk_hush_detach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk hush detach - Detach the hush device from its current qube, making sure it's not in a read-write state\n"
    echo

  else
    printf "risk hush detach - Detach the hush device from its current qube, making sure it's not in a read-write state\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk hush detach [DEVICE] [VAULT_VM]\n"
  printf "  risk hush detach --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "DEVICE")"
    printf "    (optional) qubes path to device to use as backup (defaults to BACKUP_BLOCK)\n"
    echo

    printf "  %s\n" "$(blue "VAULT_VM")"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

risk_backup_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk backup - Manage backup devices attach/detach from qubes\n"
    echo

  else
    printf "risk backup - Manage backup devices attach/detach from qubes\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk backup COMMAND\n"
  printf "  risk backup [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Attach a backup device to a qube. Accepts optional args to override default backup/vault\n" "$(red "attach")"
  printf "  %s   Detach the backup device from its current qube, making sure it's not in a read-write state\n" "$(red "detach")"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_backup_attach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk backup attach - Attach a backup device to a qube. Accepts optional args to override default backup/vault\n"
    echo

  else
    printf "risk backup attach - Attach a backup device to a qube. Accepts optional args to override default backup/vault\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk backup attach [DEVICE] [VAULT_VM]\n"
  printf "  risk backup attach --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "DEVICE")"
    printf "    (optional) qubes path to device to use as backup (defaults to BACKUP_BLOCK)\n"
    echo

    printf "  %s\n" "$(blue "VAULT_VM")"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

risk_backup_detach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk backup detach - Detach the backup device from its current qube, making sure it's not in a read-write state\n"
    echo

  else
    printf "risk backup detach - Detach the backup device from its current qube, making sure it's not in a read-write state\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk backup detach [DEVICE] [VAULT_VM]\n"
  printf "  risk backup detach --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "DEVICE")"
    printf "    (optional) qubes path to device to use as backup (defaults to BACKUP_BLOCK)\n"
    echo

    printf "  %s\n" "$(blue "VAULT_VM")"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

risk_identity_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity - Create, manage and use identities and/or use their machines\n"
    echo

  else
    printf "risk identity - Create, manage and use identities and/or use their machines\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity COMMAND\n"
  printf "  risk identity [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)\n" "$(red "create")"
  printf "  %s   Creates the infrastructure for an already exiting identity.\n" "$(red "equip") "
  printf "  %s   Destroys an identity and all its associated machines and data\n" "$(red "delete")"
  printf "  %s   Delete the VMs belonging to an identity, but not the identity in the vault.\n" "$(red "nake")  "
  printf "  %s   Simply open the identity store in the vault\n" "$(red "open")  "
  printf "  %s   Simply close the identity store in the vault\n" "$(red "close") "
  printf "  %s   Start the identity in the vault and all of its enabled VMs\n" "$(red "start") "
  printf "  %s   Stops all machines belonging to an identity, and close its vault if active.\n" "$(red "stop")  "
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_identity_create_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity create - Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)\n"
    echo

  else
    printf "risk identity create - Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity create [IDENTITY] [EMAIL] [EXPIRY_DATE] [OPTIONS]\n"
  printf "  risk identity create --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--backup, -b"
    printf "    Device file of the backup drive (must be a whole drive without a partition\n    number, eg. /dev/sdb)\n"
    echo

    printf "  %s\n" "--burner, -B"
    printf "    Generate a random username, and only generate GPG/Pass stores\n"
    echo

    printf "  %s\n" "--vault-only"
    printf "    Only create the identity in the vault: do not create any machines\n"
    echo

    printf "  %s\n" "--mail, -m"
    printf "    Mail provider to use for the GPG key (appended to the name when no full mail\n    is given as arg)\n"
    echo

    printf "  %s\n" "--prefix, -P NAME"
    printf "    Use a different name for naming identity VMs\n"
    echo

    printf "  %s\n" "--label, -L COLOR"
    printf "    Specify a label color to be used for all VMs belonging to this identity\n"
    echo

    printf "  %s\n" "--no-tor, -T"
    printf "    Don't create a Whonix TOR gateway\n"
    echo

    printf "  %s\n" "--clone-tor-from TOR_GW"
    printf "    Instead of creating the TOR gateway from a template, clone an existing TOR\n    AppVM\n"
    echo

    printf "  %s\n" "--clone-web-from WEB_VM"
    printf "    Instead of creating the Web browsing VM from a template, clone an existing\n    browser AppVM\n"
    echo

    printf "  %s\n" "--clone-split-from SPLIT_BROWSER_VM"
    printf "    Instead of creating the split-browser VM from a template, clone an existing\n    one\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Name of the identity for which to initialize infrastructure\n"
    echo

    printf "  %s\n" "$(blue "EMAIL")"
    printf "    Email address to use for the GPG identity\n"
    echo

    printf "  %s\n" "$(blue "EXPIRY_DATE")"
    printf "    Human readable, or GPG-compliant expiry duration to use for the GPG subkeys\n    (eg. '1 year', '1 week', etc)\n"
    echo

  fi
}

risk_identity_equip_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity equip - Creates the infrastructure for an already exiting identity.\n"
    echo

  else
    printf "risk identity equip - Creates the infrastructure for an already exiting identity.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity equip IDENTITY [OPTIONS]\n"
  printf "  risk identity equip --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--prefix, -P NAME"
    printf "    Use a different name for naming identity VMs\n"
    echo

    printf "  %s\n" "--label, -L COLOR"
    printf "    Specify a label color to be used for all VMs belonging to this identity\n"
    echo

    printf "  %s\n" "--no-tor, -T"
    printf "    Don't create a Whonix TOR gateway\n"
    echo

    printf "  %s\n" "--clone-tor-from TOR_GW"
    printf "    Instead of creating the TOR gateway from a template, clone an existing TOR\n    AppVM\n"
    echo

    printf "  %s\n" "--clone-web-from WEB_VM"
    printf "    Instead of creating the Web browsing VM from a template, clone an existing\n    browser AppVM\n"
    echo

    printf "  %s\n" "--clone-split-from SPLIT_BROWSER_VM"
    printf "    Instead of creating the split-browser VM from a template, clone an existing\n    one\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity for which to setup infrastructure\n"
    echo

  fi
}

risk_identity_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity delete - Destroys an identity and all its associated machines and data\n"
    echo

  else
    printf "risk identity delete - Destroys an identity and all its associated machines and data\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity delete IDENTITY [OPTIONS]\n"
  printf "  risk identity delete --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--backup, -b"
    printf "    If a backup medium is mounted in vault, also delete the backup if it exists.\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity to delete along with machines\n"
    echo

  fi
}

risk_identity_nake_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity nake - Delete the VMs belonging to an identity, but not the identity in the vault.\n"
    echo

  else
    printf "risk identity nake - Delete the VMs belonging to an identity, but not the identity in the vault.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity nake IDENTITY\n"
  printf "  risk identity nake --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity for which to delete machines\n"
    echo

  fi
}

risk_identity_open_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity open - Simply open the identity store in the vault\n"
    echo

  else
    printf "risk identity open - Simply open the identity store in the vault\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity open IDENTITY\n"
  printf "  risk identity open --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity to open in the vault\n"
    echo

  fi
}

risk_identity_close_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity close - Simply close the identity store in the vault\n"
    echo

  else
    printf "risk identity close - Simply close the identity store in the vault\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity close\n"
  printf "  risk identity close --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_identity_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity start - Start the identity in the vault and all of its enabled VMs\n"
    echo

  else
    printf "risk identity start - Start the identity in the vault and all of its enabled VMs\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity start IDENTITY\n"
  printf "  risk identity start --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity to start\n"
    echo

  fi
}

risk_identity_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity stop - Stops all machines belonging to an identity, and close its vault if active.\n"
    echo

  else
    printf "risk identity stop - Stops all machines belonging to an identity, and close its vault if active.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity stop\n"
  printf "  risk identity stop --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_identity_current_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity current - Prints the active identity as a raw string, to be used by prompts.\n"
    echo

  else
    printf "risk identity current - Prints the active identity as a raw string, to be used by prompts.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity current\n"
  printf "  risk identity current --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_slam_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk slam - Close identity, infrastructure and detach hush/backup at once\n"
    echo

  else
    printf "risk slam - Close identity, infrastructure and detach hush/backup at once\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk slam\n"
  printf "  risk slam --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_vpn_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn - Create, configure, manage and use VPN gateways for an identity.\n"
    echo

  else
    printf "risk vpn - Create, configure, manage and use VPN gateways for an identity.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn COMMAND\n"
  printf "  risk vpn [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Create VPN gateway from a template, or by cloning an existing one.\n" "$(red "create") "
  printf "  %s   Add an existing qube as an identity VPN gateway.\n" "$(red "add")    "
  printf "  %s   Manage, import network configurations and run associated setup wizards\n" "$(red "setup")  "
  printf "  %s   Start a VPN gateway in the background\n" "$(red "start")  "
  printf "  %s   Stop a VPN gateway\n" "$(red "stop")   "
  printf "  %s   Automatically start a VPN gateway when starting the identity.\n" "$(red "enable") "
  printf "  %s   Do not autostart this VM when the identity is started\n" "$(red "disable")"
  printf "  %s   Delete a VPN gateway\n" "$(red "delete") "
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_vpn_create_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn create - Create VPN gateway from a template, or by cloning an existing one.\n"
    echo

  else
    printf "risk vpn create - Create VPN gateway from a template, or by cloning an existing one.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn create [VM] [OPTIONS]\n"
  printf "  risk vpn create --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--label, -L COLOR"
    printf "    Specify a label color to be used for all VMs belonging to this identity\n"
    echo

    printf "  %s\n" "--enable, -E"
    printf "    Autostart this VM when the identity is started\n"
    echo

    printf "  %s\n" "--template, -T TEMPLATE"
    printf "    TemplateVM to use instead of the default VPN TemplateVM\n"
    echo

    printf "  %s\n" "--clone, -c"
    printf "    Instead of creating the VPN gateway from a template, clone an existing VPN\n    AppVM\n"
    echo

    printf "  %s\n" "--from, -f VPN_GW"
    printf "    VM to clone instead of the default VPN_VM configuration setting\n"
    echo

    printf "  %s\n" "--config-in CONFIG_VM"
    printf "    VM in which to browse for VPN configuration(s)\n"
    echo

    printf "  %s\n" "--choose"
    printf "    Choose an existing client config by running the setup wizard in the VPN VM\n"
    echo

    printf "  %s\n" "--set-default"
    printf "    Set this VM as the default NetVM for all identity client VMs (browsers,\n    messaging, etc)\n"
    echo

    printf "  %s\n" "--netvm, -n VM"
    printf "    NetVM to use for the gateway\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    (optional) name to use for this VM (=> identity-<name>-vpn)\n"
    echo

  fi
}

risk_vpn_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn add - Add an existing qube as an identity VPN gateway.\n"
    echo

  else
    printf "risk vpn add - Add an existing qube as an identity VPN gateway.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn add VM [OPTIONS]\n"
  printf "  risk vpn add --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--enable, -E"
    printf "    Autostart this VM when the identity is started\n"
    echo

    printf "  %s\n" "--set-default"
    printf "    Set this VM as the default NetVM for all identity client VMs (browsers,\n    messaging, etc)\n"
    echo

    printf "  %s\n" "--netvm, -n VM"
    printf "    NetVM to use for the gateway\n"
    echo

    printf "  %s\n" "--config-in CONFIG_VM"
    printf "    VM in which to browse for VPN configuration(s)\n"
    echo

    printf "  %s\n" "--choose"
    printf "    Choose an existing client config by running the setup wizard in the VPN VM\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    Qube to add as VPN gateway\n"
    echo

  fi
}

risk_vpn_setup_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn setup - Manage, import network configurations and run associated setup wizards\n"
    echo

  else
    printf "risk vpn setup - Manage, import network configurations and run associated setup wizards\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn setup VM [OPTIONS]\n"
  printf "  risk vpn setup --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--set-default"
    printf "    Set this VM as the default NetVM for all identity client VMs (browsers,\n    messaging, etc)\n"
    echo

    printf "  %s\n" "--netvm, -n VM"
    printf "    NetVM to use for the gateway\n"
    echo

    printf "  %s\n" "--config-in CONFIG_VM"
    printf "    VM in which to browse for VPN configuration(s)\n"
    echo

    printf "  %s\n" "--choose"
    printf "    Choose an existing client config by running the setup wizard in the VPN VM\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to operate setup on\n"
    echo

  fi
}

risk_vpn_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn start - Start a VPN gateway in the background\n"
    echo

  else
    printf "risk vpn start - Start a VPN gateway in the background\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn start VM\n"
  printf "  risk vpn start --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to start\n"
    echo

  fi
}

risk_vpn_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn stop - Stop a VPN gateway\n"
    echo

  else
    printf "risk vpn stop - Stop a VPN gateway\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn stop VM\n"
  printf "  risk vpn stop --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to stop\n"
    echo

  fi
}

risk_vpn_enable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn enable - Automatically start a VPN gateway when starting the identity.\n"
    echo

  else
    printf "risk vpn enable - Automatically start a VPN gateway when starting the identity.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn enable VM\n"
  printf "  risk vpn enable --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to enable autostart for\n"
    echo

  fi
}

risk_vpn_disable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn disable - Do not autostart this VM when the identity is started\n"
    echo

  else
    printf "risk vpn disable - Do not autostart this VM when the identity is started\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn disable VM\n"
  printf "  risk vpn disable --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to disable autostart for\n"
    echo

  fi
}

risk_vpn_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn delete - Delete a VPN gateway\n"
    echo

  else
    printf "risk vpn delete - Delete a VPN gateway\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn delete VM\n"
  printf "  risk vpn delete --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to delete\n"
    echo

  fi
}

risk_qube_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk qube - Manage qubes (identity settings, update/enable/disable, etc)\n"
    echo

  else
    printf "risk qube - Manage qubes (identity settings, update/enable/disable, etc)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk qube COMMAND\n"
  printf "  risk qube [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Tag an existing VM as belonging to the active identity, and change its netVM if one is already set\n" "$(red "add")         "
  printf "  %s   Delete a VM belonging to the current identity\n" "$(red "delete")      "
  printf "  %s   Enable an identity VM to autostart\n" "$(red "enable")      "
  printf "  %s   Disable an identity VM to autostart\n" "$(red "disable")     "
  printf "  %s   Show all qubes belonging to the active identity\n" "$(red "list")        "
  printf "  %s   Update one or more VM templates, by name patterns or filters\n" "$(red "update")      "
  printf "  %s   Upgrade the distribution of a Qube template\n" "$(red "dist-upgrade")"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_qube_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk qube add - Tag an existing VM as belonging to the active identity, and change its netVM if one is already set\n"
    echo

  else
    printf "risk qube add - Tag an existing VM as belonging to the active identity, and change its netVM if one is already set\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk qube add VM [OPTIONS]\n"
  printf "  risk qube add --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--netvm, -n VM"
    printf "    NetVM to use for this VM\n"
    echo

    printf "  %s\n" "--set-default"
    printf "    If VM provides network, set this VM as default NetVM for identity\n"
    echo

    printf "  %s\n" "--enable, -E"
    printf "    Autostart this VM when the identity is started\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    VM to tag with identity settings\n"
    echo

  fi
}

risk_qube_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk qube delete - Delete a VM belonging to the current identity\n"
    echo

  else
    printf "risk qube delete - Delete a VM belonging to the current identity\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk qube delete VM\n"
  printf "  risk qube delete --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    VM to delete\n"
    echo

  fi
}

risk_qube_enable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk qube enable - Enable an identity VM to autostart\n"
    echo

  else
    printf "risk qube enable - Enable an identity VM to autostart\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk qube enable VM\n"
  printf "  risk qube enable --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    VM to enable for autostart\n"
    echo

  fi
}

risk_qube_disable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk qube disable - Disable an identity VM to autostart\n"
    echo

  else
    printf "risk qube disable - Disable an identity VM to autostart\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk qube disable VM\n"
  printf "  risk qube disable --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    VM to disable from autostart\n"
    echo

  fi
}

risk_qube_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk qube list - Show all qubes belonging to the active identity\n"
    echo

  else
    printf "risk qube list - Show all qubes belonging to the active identity\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk qube list\n"
  printf "  risk qube list --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_qube_update_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk qube update - Update one or more VM templates, by name patterns or filters\n"
    echo

  else
    printf "risk qube update - Update one or more VM templates, by name patterns or filters\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk qube update [VMS] [OPTIONS] [...]\n"
  printf "  risk qube update --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--identity, -I"
    printf "    Check for templates of all VMs belong to an identity\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VMS")"
    printf "    An arbitrary list of VMs name patterns to update.\n"
    echo

  fi
}

risk_qube_dist_upgrade_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk qube dist-upgrade - Upgrade the distribution of a Qube template\n"
    echo

  else
    printf "risk qube dist-upgrade - Upgrade the distribution of a Qube template\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk qube dist-upgrade VM VERSION\n"
  printf "  risk qube dist-upgrade --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    Name of VM or template to upgrade (if VM, risk will use its template)\n"
    echo

    printf "  %s\n" "$(blue "VERSION")"
    printf "    Name or number of version to upgrade to (eg. 37 for Fedora, or bookworm for\n    Debian)\n"
    echo

  fi
}

risk_use_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk use - Execute a command in a VM belong to an identity.\n"
    echo

  else
    printf "risk use - Execute a command in a VM belong to an identity.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk use VM [...]\n"
  printf "  risk use --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "VM")"
    printf "    VM in which to execute the command\n"
    echo

    printf "The target VM does not mandatorily need to belong to the active identity, if there is one.\nIf it does not belongs to another non-active identity, risk will take care of:\n  - Closing the active identity in the vault\n  - Opening the new one\nAfter this, the target VM is launched with the command arguments.\n\n"
    echo

  fi
}

risk_url_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk url - Browse, bookmark, verify and manage URLS/links\n"
    echo

  else
    printf "risk url - Browse, bookmark, verify and manage URLS/links\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk url COMMAND\n"
  printf "  risk url [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Open a target URL into a target VM, or bookmarks with no arguments.\n" "$(red "open")    "
  printf "  %s   Add an onion to the user/system bookmarks without verifying it.\n" "$(red "bookmark")"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_url_open_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk url open - Open a target URL into a target VM, or bookmarks with no arguments.\n"
    echo

  else
    printf "risk url open - Open a target URL into a target VM, or bookmarks with no arguments.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk url open [URL]\n"
  printf "  risk url open --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "URL")"
    printf "    URL to browse\n"
    echo

  fi
}

risk_url_bookmark_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk url bookmark - Add an onion to the user/system bookmarks without verifying it.\n"
    echo

  else
    printf "risk url bookmark - Add an onion to the user/system bookmarks without verifying it.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk url bookmark [URL] [TITLE]\n"
  printf "  risk url bookmark --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "URL")"
    printf "    URL to bookmark (optional, if empty the split-bookmarks file is opened, or\n    the user is prompted for URL/info)\n"
    echo

    printf "  %s\n" "$(blue "TITLE")"
    printf "    Title of URL page (optional)\n"
    echo

  fi
}

risk_config_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config - Manage the risk global configuration\n"
    echo

  else
    printf "risk config - Manage the risk global configuration\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config COMMAND\n"
  printf "  risk config [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Set a configuration variable to a value\n" "$(red "set")  "
  printf "  %s   Print the value of a configuration variable\n" "$(red "get")  "
  printf "  %s   Delete the value of a configuration variable\n" "$(red "unset")"
  printf "  %s   List all configuration variables\n" "$(red "list") "
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_config_set_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config set - Set a configuration variable to a value\n"
    echo

  else
    printf "risk config set - Set a configuration variable to a value\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config set KEY VALUE\n"
  printf "  risk config set --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to set\n"
    echo

    printf "  %s\n" "$(blue "VALUE")"
    printf "    Value to assign to the key\n"
    echo

  fi
}

risk_config_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config get - Print the value of a configuration variable\n"
    echo

  else
    printf "risk config get - Print the value of a configuration variable\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config get KEY\n"
  printf "  risk config get --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to show\n"
    echo

  fi
}

risk_config_unset_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config unset - Delete the value of a configuration variable\n"
    echo

  else
    printf "risk config unset - Delete the value of a configuration variable\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config unset KEY\n"
  printf "  risk config unset --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to delete/unset\n"
    echo

  fi
}

risk_config_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config list - List all configuration variables\n"
    echo

  else
    printf "risk config list - List all configuration variables\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config list\n"
  printf "  risk config list --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_config_keys_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config keys - List all configuration variables as an array (for completions)\n"
    echo

  else
    printf "risk config keys - List all configuration variables as an array (for completions)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config keys\n"
  printf "  risk config keys --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

risk_help_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk help - Show help about a command\n"
    echo

  else
    printf "risk help - Show help about a command\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk help [COMMAND]\n"
  printf "  risk help --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Arguments:")"

    printf "  %s\n" "$(blue "COMMAND")"
    printf "    Help subject\n"
    echo

  fi
}

normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}

inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

config_init() {
  RISK_CONFIG_FILE=${RISK_CONFIG_FILE-${RISK_DIR}/config.ini}
  [[ -f "$RISK_CONFIG_FILE" ]] || {
      _info "Writing default configuration file to ${RISK_CONFIG_FILE}"
      cat << EOF > "$RISK_CONFIG_FILE"
; RISKS Dom0 Configuration file

; You can either edit this file in place, set values
; through the 'risk config' command.

; Default Templates =============================================== #

; Default Whonix Workstation TemplateVM for TOR clients
WHONIX_WS_TEMPLATE=whonix-ws-16

; Default Whonix Gateway TemplateVM for TOR gateways
WHONIX_GW_TEMPLATE=whonix-gw-16

; Default TemplateVM to use for VPN VMs
VPN_TEMPLATE=

; Default AppVMs ================================================== #
;
; These VMs are used when we create new machines by cloning
; existing ones, instead of creating blank AppVMs from templates.

; Default Whonix Workstation AppVM to use for identity client machine
WHONIX_WS=

; Default AppVM to use for cloning new VPN qubes
VPN_VM=

; Default AppVM to clone for split-browser backend
; If this value is set by you to a given VM, make sure its split-browser
; features function correctly, as this qube will be used for all identities'
; browsing needs. If not set, it will populated by risk when creating the
; dedicated split-browser backend AppVM qube.
SPLIT_BROWSER=

; Template to use when creating a split-browser backend.
; The template should have the corresponding qubes-split-browser package
; installed, see risk documentation for installation instructions.
; SPLIT_BROWSER_TEMPLATE=

; Vault settings ================================================== #

; Default vault VM
VAULT_VM=vault

; Qubes path to hush device, such as 'dom0:mmcblk01', or 'sys-usb:sda2', etc
SDCARD_BLOCK=

; Qubes path to backup device, such as 'sys-usb:sdb1'
BACKUP_BLOCK=

; If true, AUTO_MOUNT_HUSH will automatically run the risks hush mount
; command in the target vault when invoking 'risk hush attach', prompting
; the user for the device password. Equivalent to 'risk hush attach -m'
AUTO_MOUNT_HUSH=false

; Other network settings ========================================= #

; Default VM to use as a firewall VM, to which either Tor or VPN gateways are bound
DEFAULT_NETVM=sys-firewall

; Default path to VPN client config in VPN VM, to be loaded when the service
; starts. This path is the default one used by qubes-vpn-support installs.
DEFAULT_VPN_CLIENT_CONF='/rw/config/vpn/vpn-client.conf'

; General Application Settings =================================== #

; Default terminal to use in Dom0
DOM0_TERMINAL=xterm

; Default shell to use in Dom0
DOM0_SHELL=bash

; Default terminal to use in AppVMs
VM_TERMINAL=xterm

; Default shell to use in AppVMs
VM_SHELL=bash

EOF
  }
}

config_get() {
  # zsh compat
  setopt local_options BASH_REMATCH

  local key=$1
  local regex="^$key *= *(.+)$"
  local value=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      value="${BASH_REMATCH[2]}" # Changed to 2 because ZSH indexes start at 1
      break
    fi
  done < "$RISK_CONFIG_FILE"

  echo "$value"
}

config_set() {
  # zsh compat
  setopt local_options BASH_REMATCH

  local key=$1
  shift
  local value="$*"

  config_init

  local regex="^($key) *= *.+$"
  local output=""
  local found_key=""
  local newline

  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line =~ $regex ]]; then
      found_key="${BASH_REMATCH[2]}"
      newline="$key = $value"
      output="$output$newline\n"
    elif [[ $line ]]; then
      output="$output$line\n"
    fi
  done < "$RISK_CONFIG_FILE"

  if [[ -z $found_key ]]; then
    output="$output$key = $value\n"
  fi

  printf "%b\n" "$output" > "$RISK_CONFIG_FILE"
}

config_del() {
  local key=$1

  local regex="^($key) *="
  local output=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line ]] && [[ ! $line =~ $regex ]]; then
      output="$output$line\n"
    fi
  done < "$RISK_CONFIG_FILE"

  printf "%b\n" "$output" > "$RISK_CONFIG_FILE"
}

config_show() {
  config_init
  cat "$RISK_CONFIG_FILE"
}

config_keys() {
  # zsh compat
  setopt local_options BASH_REMATCH

  local regex="^([a-zA-Z0-9_\-\/\.]+) *="

  config_init

  local keys=()
  local key

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      key="${BASH_REMATCH[1]}"
      key="${key//\=/}"
      [[ -n "$key" ]] && keys+=("$key")
    fi
  done < "$RISK_CONFIG_FILE"
  echo "${keys[@]}"
}

config_has_key() {
  [[ $(config_get "$1") ]]
}

# crypt.filename takes a filename as input, and uses the currently
# set identity to produce an random name to use as a file/directory name.
function crypt.filename ()
{
    local encryption_key_cmd="echo -n '$1' | spectre -q -n -s 0 -F n -t n -u '$1' file_encryption_key"
    encryption_key="$(qvm-run --pass-io "$VAULT_VM" "$encryption_key_cmd")"

    local encrypted_identity_command="echo -n '$encryption_key' | spectre -q -n -s 0 -F n -t n -u $IDENTITY $1"

    # -q            Quiet: just output the password/filename
    # -n            Don't append a newline to the password output
    # -s 0          Read passphrase from stdinput (fd 0)
    # -F n          No config file output
    # -t n          Output a nine characters name, without symbols
    # -u ${user}    User for which to produce the password/name
    print "$(qvm-run --pass-io "$VAULT_VM" "$encrypted_identity_command")"
}

# device.fail_not_attached_to exits the program if a given block device
# (in QubesOS notation, ex. sys-usb:sda2) is not attached to a given VM.
# $1 - Device name
# $2 - Target qube VM
function device.fail_not_attached_to ()
{
    local block="$1"
    local vm="$2"
    local ovm

    ovm=$(qvm-block list | grep "${block}" | awk '{print $4}' | cut -d" " -f1)
    if [[ ${#ovm} -eq 0 ]] || [[ ${ovm} != "$vm" ]]; then
        _failure "Device block $block is not mounted on vault ${vm}"
    fi
}

# device.backup_mounted_on returns 0 if a backup is mounted in the target vault VM.
# $1 - Qube name (defaults to VAULT_VM)
function device.backup_mounted_on ()
{
    local vm="${1-$VAULT_VM}"
    local backup_status

    backup_status="$(qvm-run --pass-io "${vm}" 'risks backup status')"
    if [[ ${backup_status} =~ 'No backup device mounted' ]]; then
        return 1
    fi
}

# ========================================================================================
# Identity setup / script values

# ========================================================================================

# identity.set is used to propagate our various IDENTITY related variables
# so that all functions that will be subsequently called can access them.
# This function also takes care of checking if there is already an active
# identity that should be used, in case the argument is empty or none.
#
# $1 - The identity to use.
function identity.set ()
{
    local identity="$1"

    # This will throw an error if we don't have an identity from any source.
    IDENTITY=$(identity.active_or_specified "$identity")
    _catch "Command requires either an identity to be active or given as argument"

    # Other settings.
    IDENTITY_BOOKMARKS_FILE="/home/user/.tomb/mgmt/$(crypt.filename bookmarks.tsv)"
}

# identity.set_active sets the name as an ENV variable that we can use in further functions and commands.
# This function slightly differs from identity.set in that it does not set the active identity and its
# values in the script run itself: it only populates stuff that is to be used in other calls of risks.
#
# $1 - The name to use. If empty, just resets the identity.
function identity.set_active ()
{
    # If the identity is empty, wipe the identity file
    if [[ -z ${1} ]] && [[ -e ${RISK_IDENTITY_FILE} ]]; then
        identity=$(cat "${RISK_IDENTITY_FILE}")
        rm "${RISK_IDENTITY_FILE}" || _warning "Failed to wipe identity file !"

        _verbose "Identity '${identity}' is now inactive, (name file deleted)"
        _info "Identity '${identity}' is now INACTIVE"
        return
    fi

    # If we don't have a file containing the
    # identity name, populate it.
    if [[ ! -e ${RISK_IDENTITY_FILE} ]]; then
        print "$1" > "${RISK_IDENTITY_FILE}"
    fi

    _verbose "Identity '${1}' is now active (name file written)"
    _info "Identity '${1}' is now ACTIVE"
}

# identity.active returns the name of the vault active identity.
function identity.active ()
{
    qvm-run --pass-io "$VAULT_VM" 'risks identity active' 2>/dev/null
}

# identity.is_active returns 0 if an identity is unlocked, 1 if not.
function identity.is_active ()
{
    local active_identity

    active_identity=$(qvm-run --pass-io "$VAULT_VM" 'risks identity active' 2>/dev/null)
    if [[ -z "${active_identity}" ]]; then
        return 1
    fi

    return 0
}

# identity.active_or_specified checks that either an identity is active,
# or that the passed argument is not empty. If the identity is not empty
# it is echoed back to the caller.
#
# $1 - An identity name
#
# Returns:
# 0 - Identity is non-nil, provided either from arg or by the active
# 1 - None have been given
function identity.active_or_specified ()
{
    local active_identity

    if [[ -z "${1}" ]] ; then
        active_identity=$(qvm-run --pass-io "$VAULT_VM" 'risks identity active' 2>/dev/null)
        if [[ -z "${active_identity}" ]]; then
            return 1
        fi
    fi

    # Print the identity
    if [[ -n "${1}" ]]; then
        print "${1}" && return
    fi

    print "$active_identity"
}

# identity.get_args_name either returns the name given as parameter, or
# generates a random (burner) one and prints it to the screen.
function identity.get_args_name ()
{
    local name

    if [[ -z "${1}" ]] && [[ "${args['--burner']}" -eq 0 ]]; then
        _failure "Either an identity name is required, or the --burner flag"
    fi

    # Either use the provided one
    if [[ -n "${1}" ]]; then
        name="${1}"
    elif [[ "${args['--burner']}" -eq 1 ]]; then
        name="$(rig -m | head -n 1)"
        name="${name// /_}"
    fi

    print "${name}"
}

# identity.get_args_mail returns a correctly formatted mail given either a fully specified
# one as positional, or a generated/concatenated one from the username argument.
function identity.get_args_mail ()
{
    local name="$1"
    local email="$2"

    [[ -n "${email}" ]] && print "${email}" && return

    email="${args['--mail']}"

    if [[ -n "${email}" ]]; then
        # Return either the mail provider flag with the name
        print "${name}@${email}"
    else
        # Or the lowercase name without spaces
        print "${name// /_}"
    fi
}

# identity.get_args_expiry returns a correctly formatted expiry date for a GPG key.
# If no arguments are passed to the call, the expiry date is never.
function identity.get_args_expiry ()
{
    local expiry

    if [[ -z "${1}" ]]; then
        expiry_date="never"
    else
        expiry="${1}"
        expiry_date="$(date +"%Y-%m-%d" --date="${expiry}")"
    fi

    print "${expiry_date}"
}

# identity.delete_home_directory deletes the ~/.risk/identities/<identity> directory.
function identity.delete_home_directory ()
{
    if ! _identity_active ; then
        return
    fi
    if [[ -z "${IDENTITY_DIR}" ]]; then
        return
    fi

    _info "Deleting identiy ${IDENTITY} home directory"
    _run -rf "${IDENTITY_DIR}"
}

# ========================================================================================
# Identity failsafes / checks
# ========================================================================================

# identity.fail_none_active exits the program if there is no identity active or specified with args.
function identity.fail_none_active ()
{
    active_identity=$(qvm-run --pass-io "$VAULT_VM" 'risks identity active' 2>/dev/null)
    [[ -z "${active_identity}" ]] && _failure "No active identity in vault"
}

# identity.fail_other_active exits the program if another identity is already active (opened in vault).
function identity.fail_other_active ()
{
    active_identity=$(qvm-run --pass-io "$VAULT_VM" 'risks identity active' 2>/dev/null)

    if [[ -n $active_identity ]]; then
        if [[ $active_identity == "$IDENTITY" ]]; then
            return
        fi

        _failure "Identity $active_identity is active. Close/slam/fold it and rerun this command"
    fi
}

# identity.fail_unknown exits the program if an identity does not exist in the vault VM.

# $1 - Identity name
function identity.fail_unknown ()
{
    # Attempt to resolve the coffin with the name
    encrypted_identity="$(qvm-run --pass-io "${VAULT_VM}" "risks resolve coffin ${IDENTITY}")"

    # And check the directory exists
    _run_exec "$VAULT_VM" "stat ${encrypted_identity} &>/dev/null"
    _catch "Invalid identity: $IDENTITY does not exists in ${VAULT_VM}"
}

# identity.fail_exists exits the program if the given identity name already exists in the vault.
function identity.fail_exists ()
{
    # Get the resulting encrypted name
    local encrypted_identity
    encrypted_identity="$(crypt.filename "${IDENTITY}")"

    # And check the directory exists
    qvm-run --pass-io "$VAULT_VM" "stat /home/user/.graveyard/$encrypted_identity &>/dev/null"
    [[ $? -eq 0 ]] && _failure "Identity ${IDENTITY} already exists in ${VAULT_VM}"
}

# ========================================================================================
# Identity configuration values

# ========================================================================================

# identity.set_global_props analyzes the command-line flags and uses some of them
# to configure stuff about the identity's qubes, such as their colors/prefixes/netvms, etc.
# Requires access to command-line flags, and needs $IDENTITY to be set.
function identity.set_global_props ()
{
    [[ -z "${IDENTITY}" ]] && return

    local prefix label

    _warning "Global identity qubes settings"

    # Qube name prefix
    prefix="${args['--prefix']-$IDENTITY}"
    _info "VM prefix:    $prefix"
    identity.config_set QUBE_PREFIX "${prefix}"

    # Qube labels (colors)
    label="${args['--label']-orange}"
    _info "Label:        $label"
    identity.config_set QUBE_LABEL "${label}"

    # Default network VM
    identity.config_set NETVM_QUBE "$(config_get DEFAULT_NETVM)"
}

# identity.config_set uses 'risks kv set' in vault to store a key-value pair.
function identity.config_set ()
{
    identity.is_active || return

    local key="${1}"
    shift
    local value="$*"

    [[ -z "${key}" || -z "${value}" ]] && return

    _run_qube "$VAULT_VM" risks kv set "${key}" "${value}"
}

# identity.config_get uses 'risks kv get' in vault to retrieve a key-value pair.
function identity.config_get ()
{
    identity.is_active || return

    local key="${1}"
    [[ -z "${key}" ]] && return

    _run_exec "$VAULT_VM" risks kv get "${key}"
}

# identity.config_unset uses 'risks kv unset' in vault to delete a key-value pair.
function identity.config_unset ()
{
    identity.is_active || return

    local key="${1}"
    [[ -z "${key}" ]] && return

    _run_qube "$VAULT_VM" risks kv unset "${key}"
}

# identity.config_append uses 'risks kv set' and 'risks kv get' to append a value
# to an existing key-value pair (as an array), or creates it if does not exist yet.
function identity.config_append ()
{
    identity.is_active || return

    local key="${1}"
    shift
    local value="$*"

    [[ -z "${key}" || -z "${value}" ]] && return

    _run_qube "$VAULT_VM" risks kv append "${key}" "${value}"
}

# identity.config_reduce uses 'risks kv get', 'risks kv get' and 'sed' to remove a

# value from an existing key-value pair (as an array) in the vault key-value store.
function identity.config_reduce ()
{
    identity.is_active || return

    local key="${1}"
    shift
    local values=("$@")

    [[ -z "${key}" || -z "${values[*]}" ]] && return

    _run_qube "$VAULT_VM" risks kv filter "${key}" "${values[@]}"
}

# identity.config_clear uses 'risks kv clean' in vault to clear all key-value pairs.
function identity.config_clear ()
{
    identity.is_active || return

    _run_qube "$VAULT_VM" risks kv clean
}

# ========================================================================================
# Virtual machines / equipment functions
# ========================================================================================

# identity.netvm returns the default network VM for the active identity
function identity.netvm ()
{
    identity.config_get NETVM_QUBE 2>/dev/null
}

# identity.vm_label returns the default VM label/color for an identity
function identity.vm_label ()
{
    identity.config_get QUBE_LABEL 2>/dev/null
}

# identity.tor_gateway returns the TOR gateway for the identity
function identity.tor_gateway ()
{
    identity.config_get TOR_QUBE 2>/dev/null
}

# identity.browser_qube returns the browser VM for the identity
function identity.browser_qube ()
{
    identity.config_get BROWSER_QUBE 2>/dev/null
}

# identity.proxy_qubes returns an array of proxy VMs
# (VPNs and TOR gateways for the current identity)
function identity.proxy_qubes ()
{
    local proxy_qubes
    proxy_qubes=$(identity.config_get PROXY_QUBES)
    [[ -n "${proxy_qubes}" ]] || return

    read -d '' -rA proxies <<< "${proxy_qubes}"
    echo "${proxies[@]}"
}

# identity.client_qubes returns all identity VMs that are not gateways/proxies,
# but are potentially (most of the time) accessing network from one or more of

# these gateways.
function identity.client_qubes ()
{
    local client_qubes
    client_qubes=$(identity.config_get CLIENT_QUBES)
    [[ -n "${client_qubes}" ]] || return

    read -d '' -rA clients <<< "${client_qubes}"
    echo "${clients[@]}"
}

# identity.enabled_qubes returns all identity VMs that are

# not gateways/proxies, but are potentially (most of the time)

# accessing network from one or more of these gateways.
function identity.enabled_qubes ()
{
    local autostart_qubes
    autostart_qubes=$(identity.config_get AUTOSTART_QUBES)
    [[ -n "${autostart_qubes}" ]] || return

    read -d '' -rA clients <<< "${autostart_qubes}"
    echo "${clients[@]}"
}

# identity.shutdown_qubes powers off all running VMs belonging to the identity.
function identity.shutdown_qubes ()
{
    local clients proxies tor_gateway browser_vm other_vms

    # Client VMs
    read -rA clients < <(identity.client_qubes)
    for vm in "${clients[@]}" ; do
        [[ $(qube.is_running "${vm}") -gt 0 ]] && continue

        [[ -z "${vm}" ]] && continue

        _info "Shutting down $vm"
        qube.shutdown "$vm"
    done

    # Browser VMs (disposables to find from template/tag)
    browser_vm="$(identity.browser_qube)"
    if [[ -n "${browser_vm}" ]]; then
        if qube.is_running "${browser_vm}"; then
            _info "Shutting down $browser_vm"
            qube.shutdown "$browser_vm"
        fi
    fi

    # Proxy VMs
    read -rA proxies < <(identity.proxy_qubes)
    for vm in "${proxies[@]}" ; do
        [[ -z "${vm}" ]] && continue
        [[ $(qube.is_running "${vm}") -gt 0 ]] && continue

        _info "Shutting down $vm"
        qube.shutdown "$vm"
    done

    # Tor gateway.
    tor_gateway="$(identity.tor_gateway)"
    if [[ -n "${tor_gateway}" ]]; then
        if qube.is_running "${tor_gateway}"; then
            _info "Shutting down $tor_gateway"
            qube.shutdown "$tor_gateway"
        fi
    fi

    # Other VMs that are tagged with the identity.
    read -rA other_vms < <(qubes.list_all)
    for vm in "${other_vms[@]}" ; do
        [[ -z "${vm}" ]] && continue

        if qube.is_running "${vm}"; then
            if [[ "$(qube.owner "${vm}")" == "${IDENTITY}" ]]; then
                _info "Shutting down $vm"
                qube.shutdown "$vm"
            fi
        fi
    done
}

# identity.delete_qubes deletes all VMs belonging to an identity.
function identity.delete_qubes ()
{
    local clients proxies tor_gateway browser_vm other_vms

    # Client VMs
    read -rA clients < <(identity.client_qubes)
    for client in "${clients[@]}"; do
        qube.delete "${client}" CLIENT_QUBES
    done
    identity.config_unset CLIENT_QUBES

    # Browser VM
    browser_vm="$(identity.browser_qube)"
    if [[ -n "${browser_vm}" ]]; then
        qube.delete "${browser_vm}" BROWSER_QUBE
        identity.config_unset BROWSER_QUBE
    fi

    # Proxy VMs
    read -rA proxies < <(identity.proxy_qubes)
    for proxy in "${proxies[@]}"; do
        qube.delete "${proxy}" PROXY_QUBES
    done
    identity.config_unset PROXY_QUBES

    # Tor gateway.
    tor_gateway="$(identity.tor_gateway)"
    if [[ -n "${tor_gateway}" ]]; then
        qube.delete "${tor_gateway}" TOR_QUBE
        identity.config_unset TOR_QUBE
    fi

    # Other VMs that are tagged with the identity.
    read -rA other_vms < <(qubes.list_all)
    for vm in "${other_vms[@]}"; do
        if [[ "$(qube.owner "${vm}")" == "${IDENTITY}" ]]; then
            qube.delete "${vm}"
        fi
    done
}


# If the user wants to log command output to a file.
risk_log_file=""

# Section is set either by functions or simple calls,
# so that logging can inform on the component working.
section='risk'

# When multiple sections are used within a single risks
# operation, we padd them, for clearer/better aesthetics.
section_padding=6

# Last log level used. Inline logging uses this.
last_level="message"

# maps levels to their display color
declare -A log_colors
log_colors=(
    [verbose]="blue"
    [message]="default"
    [warning]="yellow"
    [success]="green"
    [failure]="red"
)

# maps levels to notice characters.
declare -A log_chars
log_chars=(
    [inline]=" > "
    [verbose]="[D]"
    [message]=" . "
    [warning]="[W]"
    [success]="(*)"
    [failure]="[E]"
)


# _init_log_file creates the log file if does not exist,
# and exits the script in case of failure, or if the file
# is not writable.
function _init_log_file ()
{
    risk_log_file="${args['--log-file']}"
    [[ -z "${risk_log_file}" ]] && return

    # Ensure not a directory, and if exists, is writable.
    if [[ -d "${risk_log_file}" ]] ; then
        risk_log_file=''
        _failure "Log file ${risk_log_file} is a directory"
    elif [[ -e "${risk_log_file}" ]] && [[ ! -w "${risk_log_file}" ]]; then
        risk_log_file=''
        _failure "Log file ${risk_log_file} is not writable"
    fi

    # Create the file if not existing, or fail.
    if [[ ! -e "${risk_log_file}" ]]; then
        _run touch "${risk_log_file}"
        _catch "Failed to create log file ${risk_log_file}"
        _info "Logging command output to file ${risk_log_file}"
    fi
}

# Simple way of setting the section and to update the padding
_in_section ()
{
    section="$1"
    if [[ "${#1}" -gt "${section_padding}" ]]; then
        section_padding="${#1}"
    fi

    if [[ -n "${2}" ]]; then
        section_padding="$2"
    fi
}

function is_verbose_set ()

{
    if [[ "${args['--verbose']}" -eq 1 ]]; then
        return 0
    else
        return 1
    fi
}

# Messaging function with pretty coloring
function _msg ()
{
    # Check if we have been provided a section name,
    # and if not, that the section is set to a default.
    if [[ ${#@} -lt 3 ]]; then
        local progname="$section"
        if [[ -z "$progname" ]]; then
            progname='risk'
        fi
        local msg="$2"
    else
        local progname="$2"
        local msg="$3"
    fi

    # Padd the program/section name
    progname="$(printf %"${section_padding}"s "${progname}")"

    # Apply any translation for non-english users
	# local i
	# command -v gettext 1>/dev/null 2>/dev/null && msg="$(gettext -s "$3")"
	# for i in {3..${#}}; do
	# 	msg=${(S)msg//::$(($i - 2))*::/$*[$i]}
	# done

    # Apply log chars & color
    local pcolor=${log_colors[$1]}
    local pchars=${log_chars[$1]}

    # Use the display of last message when inline
    [[ "$1" == "inline" ]] && { pcolor=${log_colors[$last_level]}; pchars=${log_chars[inline]} }
    last_level="$1"

	local command="print -P"
	local fd=2
	local -i returncode

	case "$1" in
		inline)
			command+=" -n"
			;;
		failure)
			returncode=1
			;;
		print)
			progname=""
			fd=1
			;;
		# *)
		# 	pchars="[F]"; pcolor="red"
		# 	msg="Developer oops!  Usage: _msg MESSAGE_TYPE \"MESSAGE_CONTENT\""
		# 	returncode=127
			# ;;
	esac

	[[ -n $_MSG_FD_OVERRIDE ]] && fd=$_MSG_FD_OVERRIDE

    # If there is a log-file specified, write the output to it.

    if [[ -n "${risk_log_file}" ]]; then
        ${=command} "${progname}" "${pchars}" "${msg}" >> "$risk_log_file"
    fi

    # Else, print to stdout, with colors
	if [[ -t $fd ]]; then
       [[ -n "$progname" ]] && progname="${fg[magenta]}$progname$reset_color"
       [[ -n "$pchars" ]] && pchars="${fg_bold[$pcolor]}$pchars$reset_color"
       msg="$fg[$pcolor]$msg$reset_color"
	fi

    ${=command} "${progname}" "${pchars}" "${msg}" >&"$fd"
	return $returncode
}

function _info ()

{
	local notice="message"
	[[ "$1" = "-n" ]] && shift && notice="inline"
    option_is_set -q || _msg "$notice" "$@"
	return 0
}

function _verbose ()

{
    is_verbose_set && _msg verbose "$@"
	return 0
}

function _success()

{
    option_is_set -q || _msg success "$@"
	return 0
}

function _warning ()

{
    option_is_set -q || _msg warning "$@"
	return 1
}

# failure first prints the message we have passed following the catch
# of an error exit code, and then looks at the contents of erroring
# command's stderr buffer, which is printed just below our message.
# We then exit the program.
function _failure ()
{
	typeset -i exitcode=${exitv:-1}

    _msg failure "$@"

    # Trim the message from any risks/risq header and print
    if [[ -n "$COMMAND_STDERR" ]]; then
        stderr=$(sed -r 's/^(risks|risq) \[[^][]*\]//' <<< "${COMMAND_STDERR}")
        stderr=$(sed -r 's/^(risks|risq)[ ]{1,}>//' <<< "${stderr}")
        stderr=$(sed -r 's/^[ ]{1,}//' <<< "${stderr}")

        _msg inline "$stderr"
    fi

	# Be sure we forget the secrets we were told
    exit "$exitcode"
}

# function _failure() {
# 	typeset -i exitcode=${exitv:-1}
#     option_is_set -q || _msg failure "$@"
# 	# be sure we forget the secrets we were told
#     exit "$exitcode"
# }

function _print ()

{
    option_is_set -q || _msg print "$@"
	return 0
}

#

# checkqube.owner verifies that the VM is owned by the current identity.
function network.fail_invalid_netvm ()
{
    local vm="$1"
    local owner
    local tor_gw

    # Or if the owner is either non-existant or not the good one, we must fail.
    owner="$(qube.owner "$vm")"
    [[ -n "$owner" ]] || _failure "VM $vm has no RISKS owner. Aborting"
    [[ "$owner" == "$IDENTITY" ]] || _failure "VM $vm does not belong to identity $IDENTITY"

    # If there is not network VM, there is nothing to do
    netvm="$(qvm-prefs "$vm" netvm)"
    [[ -z "$netvm" ]] && return 0

    # If the VM is the whonix gateway for the identity, we are done with the chain
    [[ "$vm" == "$(identity.tor_gateway)" ]] && return 0

    # We also return if its the sys-firewall, which does not belong to any identity.
    [[ "$vm" == "$(config_get DEFAULT_NETVM)" ]] && return 0

    # Or check if the netVM is in one of the identity proxies, or if its the default VM
    qube.is_identity_proxy "$netvm" || _failure "NetworkVM $vm is not listed as one of the identity's proxies"

    # Else, we go on with the netvm and do the same steps
    network.fail_invalid_netvm "$netvm"
}

# network.fail_invalid_chain verifies that the NetVM of a given VM indeed belongs
# to the same owner, and does this recursively for each NetVM found in the chain.
function network.fail_invalid_chain ()
{
    local vm="$1"
    local netvm
    local owner

    _verbose "Checking network chain (starting from VM $vm)"

    # If there is not network VM, there is nothing to do
    netvm="$(qvm-prefs "$vm" netvm)"
    [[ -z "$netvm" ]] && return 0

    # This call recursively checks for all netVMs
    network.fail_invalid_netvm "$netvm"
}

# network.fail_networked_qube fails if the VM provides network to any other VM
function network.fail_networked_qube ()
{
    local vm="$1"
    local vms connected_vms

    # If it does not provide network at all, don't go further.
    [[ $(qvm-prefs "$vm" provides_network) == "True" ]] || return 0

    # Check if it provides network to any VM, and if yes, fail.
    read -rA vms < <(qubes.list_all)
    for svm in "${vms[@]}" ; do
        [[ -z "${svm}" ]] && continue

        if [[ "$(qvm-prefs "$svm" netvm 2>/dev/null)" == "$vm" ]]; then
            connected_vms+=( "$svm" )
        fi
    done

    [[ ${#connected_vms} -gt 0 ]] && _failure "VM $vm is NetVM for [ ${connected_vms[*]} ] VMs"
}

#
# ========================================================================================
# Attributes functions
# ========================================================================================
#
# Functions starting with an underscore
# give information and values related to VMs,
#

# qube.exists returns 0 if the qube is found, or 1 if not.
# $1 - Qube name
function qube.exists ()
{
    vm=""
    for item in $(qvm-ls --raw-list | grep -v dom0)
    do
        if [ "${item}" == "${1}" ]; then
            vm=${1}
        fi
    done
    if [ ${#vm} -eq 0 ]; then
        return 1
    fi

    return 0
}

# Returns the name of the identity to which a VM belongs.
# $1 - Qube name
function qube.owner ()
{
    qvm-tags "$1" | grep "^$IDENTITY\$" 2>/dev/null
}

# qube.is_identity_proxy verifies that the identity's proxy VMs arrays contains a given VM.
# $1 - Qube name
function qube.is_identity_proxy ()
{
    local vm="$1"
    local match proxies

    match=1
    read -rA proxies < <(identity.proxy_qubes)

    for proxy in "${proxies[@]}"; do
        if [[ $vm == "$proxy" ]]; then
            match=0
            break
        fi
    done

    return $match
}

# qube.root_template returns the updateable template of a given VM.
# Example: if a disposable VM is given as argument, the first resolved
# template is the dispvm template, which itself is an AppVM, so we get
# the template of the dispvm template.
# $1 - Qube name
function qube.root_template ()
{
    local vm="${1}"
    local updateable

    # If VM is a template itself, return it.
    [[ "$(qvm-prefs "${vm}" klass)" == TemplateVM ]] && echo "${vm}" && return

    # Or get the template, and check it can be updated.
    # If not, recursively look for the first updateable template.
    template="$(qvm-prefs "${vm}" template 2>/dev/null)"
    updateable="$(qvm-prefs "${template}" updateable 2>/dev/null)"

    while [[ "${updateable}" == "False" ]]; do
        template="$(qvm-prefs "${template}" template 2>/dev/null)"
        updateable="$(qvm-prefs "${template}" updateable 2>/dev/null)"
    done

    echo "${template}"
}

# qube.command_args returns a list of VMs that are either explicitly named
# in the array passed as arguments, or those belonging to some
# "group keyword" of this same array.
# $@ - Any number of qubes' names, patterns or group keywords.
function qube.command_args ()
{
    local vms=("$@")
    local all=()
    local can_update=()
    local updatevm

    [[ -z "${vms[*]}" ]] && return

    # All updateable VMs, except the updater one
    read -rA can_update < <(qubes.list_all_updateable)
    updatevm="$(qubes.updatevm_template)"
    read -rA can_update <<< "${can_update:#$~updatevm}"

    for word in "${vms[@]}"; do
        case "${word}" in
            torbrowser|dom0)
                # Tor browser is handled in the risk_qube_update_command function.
                # Dom0 is handled in the risk_qube_update_command function.
                ;;
            all)
                # Update all the VMs that can be updated.
                all+=( "${updatevm}" )
                all+=( "${can_update[@]}" )
                ;;
            *cacher)
                # Update the template of the cacher (update) VM
                all+=( "${updatevm}" )
                ;;
            *)
                # Else find qubes matching the argument exactly.
                # Matching, check not added twice to the list.
                template="$(qube.root_template "${word}")"

                local found=false
                for queued in "${all[@]}"; do
                    [[ "$queued" == "$template" ]] && found=true && break
                done

                [[ $found == false ]] && all+=( "${template}" )
                ;;
        esac

    done

    echo "${all[@]}"
}

# qube.is_browser_instance returns 0 if the qube is either

# the identity browser qube itself, or a disposable based on it.
# $1 - Qube name
function qube.is_browser_instance ()
{
    local qube="$1"
    local qube_class

    [[ "${qube}" == "dom0" ]] && return 1
    [[ -z "${qube}" ]] && return 1

    # Get the type of qube, and return if not compatible.
    qube_class="$(qvm-prefs "${qube}" klass 2>/dev/null)"
    [[ "${qube_class}" == "TemplateVM" ]] && return 1

    # If it's a disposable, use the template.
    if [[ "${qube_class}" == "DispVM" ]]; then
        qube="$(qvm-prefs "${qube}" template)"

    fi

    [[ "${qube}" == "$(identity.browser_qube)" ]] || return 1
}

# qube.distribution returns the name of the Linux flavor of a qube,
# (eg. fedora, debian (for all debian-based), arch, etc ) based on

# the package manager used by the qube.
# $1 - Qube name
function qube.distribution ()
{
    local vm="${1}"

    if _run_qube "${vm}" which dnf; then
        print "fedora"
    elif _run_qube "${vm}" which apt; then
        print "debian"
    elif _run_qube "${vm}" which pacman; then
        print "arch"
    fi
}

# qube.dist_upgrade upgrades the target Qube template to a given version
# (name or number), adapting the process depending on the distribution.
# If the template is already to the target version, nothing is done.
# $1 - Template to upgrade.
# $2 - Name of linux distribution (lowercase, fedora/debian)
# $3 - Target version (number or name) to upgrade to.
function qube.dist_upgrade ()
{
    local vm dist version

    vm="$1"
    dist="$2"
    version="$3"

    if [[ "${dist}" == "fedora" ]]; then
        # Verify we are not already to the current version
        release_file="$(qvm-run --pass-io "${vm}" cat /etc/os-release)"
        current="$( echo "${release_file}" | sed -n 's/^VERSION_ID=//p')"

        if [[ "${current}" == "${version}" ]]; then
            _info "Template ${vm} is already to the target version ${version}"
            return
        fi

        # Else, we're good to upgrade.
        _info "Cleaning package cache"
        _run_qube "${vm}" sudo dnf clean all
        _info "Starting dist upgrade"
        _run_qube_term "${vm}" sudo dnf --releasever="${dist}" --best --allowerasing distro-sync
        _info "Trimming disk"
        _run_qube "${vm}" fstrim -v /

    elif [[ "${dist}" == "debian" ]]; then
        # Verify we are not already to the current version
        local current release_file

        _info "Changing repository source names"
        release_file="$(qvm-run --pass-io "${vm}" cat /etc/os-release)"
        current="$( echo "${release_file}" | sed -n 's/^VERSION_CODENAME=//p')"

        if [[ "${current}" == "${version}" ]]; then
            _info "Template ${vm} is already to the target version ${version}"
            return
        fi

        # Else, we're good to upgrade, change repository versions.
        _run_qube "${vm}" sudo sed -i "'s/${current}/${dist}/g'" /etc/apt/sources.list
        _run_qube "${vm}" sudo sed -i "'s/${current}/${dist}/g'" /etc/apt/sources.list.d/qubes-r4.list
        _run_qube "${vm}" sudo sed -i "'s/debian-security ${dist}\/updates/debian-security ${dist}-security/g'" /etc/apt/sources.list

        # And run the updates/upgrades.
        _info "Starting repository update & upgrade"
        _run_qube_term "${vm}" sudo apt update
        _run_qube_term "${vm}" sudo apt upgrade
        _info "Starting dist upgrade"
        _run_qube_term "${vm}" sudo apt dist-upgrade
    fi
}

# ========================================================================================
#  VM control and settings management
# ========================================================================================
#

# qube.enable enables a VM to autostart
function qube.enable ()
{
    local name="$1"
    local enabled=( "$(identity.enabled_qubes)" )
    local already_enabled=false

    # Check if the VM is already marked autostart
    for vm in "${enabled[@]}" ; do
        if [[ $vm == "$name" ]]; then
            already_enabled=true
        fi
    done

    if [[ $already_enabled != true ]]; then
        _info "Enabling VM ${name} to autostart"
        identity.config_append AUTOSTART_QUBES "${name}"
    else
        _info "VM ${name} is already enabled"
    fi
}

# qube.disable disables a VM to autostart
function qube.disable ()
{
    local name="$1"
    _info "Disabling VM $name"

    identity.config_reduce AUTOSTART_QUBES "${name}"
}

# qube.start [vm 1] ... [vm n]
#Start the given VMs without executing any command.
function qube.start ()
{
    local ret=0

    local vm=
    declare -A pids=() #VM --> pid
    for vm in "$@" ; do
        [[ "$vm" == "dom0" ]] && continue
        _verbose "Starting: $vm"
        qube.assert_running "$vm" &
        pids["$vm"]=$!
    done

    local failed=""
    local ret=
    for vm in "${(@k)pids}" ; do
        wait "${pids["$vm"]}"
        ret=$?
        [ $ret -ne 0 ] && failed="$failed"$'\n'"$vm ($ret)"
    done

    [ -z "$failed" ] || _verbose "Starting the following VMs failed: $failed"

    #set exit code
    [ -z "$failed" ]
}

# qube.shutdown [vm 1] ... [vm n]
#Shut the given VMs down.
function qube.shutdown ()
{
    local ret=0

    if [ $# -gt 0 ] ; then
        #make sure the VMs are unpaused
        #cf. https://github.com/QubesOS/qubes-issues/issues/5967
        local vm=
        for vm in "$@" ; do
            qvm-unpause "$vm" &> /dev/null
        done

        _verbose "Shutting down: $*"
        qvm-shutdown --wait "$@"
        ret=$?
    fi

    return $ret
}

#qube.assert_running [vm] [start]
#Assert that the given VM is running. Will unpause paused VMs and may start shut down VMs.
#[vm]: VM for which to make sure it's running.
#[start]: If it's not running and not paused, start it (default: 0/true). If set to 1, this function will return a non-zero exit code.
#returns: A non-zero exit code, if it's not running and/or we failed to start the VM.
function qube.assert_running ()
{
    local vm="$1"
    local start="${2:-0}"

    #make sure the VM is unpaused
    if qvm-check --paused "$vm" &> /dev/null ; then
        qvm-unpause "$vm" &> /dev/null || return 1
    else
        if [ "$start" -eq 0 ] ; then
            qvm-start --skip-if-running "$vm" &> /dev/null || return 1
        else
            #we don't attempt to start
            return 2
            fi
        fi

        return 0
    }

# qube.is_running returns 0 if the target qube is running (or paused), or 1 if not.
# $1 - VM name.
function qube.is_running ()
{
    qvm-check --running "$1" &>/dev/null
}

# qube.delete deletes a VM belonging to the identity, and removes its from the
# specified file. If this file is empty after this, it is deleted here.
# $1 - VM name.
# $2 - The name of key to search in the vault key-value store for deletion.
function qube.delete ()
{
    local vm="${1}"
    local file="${2}"

    [[ -z "${vm}" ]] && return

    # Attempt to delete: if fails, return without touching the specified file.
    _info "Deleting VM ${vm}"
    _run qvm-remove --force --verbose "${vm}"
    if [[ $? -gt 0 ]]; then
        return
    fi

    if [[ -z "${file}" ]]; then
        return
    fi

    # Delete the VM from the corresponding key-value pair in vault.
    identity.config_reduce "${file}" "${vm}"
}

# ========================================================================================
#  Qubes dom0 general functions (not about a single qube)
# ========================================================================================
#

# qubes.updatevm_template returns the template of the updateVM.
function qubes.updatevm_template ()
{
    qvm-ls | grep "$(qubes-prefs updatevm)" | grep "TemplateVM" | awk '{print $1}'
}

# qubes.focused_qube returns the name of the VM owning the currently

# active window. Returns 'dom0' if the focused window is a dom0 one.
function qubes.focused_qube ()
{
    local window_class parts vm
    window_class="$(xdotool getwindowclassname "$(xdotool getactivewindow)")"

    # No colon means dom0
    if [[ ${window_class} == *:* ]]; then
        parts=( ${(s[:])window_class} )
        print "${parts[1]}"
    else
        print "dom0"
    fi
}

# qubes.list_all returns an array of all VMs
function qubes.list_all ()
{
    local -a vms

    while IFS= read -r VM_NAME ; do
        vms+=("${VM_NAME}")
    done < <(qvm-ls --raw-list | sort)

    echo "${vms[@]}"
}

# qubes.list_all_updateable returns all templates and standalone VMs
function qubes.list_all_updateable ()
{
    local templates=()
    while read -r line ; do
        IFS="|" read -r name class <<< "${line}"
        if [[ "$class" == "TemplateVM" ]]; then
            templates+=( "$name" )
        elif [[ "$class" == "StandaloneVM" ]]; then
            templates+=( "$name" )
        fi
    done < <(qvm-ls --raw-data --fields name,class | sort)

    echo "${templates[@]}"
}

COMMAND_STDOUT=''           # Stores a command's stdout output.
COMMAND_STDERR=''           # Stores a command's stderr output.

# do a command, splitting and storing stdout/stderr output and printing
# the former to screen only if the command is ran with verbose flag.
# Returns the command's exit code, so we can catch any errors and inform.
_run ()
{
    # The STDOUT/STDERR variables are populated, which
    # makes their content available to any subsequent call
    # to _failure, which needs STDERR output
    {
        IFS=$'\n' read -r -d '' COMMAND_STDERR;
        IFS=$'\n' read -r -d '' COMMAND_STDOUT;
        (IFS=$'\n' read -r -d '' _ERRNO_; exit "${_ERRNO_}");
    } < <((printf '\0%s\0%d\0' "$("$@")" "${?}" 1>&2) 2>&1)

    local ret="$?"

    # Output the command's result depending on the verbose mode
    # and if the command ran successfully. We check that either
    # stdout or stderr are non-empty: sometimes commands might
    # output to stderr, like wipe.
    if [[ $ret -eq 0 ]] && is_verbose_set ; then
        if [[ -n "$COMMAND_STDOUT" ]]; then
            _verbose "$COMMAND_STDOUT"
        fi
    fi

    # Return the command's exit code
    return $ret
}

# run a command in a qube
# $1 - Qube name
# $@ - Command string to run
_run_qube ()
{
    local vm="$1" ; shift
    local command="$*"
    local terminal shell shell_command full_command

    # Prepare the full command
    terminal="$(config_get VM_TERMINAL)"
    shell="$(config_get VM_SHELL)"
    shell_command="${shell} -c '$command'"
    full_command=(qvm-run --pass-io "$vm" "$shell_command")

    _verbose "Running command: ${full_command[*]}"

    # Split io like in _run, and store the return value
    # Note that we don't double quote the $full_command variable.
    {
        IFS=$'\n' read -r -d '' COMMAND_STDERR;
        IFS=$'\n' read -r -d '' COMMAND_STDOUT;
        (IFS=$'\n' read -r -d '' _ERRNO_; exit "${_ERRNO_}");
    } < <((printf '\0%s\0%d\0' "$( "${full_command[@]}" )" "${?}" 1>&2) 2>&1)

    local ret="$?"

    # Output the command's result depending on the verbose mode
    # and if the command ran successfully like in _run also.
    if [[ $ret -eq 0 ]] && is_verbose_set ; then
        if [[ -n "$COMMAND_STDOUT" ]]; then
            _verbose "$COMMAND_STDOUT"
        fi
    fi

    return $ret
}

# _run_exec is a simplified version of _run_qube, without stdout/err split & store.
_run_exec ()
{
    local vm="$1"
    shift
    local command="$*"

    # If we don't have any command arguments, we run the default terminal
    [[ -z "$command" ]] && command="$VM_TERMINAL"

    _verbose "Running command: ${command}"

    # Run the command raw, so that we get the output as it is.
    qvm-run --pass-io "$vm" "${command}"
}

# _run_qube_term spawns a terminal on a target qube, with an associated command to run.
_run_qube_term ()
{
    local vm="$1" ; shift
    local command="$*"
    local terminal shell shell_command

    # Prepare the full command
    terminal="$(config_get VM_TERMINAL)"
    shell="$(config_get VM_SHELL)"
    shell_command="${shell} -c '$command'"

    # Run the raw command, so that we get the output as it is.
    qvm-run --pass-io "$vm" "$terminal" -e "$shell_command"
}

# Checks the return code of a command, and if not successful,
# fails with the associated error message. Usage:
# catch $ret "hush" "Failed to execute this command"
function _catch ()
{
    local ret="$?"

    if [[ ! $ret -eq 0 ]]; then
        _failure "$@"
    fi
}

# proxy.tor_create creates a new TOR Whonix gateway AppVM.
# $1 - Name to use for new VM
# $2 - Netvm for this gateway
# $3 - Label
function proxy.tor_create ()
{
    local gw="${1}-tor"
    local netvm="${2-$(identity.config_get NETVM_QUBE)}"
    local gw_label="${3-yellow}"
    local gw_template="$(config_get WHONIX_GW_TEMPLATE)"

    _run qvm-create "${gw}" --property netvm="$netvm" --label "$gw_label" --template "$gw_template"
    _run qvm-prefs "$gw" provides_network true

    print_new_qube "${gw}" "New TOR gateway qube"

    # Tag the VM with its owner, and save as identity tor gateway
    _run qvm-tags "$gw" set "$IDENTITY"
    identity.config_set TOR_QUBE "${gw}"
    identity.config_set NETVM_QUBE "${gw}"
}

# proxy.tor_clone is similar to proxy.tor_create, except that we clone

# an existing gateway AppVM instead of creating a new one from a Template.
function proxy.tor_clone ()
{
    local gw="${1}-tor"
    local gw_clone="$2"
    local netvm="${3-$(identity.config_get NETVM_QUBE)}"
    local gw_label="${4-yellow}"

    _run qvm-clone "${gw_clone}" "${gw}"
    _catch "Failed to clone VM ${gw_clone}"

    print_cloned_qube "${gw}" "${gw_clone}" "New TOR gateway qube"

    # For now disposables are not allowed, since it would create too many VMs,
    # and complicate a bit the setup steps for VPNs. If the clone is a template
    # for disposables, unset it
    local disp_template
    disp_template=$(qvm-prefs "${gw}" template_for_dispvms)
    if [[ "$disp_template" = "True" ]]; then
        qvm-prefs "${gw}" template_for_dispvms False
    fi

    _info "Getting network from $netvm"
    _run qvm-prefs "$gw" netvm "$netvm"

    _verbose "Setting label to $gw_label"
    _run qvm-prefs "$gw" label "$gw_label"

    # Tag the VM with its owner, and save as identity tor gateway
    _run qvm-tags "$gw" set "$IDENTITY"
    identity.config_set TOR_QUBE "${gw}"
    identity.config_set NETVM_QUBE "${gw}"
}

# proxy.fail_config_tor exits the program if risk lacks some information
# (which templates/clones to use) when attempting to create a Tor qube.
function proxy.fail_config_tor ()
{
    [[ ${args['--no-tor']} -eq 1 ]] && return

    local template clone netvm

    # Check qubes specified in config or flags.
    template="$(config_get WHONIX_GW_TEMPLATE)"
    [[ -n "${args['--clone-tor-from']}" ]] && clone="${args['--clone-tor-from']}"

    # Check those qubes exist
    if [[ -n ${clone} ]]; then
        ! qube.exists "${clone}" && _failure "Qube to clone ${clone} does not exist"
    else
        ! qube.exists "${template}" && _failure "Qube template ${template} does not exist"
    fi
}

# proxy.skip_tor_create returns 0 when there not enough information in the configuration
# file or in command flags for creating a new TOR qube (no templates/clones indicated, etc).
# Needs access to command-line flags
function proxy.skip_tor_create ()
{
    [[ ${args['--no-tor']} -eq 1 ]] && return 0

    local template clone netvm

    template="$(config_get WHONIX_GW_TEMPLATE)"
    [[ -n "${args['--clone-tor-from']}" ]] && clone="${args['--clone-tor-from']}"

    [[ -z ${template} && -z ${clone} ]] && \
        _info "Skipping TOR gateway: no TemplateVM/AppVM specified in config or flags" && return 0

    return 1
}

# Return 0 if is set, 1 otherwise
option_is_set() {
	local -i r	 # the return code (0 = set, 1 = unset)

	[[ -n ${(k)OPTS[$1]} ]];
	r=$?

	[[ $2 == "out" ]] && {
		[[ $r == 0 ]] && { print 'set' } || { print 'unset' }
	}

	return $r;
}

# Retrieves the value of a variable first by looking in the risk
# config file, and optionally overrides it if the flag is set.
# $1 - Flag argument
# $2 - Key name in config
config_or_flag ()
{
    local value config_value

    config_value=$(config_get $2)   # From config
    value="${1:=$config_value}"      # overriden by flag if set

    print $value
}

# contains(string, substring)
#
# Returns 0 if the specified string contains the specified substring,
# otherwise returns 1.
contains() {
    string="$1"
    substring="$2"
    if test "${string#*$substring}" != "$string"
    then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

# prompt_question asks the user to answer a question prompt.
# $@ - A question string.
prompt_question ()
{
    printf >&2 '%s ' "$*"

    read -r ans
    echo "${ans}"
}

# print_new_qube is used to display the properties of a newly created qube.
# $1 - Name
# $2 - Message to display above properties
print_new_qube ()
{
    local name="$1"
    local template netvm

    qvm-ls "${name}" &>/dev/null || return

    template=$(qvm-prefs "${name}" template)
    netvm=$(qvm-prefs "${name}" netvm)

    [[ -n "${2}" ]] && _info "${2}"
    _info "Name:       ${fg_bold[white]} $name ${reset_color}"
    _info "Netvm:      ${fg_bold[white]} $netvm ${reset_color}"
    _info "Template:   ${fg_bold[white]} $template ${reset_color}"
}

# print_new_qube is used to display the properties of a newly cloned qube.
# $1 - Name
# $2 - Clone name
# $2 - Message to display above properties
print_cloned_qube ()
{
    local name="$1"
    local clone="$2"
    local netvm

    qvm-ls "${name}" &>/dev/null || return

    netvm=$(qvm-prefs "${name}" netvm)

    [[ -n "${3}" ]] && _info "${3}"
    _info "Name:          ${fg_bold[white]} $name ${reset_color}"
    _info "Netvm:         ${fg_bold[white]} $netvm ${reset_color}"
    _info "Cloned from:   ${fg_bold[white]} $clone ${reset_color}"
}

validate_device () {
    local block="$1"

    # And check not already attached to another qube
    ovm=$(qvm-block list | grep "${block}" | awk {'print $4'} | cut -d" " -f1)

    if [[ ${#ovm} -gt 0 ]]; then
        echo -e "Block ${block} is currently attached to ${ovm}."
        echo "Please umount it properly from there and rerun this program."
        return
    fi
}

validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# does the vm exist?
validate_vm_exists () {
    vm=""
    for item in $(qvm-ls | grep -v dom0 | awk '{print $1}' | grep "${1}")
    do
        if [ "${item}" == "${1}" ]; then
            vm=${1}
        fi
    done
    if [ ${#vm} -eq 0 ]; then
        echo "No vm with name ${1} exists or can not be used. Aborted."
        return
    fi
}

# Checks that the vault VM obeys a few requirements, like no network
validate_valid_vaultvm () {
    vm=""
    for item in $(qvm-ls | grep -v dom0 | awk '{print $1}' | grep "${1}")
    do
        if [ "${item}" == "${1}" ]; then
            vm=${1}
        fi
    done
    if [ ${#vm} -eq 0 ]; then
        echo "No vm with name ${1} exists or can not be used. Aborted."
        return
    fi

    netvm=$(qvm-prefs "${vm}" | grep "netvm" | awk '{print $3}')
    if [ "${netvm}" != "None" ]; then
        echo "${vm} might be connected to the internet. Aborted."
        echo "Check: qvm-prefs ${vm} | grep netvm"
    fi
}

# validate_netvm fails if the specified VM does not provide network.
validate_netvm ()
{
    local netvm="${1}"

    if [[ $(qvm-prefs "${netvm}" provides_network) == False ]]; then
        echo "Qube ${netvm} is specified as netvm, but does not provide network."
    fi
}

# proxy.vpn_create creates a new VPN gateway from a TemplateVM
function proxy.vpn_create ()
{
    local gw="${1}"
    local netvm="${2}"
    local gw_label="${3-blue}"
    local template="${4:=$(config_get VPN_TEMPLATE)}"

    _run qvm-create "${gw}" --property netvm="$netvm" --label "$gw_label" --template "$template"
    _catch "Failed to create VPN qube"

    _run qvm-prefs "${gw}" provides_network True
    print_new_qube "${gw}" "New VPN qube"

    # Tag the VM with its owner, and add the gateway to the list of proxies
    _run qvm-tags "$gw" set "$IDENTITY"
    identity.config_append PROXY_QUBES "${gw}"
}

# proxy.vpn_clone creates a new VPN gateway from an existing VPN AppVM
function proxy.vpn_clone ()
{
    local gw="${1}"
    local netvm="${2}"
    local gw_label="${3-blue}"
    local gw_clone="$4"

    _run qvm-clone "${gw_clone}" "${gw}"
    _catch "Failed to clone VM ${gw_clone}"

    # For now disposables are not allowed, since it would create too many VMs,
    # and complicate a bit the setup steps for VPNs. If the clone is a template
    # for disposables, unset it
    local disp_template
    disp_template=$(qvm-prefs "${gw}" template_for_dispvms)
    [[ "$disp_template" = "True" ]] && qvm-prefs "${gw}" template_for_dispvms False

    _run qvm-prefs "${gw}" provides_network True

    print_cloned_qube "${gw}" "${gw_clone}" "New VPN qube"

    # Tag the VM with its owner, and add the gateway to the list of proxies
    _run qvm-tags "$gw" set "$IDENTITY"
    identity.config_append PROXY_QUBES "${gw}"
}

# proxy.fail_config_vpn exits the program if risk lacks some information
# (which templates/clones to use) when attempting to create a VPN qube.
function proxy.fail_config_vpn ()
{
    local template clone netvm

    # Check qubes specified in config or flags.
    template="$(config_get VPN_TEMPLATE)"
    if [[ ${args['--clone']} -eq 1 ]]; then
        [[ -n ${args['--from']} ]] && clone=${args['--from']} || clone=$(config_get VPN_VM)
    fi

    # Check those qubes exist
    if [[ -n ${clone} ]]; then
        ! qube.exists "${clone}" && _failure "Qube to clone ${clone} does not exist"
    else
        ! qube.exists "${template}" && _failure "Qube template ${template} does not exist"
    fi
}

# proxy.skip_vpn_create returns 0 when there not enough information in the configuration
# file or in command flags for creating a new VPN qube (no templates/clones indicated, etc).
# Needs access to command-line flags
function proxy.skip_vpn_create ()
{
    local template clone netvm

    # Check qubes specified in config or flags.
    template="$(config_get VPN_TEMPLATE)"
    if [[ ${args['--clone']} -eq 1 ]]; then
        [[ -n ${args['--from']} ]] && clone=${args['--from']} || clone=$(config_get VPN_VM)
    fi

    [[ -z ${template} && -z ${clone} ]] && \
        _info "Skipping VPN qube: no TemplateVM/AppVM specified in config or flags" && return 0

    return 1
}

# proxy.vpn_import_configs browses for one or more (as zip) VPN client configurations
# in another VM, import them in our VPN VM, and run the setup wizard if there is more

# than one configuration to choose from.
# $1 - Name of VPN VM
# $2 - Name of VM in which to browse for configuration
# $3 - Path to the VPN client config to which one (only) should be copied, if not a zip file
function proxy.vpn_import_configs ()
{
    local name="$1"
    local config_vm="$2"
    local client_conf_path="$3"

    local config_path
    local new_path

    # Select the file, return if empty
    config_path=$(_run_exec "$config_vm" "zenity --file-selection --title='VPN configuration selection' 2>/dev/null")
    [[ -z "$config_path" ]] && _info "Canceling setup: no file selected in VM $config_vm" && return

    _verbose "Copying file $config_path to VPN VM"
    qvm-run "$config_vm" "qvm-copy-to-vm $name $config_path" &>/dev/null

    # Now our configuration is the QubesIncoming directory of our VPN,
    # so we move it where the VPN will look for when starting.
    new_path="/home/user/QubesIncoming/${config_vm}/$(basename "$config_path")"

    # If the file is a zip file, unzip it in the configs directory
    # and immediately run the setup prompt to choose one.
    if [[ ${new_path:e} == "zip" ]]; then
        local configs_dir="/rw/config/vpn/configs"
        _info "Unzipping VPN configuration files into $configs_dir"
        qvm-run "$name" "sudo mkdir -p $configs_dir" &>/dev/null
        qvm-run "$name" "sudo unzip -d $configs_dir ${new_path}" &>/dev/null
        _run_exec "$name" /usr/local/bin/setup_VPN
    else
        _info "Copying file directly to the VPN client config path"
        _run_exec "$name" sudo mv "$new_path" "$client_conf_path"
    fi

    _info "Done transfering VPN client configuration to VM"
}

# proxy.vpn_next_name returns a name for a new VPN VM, such as vpn-1, where

# the number is the next value after the ones found in existing VPN qubes.
function proxy.vpn_next_name ()
{
    local base_name="$1"

    # First get the array of ProxyVMs names
    read -rA proxies < <(identity.proxy_qubes)

    local next_number=1

    for proxy in "${proxies[@]}"; do
        if contains "$proxy" "vpn-"; then
            next_number=$((next_number + 1))
        fi
    done

    print "$base_name-vpn-$next_number"
}

# proxy.fail_not_identity_proxy exits the program

# if the VM is not listed as an identity proxy.
function proxy.fail_not_identity_proxy ()
{
    local name="$1"
    local found=false

    read -rA proxies < <(identity.proxy_qubes)
    for proxy in "${proxies[@]}" ; do
        if [[ $proxy == "$name" ]]; then
            found=true
        fi
    done

    if [[ $found != true ]]; then
        _info "VM $name is not listed as a VPN gateway. Aborting."
        exit 1
    fi
}

# ========================================================================================
# Client browser qubes

# ========================================================================================

# web.client.create creates a web browsing VM from a template.
function web.client.create ()
{
    local web="${1}-web"
    local netvm="${2-$(identity.config_get NETVM_QUBE)}"
    local label="${3-orange}"

    local template template_disp
    template="$(config_get WHONIX_WS_TEMPLATE)"
    template_disp="$(qvm-prefs "${template}" template_for_dispvms 2>/dev/null)"

    # If the template used is a disposable_template,
    # this means we must create a named disposable VM.
    if [[ "${template_disp}" == True ]]; then
        _verbose "VM template is a disposable template, cloning it instead"
        web.client.clone "${1}" "${template}" "${netvm}" "${label}"
        return
    fi

    # Generate the VM
    _run qvm-create "${web}" --property netvm="$netvm" --label="$label" --template="$template"
    print_new_qube "${web}" "New client browser VM"

    if [[ $? -gt 0 ]]; then
        _warning "Failed to create browser VM $web" && return
    fi

    # Mark this VM as a disposable template, and tag it with our identity
    if [[ "${template_disp}" != True ]]; then
        qvm-prefs "${web}" template_for_dispvms True
    fi

    _run qvm-tags "$web" set "$IDENTITY"
    identity.config_set BROWSER_QUBE "${web}"
}

# web.client.clone clones a web browsing VM from an existing AppVM one.
function web.client.clone ()
{
    local web="${1}-web"
    local web_clone="$2"
    local netvm="${3-$(identity.config_get NETVM_QUBE)}"
    local label="${4-orange}"

    _run qvm-clone "${web_clone}" "${web}"
    if [[ $? -gt 0 ]] ; then
        _warning "Failed to clone browser VM $web" && return
    fi
    print_cloned_qube "${web}" "${web_clone}" "New client browser VM"

    _run qvm-prefs "$web" label "$label"
    _run qvm-prefs "$web" netvm "$netvm"

    # Only mark this VM as disposable template when it's not one already.
    if [[ "$(qvm-prefs "${web}" template_for_dispvms 2>/dev/null)" == False ]]; then
        _run qvm-prefs "${web}" template_for_dispvms True
    fi

    _run qvm-tags "$web" set "$IDENTITY"
    identity.config_set BROWSER_QUBE "${web}"
}

# web.client.skip returns 0 when there not enough information in the configuration
# file or in command flags for creating a new browser qube (no templates/clones

# indicated, etc).
# Needs access to command-line flags
function web.client.skip ()
{
    local template clone netvm

    # Check qubes specified in config or flags.
    template="$(config_get WHONIX_WS_TEMPLATE)"
    [[ -n "${args['--clone-web-from']}" ]] && clone="${args['--clone-web-from']}"

    [[ -z ${template} && -z ${clone} ]] && \
        _info "Skipping browser qube: no TemplateVM/AppVM specified in config or flags" && return 0
}

# web.client.fail_invalid_config exits the program if risk lacks some information
# (which templates/clones to use) when attempting to create a browser qube.
function web.client.fail_invalid_config ()
{
    local template clone netvm

    # Check qubes specified in config or flags.
    template="$(config_get WHONIX_WS_TEMPLATE)"
    [[ -n "${args['--clone-web-from']}" ]] && clone="${args['--clone-web-from']}"

    # Check those qubes exist
    if [[ -n ${clone} ]]; then
        ! qube.exists "${clone}" && _failure "Qube to clone ${clone} does not exist"
    else
        ! qube.exists "${template}" && _failure "Qube template ${template} does not exist"
    fi
}

# web.client.update_tor_browser finds the active identity's browser qube template,
# or if not existing, the globally configured whonix workstation, and updates
# the Tor browser in it.
# Requires an identity to be active.
function web.client.update_tor_browser ()
{
    local browser_vm browser_template running

    # Either the identity browser, of the global config one, or return.
    browser_vm="$(identity.browser_qube)"
    [[ -z "${browser_vm}" ]] && browser_vm="$(config_get WHONIX_WS)"
    [[ -z "${browser_vm}" ]] && return

    # Get the template
    browser_template="$(qube.root_template "${browser_vm}")"

    _warning "Updating Tor browser in ${browser_template}"
    qube.is_running "${browser_template}"
    running=$?

    # Run the update and optionally shut it down if it was before.
    _run_qube_term "${browser_template}" sudo update-torbrowser
    [[ ${running} -eq 1 ]] && qube.shutdown "${browser_template}"
}

# web.client.open_url attempts to a URL with the system browser of a qube.
# $1 - URL to open.
# $2 - Target qube.
function web.client.open_url ()
{
    local url="$1"
    local qube="$2"

    _info "Opening ${url} in ${qube}"
    _run qvm-run "${qube}" "x-www-browser ${url}" &
}

# ========================================================================================
# Backend browser qubes (split-browser)

# ========================================================================================

# web.backend.create creates a split-browser backend qube from a template.
function web.backend.create ()
{
    local web web_label split_template

    web="${1}-split-web"
    web_label="${2-gray}"
    split_template="$(config_get SPLIT_BROWSER_TEMPLATE)"

    qvm-create --property netvm=None --label "$web_label" --template "$split_template"
    print_new_qube "${web}" "New split-browser backend"

    # Once created, set the configuration with this qube.
    config_set SPLIT_BROWSER "${web}"

    # And write the required qrexec services.
    echo && _info "Writing split-bookmark RPC services/policies"
    web.backend.setup_policy "${web}"
    web.backend.setup_policy_dom0 "${web}"
}

# web.backend.clone clones an existing split-browser backend qube.
function web.backend.clone ()
{
    local web="${1}-split-web"
    local web_clone="$2"
    local web_label="${3-gray}"

    qvm-clone "${web_clone}" "${web}"
    qvm-prefs "$web" label "$web_label"
    qvm-prefs "$web" netvm None

    print_cloned_qube "${web}" "${web_clone}" "New split-browser backend"

    # Once created, set the configuration with this qube.
    config_set SPLIT_BROWSER "${web}"

    # And write the required qrexec services.
    echo && _info "Writing split-bookmark RPC services/policies"
    web.backend.setup_policy "${web}"
    web.backend.setup_policy_dom0 "${web}"
}

# web.backend.skip returns 0 when there not enough information in the configuration
# file or in command flags for creating a new split-browser backend qube (no templates
# or clones indicated, etc).
# Needs access to command-line flags
function web.backend.skip ()
{
    [[ ${args['--no-split-browser']} -eq 1 ]] && return 0

    local template clone

    template="$(config_get SPLIT_BROWSER_TEMPLATE)"
    clone="$(config_get SPLIT_BROWSER)"

    [[ -z ${template} && -z ${clone} ]] && \
        _info "Skipping split-browser backend: no TemplateVM/AppVM specified in config" && return 0

    [[ -n ${clone} ]] && return 0

    return 1
}

# web.backend.fail_invalid_config exits the program if risk lacks some information
# (which templates/clones to use) when attempting to create a split-browser qube.
function web.backend.fail_invalid_config ()
{
    [[ ${args['--no-split-browser']} -eq 1 ]] && return

    local template clone

    # Check qubes specified in config or flags.
    template="$(config_get SPLIT_BROWSER_TEMPLATE)"
    [[ -n "${args['--clone-split-from']}" ]] && clone="${args['--clone-split-from']}"

    # Check those qubes exist
    if [[ -n ${clone} ]]; then
        ! qube.exists "${clone}" && _failure "Qube to clone ${clone} does not exist"
    else
        ! qube.exists "${template}" && _failure "Qube template ${template} does not exist"
    fi
}

# web.backend.setup_policy writes two RPC policy scripts to the split-browser backend, that

# are used either to read the bookmarks file from vault, or send it back and delete it.
# $1 - split-browser backend qube name.
function web.backend.setup_policy ()
{
    local vm="$1"

    # Prepare the script to write as the backend qrexec service.
    read -r -d '' QREXEC_SPLIT_BOOKMARK_BACKUP <<'EOF'
#!/bin/sh
bookmarks_split_file="/home/user/.local/share/split-browser/bookmarks.tsv"

# Print the bookmarks file or return
[[ -e "${bookmarks_split_file}" ]] || return
cat "${bookmarks_split_file}"

# And delete it
shred -uzf "${bookmarks_split_file}"
EOF

    # Write the script to the target path and make it executable.
    local qrexec_backup_path="/usr/local/etc/qubes-rpc/risk.SplitBookmarkBackup"
    qvm-run -q "${vm}" "echo '${QREXEC_SPLIT_BOOKMARK_BACKUP}' | sudo tee ${qrexec_backup_path}"
    [[ $? -ne 0 ]] && _warning "Failed to write risk.SplitBookmarkBackup policy to ${vm}"
    qvm-run -q "${vm}" "sudo chmod +x ${qrexec_backup_path}"

    # Prepare the second script, which will read that same file from the vault.
    read -r -d '' QREXEC_SPLIT_BOOKMARK <<'EOF'
#!/bin/sh
bookmarks_split_file="/home/user/.local/share/split-browser/bookmarks.tsv"
# Read the bookmarks file contents.
while IFS= read -r bookmark; do
    echo "${bookmark}" >> "${bookmarks_split_file}"
done
EOF

    # Write the script
    local qrexec_path="/usr/local/etc/qubes-rpc/risk.SplitBookmark"
    qvm-run -q "${vm}" "echo '${QREXEC_SPLIT_BOOKMARK}' | sudo tee ${qrexec_path}"
    [[ $? -ne 0 ]] && _warning "Failed to write risk.SplitBookmark policy to ${vm}"
    qvm-run -q "${vm}" "sudo chmod +x ${qrexec_path}"
}

# web.backend.setup_policy_dom0 creates two RPC policy files in Dom0, which are used to
# allow the vault qube to copy/read and delete the bookmarks file in the split-backend qube.
# $1 - split-browser backend qube name.
function web.backend.setup_policy_dom0 ()
{
    local split_backend="$1"

    # Echo both permission lines to their appropriate policy files.
    local bookmarks_policy="${VAULT_VM}    ${split_backend}    allow"

    _info "Writing split-bookmark policies to dom0"

    local split_bookmark_policy_path="/etc/qubes-rpc/policy/risk.SplitBookmark"
    local split_bookmark_backup_policy_path="/etc/qubes-rpc/policy/risk.SplitBookmarkBackup"

    if ! grep "${bookmarks_policy}" "${split_bookmark_policy_path}" &>/dev/null; then
        echo "${bookmarks_policy}" | sudo tee -a "${split_bookmark_policy_path}" &>/dev/null
    fi

    if ! grep "${bookmarks_policy}" "${split_bookmark_backup_policy_path}" &>/dev/null; then
        echo "${bookmarks_policy}" | sudo tee -a "${split_bookmark_backup_policy_path}" &>/dev/null
    fi
}

# web.backend.set_client updates the default disposable VM
# used by the split backend to use the active identity's one.
function web.backend.set_client ()
{
    local browser_vm split_backend filename copy_command

    # Set browser qubes
    split_backend="$(config_get SPLIT_BROWSER)"
    browser_vm=$(identity.config_get BROWSER_QUBE)

    [[ -z "${browser_vm}" ]] && return

    # Use this browser as the split dispVM
    _info "Setting split-browser: $browser_vm"
    qvm-prefs "${split_backend}" default_dispvm "${browser_vm}"

    # And copy identity bookmarks.

    web.backend.read_bookmarks "${split_backend}"
}

# web.backend.unset_client removes the dispvm setting of the
# tor split backend if it is set to the identity browser VM.
function web.backend.unset_client ()
{
    local browser_vm split_backend filename backup_command

    browser_vm=$(identity.config_get BROWSER_QUBE)
    split_backend="$(config_get SPLIT_BROWSER)"

    [[ -z "${browser_vm}" ]] && return

    # Unset the browser as the split-backend dispVM
    if [[ "$(qvm-prefs "${split_backend}" default_dispvm)" == "${browser_vm}" ]]; then
        qvm-prefs "${split_backend}" default_dispvm ''
    fi

    # And backup the bookmarks file.

    web.backend.save_bookmarks "${split_backend}"
}

# web.backend.open_url attempts to open a URL with the split-browser backend.
function web.backend.open_url ()
{
    local url="$1"
    local qube
    qube="$(config_get SPLIT_BROWSER)"

    _info "Opening ${url} in ${qube}"
    _run qvm-run "${qube}" "split-browser ${url}" &
}

# web.backend.save_bookmarks asks the vault qube to make use of an RPC

# call to read the bookmarks file from the split backend and save it.

# The split-browser backend then deletes the bookmark file.
function web.backend.save_bookmarks ()
{
    local split_backend="$1"
    local bookmarks_split_file

    # Test for the file, and if not empty, otherwise
    # we risk doing dangerous and unwanted things.
    bookmarks="$(qvm-run --pass-io "${split_backend}" "cat ${bookmarks_split_file}")"
    if [[ $? -ne 0 ]] || [[ -z "${bookmarks}" ]] ; then
         return
    fi

    _info "Backing up bookmarks"
    backup_command="qrexec-client-vm ${split_backend} risk.SplitBookmarkBackup > ${IDENTITY_BOOKMARKS_FILE}"
    qvm-run -q "${VAULT_VM}" "${backup_command}"
    [[ $? -ne 0 ]] && _warning "Failed to backup bookmarks"
}

# web.backend.read_bookmarks asks the vault to make use of an RPC call

# to send the identity's bookmarks file to the split-backend qube.
function web.backend.read_bookmarks ()
{
    local split_backend="$1"

    _info "Copying bookmarks"
    copy_command="cat ${IDENTITY_BOOKMARKS_FILE} | qrexec-client-vm ${split_backend} risk.SplitBookmark"
    qvm-run -q "${VAULT_VM}" "${copy_command}"
    [[ $? -ne 0 ]] && _warning "Failed to send bookmarks"

}

# ========================================================================================
# Bookmarks management

# ========================================================================================

# Command to spawn split-browser dmenu with bookmarks, and select one (written to file '~/bookmark').
# shellcheck disable=2016
SPLIT_BROWSER_QUERY_COMMAND='export SB_CMD_INPUT=bookmark; touch $SB_CMD_INPUT; split-browser-bookmark get'

# web.bookmark.create_user_file writes a file to store per-user

# bookmarks, and obfuscates its name. If the file already exists,

# nothing will happen (except modified touch timestamp).
function web.bookmark.create_user_file ()
{
    _run_exec "$VAULT_VM" "touch ${IDENTITY_BOOKMARKS_FILE}"
}

# web.bookmark.file_is_empty returns 0 if no bookmark
# file exists in split-browser or if it is empty.
function web.bookmark.file_is_empty ()
{
    local split_command contents
    split_command=( qvm-run --pass-io "$(config_get SPLIT_BROWSER)" "cat .local/share/split-browser/bookmarks.tsv" )
    if ! "${split_command[@]}" &>/dev/null; then
        return 0
    fi

    contents="$("${split_command[@]}")"
    if [[ -z "${contents}" ]]; then
        return 0
    fi

    return 1
}

# web.bookmark.prompt_command returns a command string
# to use as the dmenu displayer of a bookmarks file.
function web.bookmark.prompt_command ()
{
    # This command will not work if qubes-split-browser is not installed in the split-browser VM
    local window_focus_command='_NET_WM_NAME="Split Browser" x11-unoverride-redirect stdbuf -oL'

    if [[ -n "$(config_get BOOKMARKS_DMENU_COMMAND)" ]]; then
        echo "${window_focus_command} $(config_get BOOKMARKS_DMENU_COMMAND)"
    else
        echo "${window_focus_command} dmenu -i -l 20 -b -p 'RISKS Bookmark'"
    fi
}

# web.bookmark.prompt_select prompts the user with bookmarks,
# and returns the URL extracted from the selection.
function web.bookmark.prompt_select ()
{
    # bookmark_prompt=( $(web.bookmark.prompt_command) )
    qvm-run "${vm}" "${SPLIT_BROWSER_QUERY_COMMAND}"
    qvm-run --pass-io "${vm}" cat bookmark | awk '{print $2}'
}

# web.bookmark.prompt_pop prompts the user with bookmarks, returns the URL
# extracted from the selection and deletes the line in the file.
# Returns the complete bookmark entry.
function web.bookmark.prompt_pop ()
{
    local result bookmark_line vm
    bookmark_file=".local/share/split-browser/bookmarks.tsv"
    vm="$(config_get SPLIT_BROWSER)"

    # Get the URL
    qvm-run "${vm}" "${SPLIT_BROWSER_QUERY_COMMAND}"
    result=$( qvm-run --pass-io "${vm}" cat bookmark | awk '{print $2}')
    qvm-run "${vm}" "rm bookmark"

    # Get the entire line, with the title and timestamp.
    bookmark_line="$(qvm-run --pass-io "${vm}" "cat ${bookmark_file}")"
    line="$(echo "${bookmark_line}" | grep "${result}")"

    # Abort if the user did not select anything
    [[ -z "${result}" ]] && return

    # Remove the line from the file.
    remove_command="sed -i '\#${result}#d' .local/share/split-browser/bookmarks.tsv"
    qvm-run "${vm}" "${remove_command}"

    print "${line}"
}

# web.bookmark.prompt_create opens a zenity prompt in the focused

# qube for the user to enter a URL and an optional page title.
function web.bookmark.prompt_create ()
{
    local zenity_prompt result active_vm
    active_vm="$(qubes.focused_qube)"

    zenity_prompt=(zenity --text 'URL Bookmark' --forms --add-entry='URL' --add-entry='Page Title' --separator=$'\t')

    if [[ "${active_vm}" != "dom0" ]]; then
        qvm-run --pass-io "${active_vm}" "${zenity_prompt[@]}"
    else
        "${zenity_prompt[@]}"
    fi
}

# web.bookmark.url_bookmarked returns 0 if the bookmark

# is found in the user bookmarks file, or 1 if not.
# $1 - Bookmark URL path.
function web.bookmark.url_bookmarked ()
{
    local url="${1}"

    qvm-run --pass-io "${VAULT_VM}" "cat ${IDENTITY_BOOKMARKS_FILE} | grep ${url}" &>/dev/null
}

# web.bookmark.url_save writes a bookmark in split-browser

# format to the identity's bookmarks file.
# $1 - Bookmark entry
function web.bookmark.url_save ()
{
    local bookmark_entry="$1"
    qvm-run --pass-io "${VAULT_VM}" "echo '${bookmark_entry}' >> ${IDENTITY_BOOKMARKS_FILE}"
}

# ========================================================================================
# Other functions

# ========================================================================================

# web.bookmark_create_system writes and encrypts a file for blacklisted links.
function web.blacklist_create_file ()
{
    echo
}

# web.no_split_backend returns 0 if there is no split-browser backend

# qube specified in the configuration/flags, or 1 if one is found.
function web.no_split_backend ()
{
    echo -n
}

risk_hush_attach_command() {

  local block vm
  local error_invalid_vm error_device
  local must_mount

  block="${args['device']-$(config_get SDCARD_BLOCK)}"
  vm="${args['vault_vm']-$(config_get VAULT_VM)}"

  # If the validations were not performed because
  # we use a default environment variable for the
  # vault VM, perform them again here.
  error_invalid_vm=$(validate_valid_vaultvm "$vm")
  if [[ -n "$error_invalid_vm" ]]; then
      _failure "$error_invalid_vm"
  fi

  # Do the same for the hush device
  error_device=$(validate_device "$block")
  if [[ -n "$error_device" ]]; then
      _failure "$error_device"
  fi

  # is the vm running?
  qvm-ls | grep Running | awk {'print $1'} | grep '^'"${vm}"'$' &> /dev/null
  if [ "$?" != "0" ]; then
      _verbose "Starting VM $vm"
      qvm-start "${vm}"
  	sleep 5
  fi

  # finally attach the sdcard encrypted partition to the qube
  qvm-block attach "${vm}" "${block}"
  if [[ $? -eq 0 ]]; then
  	_success "Block ${block} has been attached to ${vm}"
  else
  	_failure "Block ${block} can not be attached to ${vm}"
  fi

  # If user wants to mount it now, do it
  if [[ ${args['--mount']} -eq 1 ]]; then
      must_mount=1
  elif [[ "$(config_get AUTO_MOUNT_HUSH)" == True ]]; then
      must_mount=1
  elif [[ "$(config_get AUTO_MOUNT_HUSH)" == true ]]; then
      must_mount=1
  elif [[ "$(config_get AUTO_MOUNT_HUSH)" == yes ]]; then
      must_mount=1
  elif [[ "$(config_get AUTO_MOUNT_HUSH)" == 1 ]]; then
      must_mount=1
  fi

  if [[ "${must_mount}" -eq 1 ]]; then
      _info "Mounting hush device"
      _run_qube_term "$vm" risks hush mount
  fi

}

risk_hush_detach_command() {

  local block vm

  block="${args['device']-$(config_get SDCARD_BLOCK)}"
  vm="${args['vault_vm']-$(config_get VAULT_VM)}"

  # First unmount the hush device in vault
  _info "Unmounting hush device before detaching"
  _run_qube "$vm" risks hush umount
  _catch "Failed to unmount hush device ($block)"

  # detach the sdcard encrypted partition to the qube
  if qvm-block detach "${vm}" "${block}" &>/dev/null ; then
  	_success "Block ${block} has been detached from ${vm}"
  else
  	_failure "Block ${block} can not be detached from ${vm}"
  fi

}

risk_backup_attach_command() {

  local block vm

  block="${args['device']-$(config_get BACKUP_BLOCK)}"
  vm="${args['vault_vm']-$(config_get VAULT_VM)}"

  local error_invalid_vm error_device

  # If the validations were not performed because
  # we use a default environment variable for the
  # vault VM, perform them again here.
  error_invalid_vm=$(validate_vm_exists "$vm")
  if [[ -n "$error_invalid_vm" ]]; then
      _failure "$error_invalid_vm"
  fi

  # Do the same for the hush device
  error_device=$(validate_device "$block")
  if [[ -n "$error_device" ]]; then
      _failure "$error_device"
  fi

  # is the vm running?
  qvm-ls | grep Running | awk {'print $1'} | grep '^'"${vm}"'$' &> /dev/null
  if [ "$?" != "0" ]; then
      _verbose "Starting VM $vm"
      qvm-start "${vm}"
  	sleep 15
  fi

  # finally attach the sdcard encrypted partition to the qube
  qvm-block attach "${vm}" "${block}"
  if [[ $? -eq 0 ]]; then
  	_success "Block ${block} has been attached to ${vm}"
  else
  	_success "Block ${block} can not be attached to ${vm}"
  fi

}

risk_backup_detach_command() {
  local block vm

  block="${args['device']:-$(config_get BACKUP_BLOCK)}"
  vm="${args['vault_vm']-$(config_get VAULT_VM)}"

  # Always umount first
  _info "Locking/unmounting backup device before detaching"
  _run_qube "$vm" risks backup umount
  _catch "Failed to unmount backup device ($block)"

  # detach the backup device
  if qvm-block detach "${vm}" "${block}" ; then
  	_success "Block ${block} has been detached from to ${vm}"
  else
  	_failure "Block ${block} can not be detached from ${vm}"
  fi

}

risk_identity_create_command() {

  name="${args['identity']}"
  name="$(identity.get_args_name "${name}")"
  identity="${name// /_}"
  email="$(identity.get_args_mail "${name}" "${args['email']}")"
  pendrive="${args['--backup']}"

  local other_args

  # 0 - Safety checks --------------------------------------------------------------

  # The identity should not exist, and none other should be active.
  identity.set "${identity}"
  identity.fail_other_active
  identity.fail_exists

  # 1 - Create identity in vault ---------------------------------------------------
  _in_section "identity" 8 && _info "Creating identity in vault"

  [[ -n "${args['expiry_date']}" ]] && other_args+=( "${args['expiry_date']}" )
  [[ -n "$pendrive" ]] && other_args=(--backup "$pendrive")
  [[ "${args['--burner']}" -eq 1 ]] && other_args+=( --burner )

  _run_qube_term "$VAULT_VM" risks identity create "'$name'" "$email" "${other_args[@]}"
  _catch "Failed to create identity in vault"

  _run_qube_term "$VAULT_VM" risks identity open "$identity"
  _catch "Failed to open identity in vault"

  # If the user only wanted to create the identity in the vault, exit.
  if [[ ${args['--vault-only']} -eq 1 ]] ; then
      _info "Skipping infrastructure setup"
      _success "Successfully created identity $identity"
      exit
  fi

  # 2 - Create all default qubes ---------------------------------------------------
  risk_identity_equip_command

}

risk_identity_equip_command() {

  local name="${args['identity']}"

  # Other variables
  local vm_name           # Default prefix to use for newly created vm (eg. 'joe' => joe-vpn, joe-web)
  local label             # Default label color to use for all VMs, varies if not specified
  local gw_netvm          # NetVM for the tor gateway
  local web_netvm         # NetVM for the Web browser VM
  local clone             # A variable that might be overritten several times, used to assign a VM to clone.

  # 1 - Identity basic setup.
  identity.set "${name}"
  identity.fail_unknown "$IDENTITY"
  identity.fail_none_active
  identity.fail_other_active

  _in_section "risk" 8 && _info "Creating qubes for identity $IDENTITY" && echo

  identity.set_global_props
  label=$(identity.config_get QUBE_LABEL)
  vm_name=$(identity.config_get QUBE_PREFIX)

  # 2 - Network VMs
  _in_section "network" && echo && _warning "Creating network VMs"
  gw_netvm="$(identity.config_get NETVM_QUBE)"

  if ! proxy.skip_tor_create; then
      if [[ -n ${args['--clone-tor-from']} ]]; then
          clone="${args['--clone-tor-from']}"
          proxy.tor_clone "$vm_name" "$clone" "$gw_netvm" "$label"
      else
          proxy.tor_create "$vm_name" "$gw_netvm" "$label"
      fi
  fi

  # 3 - Browser VMs
  _in_section "web" && echo && _warning "Creating browsing VMs"
  web_netvm="$(identity.config_get NETVM_QUBE)"

  # Browser client
  if ! web.client.skip; then
      if [[ -n ${args['--clone-web-from']} ]]; then
          clone="${args['--clone-web-from']}"
          web.client.clone "$vm_name" "$clone" "$web_netvm" "$label"
      else
          web.client.create "$vm_name" "$web_netvm" "$label"
      fi
  fi

  # Split-browser backend
  if ! web.backend.skip; then
      web.backend.create "${vm_name}" "${label}"
  else
      echo && _info "Writing split-bookmark RPC services/policies"
      web.backend.setup_policy "$(config_get SPLIT_BROWSER)"
      web.backend.setup_policy_dom0 "$(config_get SPLIT_BROWSER)"
  fi

  # Per-identity bookmarks file in vault management tomb.
  web.bookmark.create_user_file

  echo && _in_section 'risk' && _success "Successfully initialized qubes for identity $IDENTITY"

}

risk_identity_delete_command() {

  local delete_vault_cmd sdcard_block

  # First check the identity is valid
  identity.set "${args['identity']}"
  identity.fail_unknown

  # Check access to hush device in vault
  sdcard_block="$(config_get SDCARD_BLOCK)"
  device.fail_not_attached_to "${sdcard_block}" "${VAULT_VM}"

  # Close the identity and all its running VMs
  risk_identity_stop_command

  _info "Deleting identity VMs"
  identity.delete_qubes

  _info "Deleting identity in vault"
  delete_vault_cmd=( risks identity delete "${IDENTITY}" )

  # If a backup medium is mounted and backup
  # removal is asked, add the corresponding flags.
  if device.backup_mounted_on "${VAULT_VM}"; then
      if [[ "${args['--backup']}" -eq 1 ]]; then
          delete_vault_cmd+=( --backup )
      fi
  fi

  _run_qube_term "${VAULT_VM}" "${delete_vault_cmd[@]}"

  # Finally, delete its dom0 directory.
  identity.delete_home_directory

  _success "Successfully deleted identity $IDENTITY"

}

risk_identity_nake_command() {

  # First check the identity is valid
  identity.set "${args['identity']}"
  identity.fail_unknown
  identity.fail_none_active
  identity.fail_other_active

  # Close the identity and all its running VMs
  _warning "Stopping machines of identity $IDENTITY"
  identity.shutdown_qubes

  # If the identity browser VM is used with the split-browser backend.
  web.backend.unset_client

  echo && _warning "Deleting identity VMs"
  identity.delete_qubes

  echo && _warning "Deleting identity settings"
  identity.config_unset QUBE_LABEL
  identity.config_unset QUBE_PREFIX
  identity.config_unset NETVM_QUBE

  echo && _success "Successfully deleted qubes of identity $IDENTITY"

}

risk_identity_open_command() {

  device.fail_not_attached_to "$(config_get SDCARD_BLOCK)" "${VAULT_VM}"

  identity.set "${args['identity']}"
  identity.fail_other_active

  # Send commands to vault
  _info "Opening identity $IDENTITY"
  _run_qube_term "$VAULT_VM" risks identity open "$IDENTITY"
  identity.is_active || _failure "Failed to open identity $IDENTITY"

  # Set the identity browser VM, if any, as the disposable VM of split-browser backend.
  _in_section "web"
  web.backend.set_client

  _in_section "risk" && _info "Identity $IDENTITY is active"

}

risk_identity_close_command() {

  local active_identity

  identity.set

  # Check we have an active identity
  active_identity="$(identity.active)"
  if [[ -z $active_identity ]]; then
      _info "No active identity to close"
      return
  fi

  # If the identity browser VM is used with the split-browser backend.
  _in_section "web" 4
  web.backend.unset_client

  _in_section "risk" && _info "Closing identity $active_identity"

  _run_qube_term "${VAULT_VM}" risks identity close "$active_identity"
  _catch "Failed to close identity $active_identity"

  _info "Identity $active_identity is closed"

}

risk_identity_start_command() {

  local active_identity enabled_vms

  # Check the identity is valid, and open in vault if needed.
  identity.set "${args['identity']}"
  identity.fail_other_active
  risk_identity_open_command

  # Start all enabled identity machines
  read -rA enabled_vms < <(identity.enabled_qubes)
  for vm in "${enabled_vms[@]}"; do
      if [[ -z "${vm}" ]]; then
          continue
      fi
      _info "Starting VM ${vm}"
      _run qube.start "${vm}"
  done

  _in_section 'risk' && _success "Opened identity '$IDENTITY' and started enabled VMs"

}

risk_identity_stop_command() {

  identity.set

  # Else get the active identity
  local active_identity
  active_identity=$(identity.active_or_specified)

  _info "Stopping machines of identity $active_identity"
  identity.shutdown_qubes

  risk_identity_close_command

}

risk_identity_current_command() {
  # Simply print the active identity in the vault
  identity.active_or_specified

}

risk_slam_command() {

  # If no active identity to slam, nothing to do except umounting the hush device
  if ! _identity_active ; then
      _info "No active identity, only detaching hush and backup devices"
      risk_hush_detach_command
      risk_backup_detach_command
      exit 0
  fi

  # Else get the active identity, and propagate values to the script
  local active_identity
  active_identity=$(identity.active_or_specified)
  identity.set "$active_identity"

  _info "Slamming infrastructure, vault and devices: identity $active_identity"

  # First shut down all client VMs
  read -rA client_vms < <(identity.client_qubes)
  for vm in "${client_vms[@]}" ; do
      _info "Shutting down $vm"
      qube.shutdown "$vm"
  done

  # Do the same for proxyVMs
  read -rA proxy_vms < <(identity.proxy_qubes)
  for vm in "${proxy_vms[@]}" ; do
      _info "Shutting down $vm"
      qube.shutdown "$vm"
  done

  # Close the identity in the vault, unmount hush and backup
  risk_identity_close_command
  risk_hush_detach_command
  risk_backup_detach_command

  _success "Done"

}

risk_vpn_create_command() {

  identity.set

  # Prepare some settings for this new VM
  local name netvm clone template label

  # Identity specific values.
  name=$(identity.config_get QUBE_PREFIX)
  if [[ -n "${args['vm']}" ]]; then
      name="${name}-${args['vm']}-vpn"
  fi

  label="${args['--label']:=$(identity.vm_label)}"

  netvm="${args['--netvm']}"
  if [[ -z "${netvm}" ]]; then
      netvm="$(identity.config_get NETVM_QUBE)"
  fi
  if [[ -z "${netvm}" ]]; then
      netvm="$(config_get DEFAULT_NETVM)"
  fi

  # Global config
  clone="$(config_or_flag "${args['--from']}" VPN_VM)"
  template="$(config_or_flag "${args['--template']}" VPN_TEMPLATE)"

  _warning "Starting VPN qube creation"

  # Get the name to use for this qube, from flags/args or defaults.
  if [[ -z "${args['vm']}" ]]; then
      name="$(proxy.vpn_next_name "$name")"
  fi

  # Create or clone the qube.
  if [[ "${args['--clone']}" -eq 1 ]]; then
      proxy.vpn_clone "$name" "$netvm" "$label" "$clone"
  else
      proxy.vpn_create "$name" "$netvm" "$label" "$template"
  fi

  # Run the setup command, which will reuse all required flags.
  echo
  args['vm']="$name"
  risk_vpn_setup_command

  # If the VM is marked autostart
  if [[ ${args['--enable']} -eq 1 ]]; then
      _verbose "Enabling VM to autostart"
      risk_vpn_enable_command
  fi

  _info "Done creating VPN gateway $name"

}

risk_vpn_add_command() {

  # Prepare some settings for this new VM
  local vm netvm

  identity.set

  vm="${args['vm']}"

  # Check VM ownership
  owner=$(qube.owner "$vm")

  # If already belongs to an identity, ask for confirmation to update the settings.
  if [[ -n "$owner" ]] && [[ "$owner" != "$IDENTITY" ]]; then
      _warning "VM $vm already belongs to $owner"
      chown=$(prompt_question "Do you really want to assign a new identity ($IDENTITY) to this qube ? (YES/n)")
      if [[ "$chown" != 'YES' ]]; then
          _info "Aborting qube owner change. Exiting"
          exit 0
      fi
  fi

  # Network
  if [[ "$(qvm-prefs "$vm" netvm)" != 'None' ]]; then
      _info "Qube is networked, updating its network VM."
      netvm="$(identity.netvm)"

      # If the user overrode the default netVM, check that
      # it belongs to the identity, or ask confirmation.
      if [[ -n "${args['--netvm']}" ]]; then
          netvm="${args['--netvm']}"
          netvm_owner=$(qube.owner "${netvm}")

          if [[ -n "${netvm_owner}" ]] && [[ "$netvm_owner" != "$IDENTITY" ]]; then
              _warning "Network VM $netvm already belongs to $netvm_owner"
              chnet=$(prompt_question "Do you really want to use this qube as network VM for $vm? (YES/n)")
              if [[ "$chnet" != 'YES' ]]; then
                  netvm="$(identity.netvm)"
              fi
          fi
      fi

      _info "Setting network VM to $netvm"
      _run qvm-prefs "$vm" netvm "$netvm"
      _catch "Failed to set netvm"
  fi

  _run qvm-prefs "$vm" provides_network True

  if [[ ${args['--set-default']} -eq 1 ]]; then
      identity.config_set NETVM_QUBE "${vm}"
      _info "Setting '$vm' as default NetVM for all future client qubes"
  fi

  # Tag the VM with its owner, and mark as providing network.
  _run qvm-tags "$vm" set "$IDENTITY"
  _catch "Failed to tag qube with identity"
  identity.config_append PROXY_QUBES "${vm}"

  # Enable autostart if asked to
  if [[ ${args['--enable']} -eq 1 ]]; then
      _verbose "Enabling VM to autostart"
      risk_vpn_enable_command
  fi

  # Client VPN Configurations
  config_vm="${args['--config-in']}"
  client_conf_path="$(config_or_flag "" DEFAULT_VPN_CLIENT_CONF)"

  if [[ "${args['--choose']}" -eq 1 ]]; then
      # If we are asked to choose an existing configuration in the VM
      _run_exec "$vm" /usr/local/bin/setup_VPN
  elif [[ -n "${args['--config-in']}" ]]; then
      # Or if we are asked to browse one or more configuration files in another VM.
      proxy.vpn_import_configs "$vm" "$config_vm" "$client_conf_path"
  fi

  _success "Successfully added $vm as identity gateway"

}

risk_vpn_setup_command() {

  identity.set

  local name config_vm client_conf_path netvm

  name="${args['vm']}"
  config_vm="${args['--config-in']}"
  client_conf_path="$(config_or_flag "" DEFAULT_VPN_CLIENT_CONF)"

  netvm="${args['--netvm']}"

  # Set the netVM of this VPN if required.
  if [[ -n  "${netvm}" ]] && [[ "$(qvm-prefs "${name}" netvm)" != "${netvm}" ]]; then
      _info "Setting the VPN network VM to $netvm"
      qvm-prefs "$name" netvm "$netvm"
  fi

  # Possibly set VPN to be the default NetVM for all client qubes (browsers, etc).
  if [[ ${args['--set-default']} -eq 1 ]]; then
      _info "Setting '$name' as default NetVM for all client machines"
      identity.config_set NETVM_QUBE "${name}"

      # Find all existing client VMs (not gateways) and change their netVMs.
      read -rA clients < <(identity.client_qubes)
      for client in "${clients[@]}"; do
          if [[ -n "$client" ]]; then
              _verbose "Changing $client netVM"
              qvm-prefs "$client" netvm "$name"
          fi
      done
  fi

  # Client VPN Configurations
  if [[ "${args['--choose']}" -eq 1 ]]; then
      # If we are asked to choose an existing configuration in the VM
      _run_exec "$name" /usr/local/bin/setup_VPN
  elif [[ -n "${args['--config-in']}" ]]; then
      # Or if we are asked to browse one or more configuration files in another VM.
      proxy.vpn_import_configs "$name" "$config_vm" "$client_conf_path"
  fi

}

risk_vpn_start_command() {

  local name="${args['vm']}"

  _info "Starting gateway $name in the background"

  # First check all the network VMs that will be started
  # actually belong to the identity, otherwise we fail.
  network.fail_invalid_chain "$name"

  # Then start the VM, which will start all dependent ones.
  qube.start "$name"
  _catch "Failed to start $name"

  _info "Started VM $name"

}

risk_vpn_stop_command() {

  local name="${args['vm']}"

  _info "Shutting down gateway $name"
  qube.shutdown "$name"
  _catch "Failed to shutdown $name"
  _info "Shut down $name"

}

risk_vpn_enable_command() {

  # Same parameters for this command, just use it and its checks.
  risk_qube_enable_command

}

risk_vpn_disable_command() {

  # Same parameters for this command, just use it and its checks.
  risk_qube_disable_command

}

risk_vpn_delete_command() {

  local vm
  local tor_gw

  vm="${args['vm']}"

  identity.set

  # Fail if either the VM does not belong to the identity,
  # or if it provides network to some of the identity qubes.
  proxy.fail_not_identity_proxy "$vm"
  network.fail_networked_qube "$vm"

  _info "Deleting gateway VM $vm"

  # If the VPN was the default NetVM for the identity,
  # update the NetVM to Whonix.
  netvm="$(identity.netvm)"
  if [[ $netvm == "$vm" ]]; then
      _warning "Gateway $vm is the default NetVM for identity clients !"

      # Check if we have a TOR gateway
      tor_gw=$(identity.tor_gateway)
      if [[ -n $tor_gw ]]; then
          _info "Updating the default identity NetVM to $tor_gw"
          identity.config_set TOR_QUBE "${tor_gw}"
      else
          _info "The identity has no default NetVM anymore, please set it."
      fi
  fi

  # Delete without asking to confirm
  echo "y" | _run qvm-remove "$vm"
  _catch "Failed to delete (fully or partially) VM $vm"

  # Remove this VM name from the relevant files.
  identity.config_reduce AUTOSTART_QUBES "${vm}"
  identity.config_reduce PROXY_QUBES "${vm}"

  _info "Deleted $vm"

}

risk_qube_add_command() {

  local vm owner               # Variables for the target VM
  local netvm netvm_owner      # Variables for any netvm found/used.
  local chown chnet            # Questions variable (ex. do you want to blablabla)

  vm="${args['vm']}"

  identity.set
  identity.fail_unknown "$IDENTITY"

  # Check VM ownership
  owner=$(qube.owner "$vm")

  # Check if the VM provides network. If yes we naturally consider
  # it to be a gateway, and we add it to the list of proxy_vms.
  if [[ "$(qvm-prefs "$vm" provides_network)" == 'True' ]]; then
      _info "VM '${vm}' provides network: treating it as a gateway qube."
      args['--set-default']=${args['--default-netvm']}
      risk_vpn_add_command
      return $?
  fi

  # If already belongs to an identity, ask for confirmation to update the settings.
  if [[ -n "$owner" ]] && [[ "$owner" != "$IDENTITY" ]]; then
      _warning "VM $vm already belongs to $owner"
      chown=$(prompt_question "Do you really want to assign a new identity ($IDENTITY) to this qube ? (YES/n)")
      if [[ "$chown" != 'YES' ]]; then
          _info "Aborting qube owner change. Exiting"
          exit 0
      fi
  fi

  # Tag the VM with its owner
  _run qvm-tags "$vm" set "$IDENTITY"
  _catch "Failed to tag qube with identity"

  # If the target qube is networked, change its network VM, either with
  # the default for the identity, or with the netvm flag, which has precedence.
  if [[ "$(qvm-prefs "$vm" netvm)" != 'None' ]]; then
      _info "Qube is networked. Updating its network VM"
      netvm="$(identity.netvm)"

      # If the user overrode the default netVM, check that
      # it belongs to the identity, or ask confirmation.
      if [[ -n "${args['--netvm']}" ]]; then
          netvm="${args['--netvm']}"
          netvm_owner=$(qube.owner "${netvm}")

          if [[ -n "${netvm_owner}" ]] && [[ "$netvm_owner" != "$IDENTITY" ]]; then
              _warning "Network VM $netvm already belongs to $netvm_owner"
              chnet=$(prompt_question "Do you really want to use this qube as network VM for $vm? (YES/n)")
              if [[ "$chnet" != 'YES' ]]; then
                  netvm="$(identity.netvm)"
              fi
          fi
      fi

      _info "Setting network VM to $netvm"
      _run qvm-prefs "$vm" netvm "$netvm"
      _catch "Failed to set netvm"
  fi

  identity.config_append CLIENT_QUBES "${vm}"

  # Enable autostart if asked to
  [[ "${args['--enable']}" -eq 1 ]] && qube.enable "$vm"

  _success "Successfully set qube $vm as belonging to identity $IDENTITY"

}

risk_qube_delete_command() {
  local vm

  vm="${args['vm']}"

  identity.set
  identity.fail_unknown "$IDENTITY"

  # Check VM ownership
  if [[ "$(qube.owner "$vm")" != "$IDENTITY" ]]; then
      _info "VM $vm does not belong to $IDENTITY"
      return
  fi

  # Do not even attempt to delete if the VM provides network to another VM.
  network.fail_networked_qube "$vm"

  # If the VM is a gateway, just call the VPN command to do the work.
  if qube.is_identity_proxy "$vm" ; then
      risk_vpn_delete_command
      return
  fi

  # Remove from autostart enabled commands
  _info "Deleting qube ${vm}"
  identity.config_reduce AUTOSTART_QUBES "${vm}"
  identity.config_reduce PROXY_QUBES "${vm}"
  identity.config_reduce CLIENT_QUBES "${vm}"

  # Finally, delete the VM,
  qvm-remove "$vm"
  _catch "Failed to delete VM $vm:"

  _info "Deleted qube ${vm}"

}

risk_qube_enable_command() {
  local vm

  vm="${args['vm']}"

  identity.set

  # Check VM ownership
  [[ "$(qube.owner "$vm")" != "$IDENTITY\n" ]] || _failure "VM $vm does not belong to $IDENTITY"

  # If already enabled, skip
  if grep "^${vm}\$" < <(identity.config_get AUTOSTART_QUBES) &>/dev/null; then
      _info "Qube ${vm} is already enabled for autostart"
      return
  fi

  qube.enable "$vm"

}

risk_qube_disable_command() {
  local vm

  vm="${args['vm']}"

  identity.set

  # Check VM ownership
  [[ "$(qube.owner "$vm")" != "$IDENTITY\n" ]] || _failure "VM $vm does not belong to $IDENTITY"

  qube.disable "$vm"

}

risk_qube_list_command() {

  local clients proxies

  identity.set

  # Defaults
  _warning "Global values and defaults:"
  [[ -n "$(identity.netvm)" ]] && _info "${fg[blue]}Default netVM${fg[white]}: $(identity.netvm)"
  [[ -n "$(identity.tor_gateway)" ]] && _info "${fg[blue]}Tor gateway${fg[white]}: \t$(identity.tor_gateway)"
  [[ -n "$(identity.browser_qube)" ]] && _info "${fg[blue]}Browser qube${fg[white]}: \t$(identity.browser_qube)"

  # Network VMs
  read -rA proxies < <(identity.proxy_qubes)
  if [[ -n "${proxies[*]}" ]]; then
      echo && _warning "Proxy qubes:"
      for proxy in "${proxies[@]}"; do
          printf "\t\t%s" "${proxy}"
      done
  fi

  # Client VMs
  read -rA clients < <(identity.client_qubes)
  if [[ -n "${clients[*]}" ]]; then
      echo && _warning "Client qubes:"
      for client in "${clients[@]}"; do
          printf "\t\t%s" "${client}"
      done
  fi

}

risk_qube_update_command() {
  # Analyze the arguments and extract all VMs
  # corresponding to those names/groups.
  read -rA vms < <(qube.command_args "${args['vms']}" "${other_args[@]}")

  # Update matching VMs.
  if [[ -n "${vms[*]}" ]]; then
      _info "Updating following VMs:"
      for template in "${vms[@]}"; do
          _info "$template"
      done

      printf -v targets '%s,' "${vms[@]}"
      _run sudo qubesctl --skip-dom0 --targets "${targets%,}" state.apply update.qubes-vm
  fi

  # Update dom0 if required
  if [[ ${args['vms']} == dom0 ]] || [[ ${other_args[(r)dom0]} == dom0 ]]; then
      _info "Updating dom0"
      sudo qubes-dom0-update
  fi

  # If torbrowser update is required, get identity browsing VM template and update
  # We need to know for which identity to update, so we need one active.
  if [[ ${args['vms']} == torbrowser ]] || [[ ${other_args[(r)torbrowser]} == torbrowser ]]; then
      identity.set
      web.client.update_tor_browser
  fi

  _success "Done updating"

}

risk_qube_dist_upgrade_command() {

  local vm version
  local template dist running

  vm="${args['vm']}"
  version="${args['version']}"

  # Determine if the VM is a Fedora or Debian,
  # and fail if the distribution fits with the provided argument.
  template="$(qube.root_template "${vm}")"
  running="$(qube.assert_running "${template}")"
  dist="$(qube.distribution "${template}")"

  if [[ "${dist}" != "fedora" ]] && [[ "${dist}" != "debian" ]]; then
      _failure "Distribution upgrade currently not supported for ${dist} qubes."
  elif [[ ! "${version}" =~ ^[0-9]+$ ]] && [[ ${dist} == "fedora" ]] ; then
      _failure "Template is Fedora linux, but got non-number version ${version}."
  elif [[ "${version}" =~ ^[0-9]+$ ]] && [[ ${dist} != "fedora" ]] ; then
      _failure "Template is ${dist} linux, but got number version ${version}."
  fi

  # Start updating
  if [[ "${template}" == "${vm}" ]]; then
      _info "Trying to upgrade ${vm}"
  else
      _info "Trying to upgrade ${template} (template for ${vm})"
  fi

  _warning "You might be prompted for confirmations to import repo keys:"
  _warning "Please attend the upgrade process."

  qube.dist_upgrade "${template}" "${dist}" "${version}"

  _info "Done upgrading."

  if ! ${running}; then
      _info "Shutting down qube"
      qube.shutdown "${template}"
  fi

}

risk_use_command() {

  local vm arguments

  # Note that we concatenate all command arguments in a string (with *), to be passed to qvm-run
  vm="${args['vm']}"
  arguments="${other_args[@]}"

  local owner active_identity
  owner=$(qube.owner "$vm")
  active_identity="$(identity.active_or_specified)"

  # If the VM does not belong to any identity, then we don't have
  # to interact with any of them, and this branch is skipped.
  #
  # However if the VM does not belong the active identity, we must:
  if [[ -n "$owner" ]] && [[ $owner != "$active_identity" ]]; then
      # Close the active identity
      _info "Closing identity $active_identity"
      risk_identity_close_command

      # Open the new one
      args['identity']="$owner"
      risk_identity_open_command
  fi

  # At this point everything identity-related should be cleared and done.
  [[ -z "${arguments[*]}" ]] && command="$VM_TERMINAL"

  _verbose "Running command: ${command}"
  qvm-run "$vm" "${command}"
  _catch "Failed to execute command in $vm:"

}

risk_url_open_command() {

  local url               # URL link to open
  local split_vm          # The split-browser backend qube.
  local active_vm         # Qube of the focused window.

  identity.set

  url="${args['url']}"
  split_vm="$(config_get SPLIT_BROWSER)"
  active_vm="$(qubes.focused_qube)"

  # Get the bookmark entry from either split-browser file, args, or user-input in prompt.
  if [[ -z "${url}" ]]; then
      if ! web.bookmark.file_is_empty; then
          _info "No URL argument, starting dmenu with bookmarks list in ${split_vm}"
          url="$( web.bookmark_select | awk '{print $2}' )"
      else
          _info "Bookmark file is empty, and no URL argument was given." && return
      fi
  fi

  # We either have an entry, or some information to build one, otherwise abort.
  if [[ -z "${url}" ]]; then
      _info "No bookmark entry or URL selected or entered, aborting." && return
  fi

  # And open the link in the appropriate qube.
  # If the focused VM is a disposable browser, do not go through split-browser to open it.
  # Else, pass the URL as a split-browser command argument.
  if qube.is_browser_instance "${active_vm}"; then
      web.client.open_url "${url}" "${active_vm}"
  else
      web.backend.open_url "${url}"
  fi

}

risk_url_bookmark_command() {

  local bookmark_entry    # Complete entry (date/url/title)
  local url               # The URL to bookmark
  local title             # The URL page title to use if/when prompting the user for input.
  local split_vm          # The split-browser backend qube.

  identity.set

  url="${args['url']}"
  title="${args['title']}"
  split_vm="$(config_get SPLIT_BROWSER)"

  # Get the bookmark entry from either split-browser file, args, or user-input in prompt.
  if [[ -z "${url}" ]]; then
      if web.bookmark.file_is_empty; then
          _info "No bookmarks file in ${split_vm}, prompting user to enter it."
          result="$(web.bookmark.prompt_create)"
          url="$( echo "${result}" | cut -f 1 -d $'\t')"
          title="$( echo "${result}" | cut -f 2- -d $'\t')"
      else
          _info "No URL argument, starting dmenu with bookmarks list in ${split_vm}"
          bookmark_entry="$(web.bookmark.prompt_pop)"
          url="$( echo "${bookmark_entry}" | awk '{print $2}' )"
          title="$( echo "${bookmark_entry}" | awk '{print $3}' )"
      fi
  fi

  # We either have an entry, or some information to build one, otherwise abort.
  if [[ -z "${bookmark_entry}" ]] ; then
      if [[ -z "${url}" ]]; then
          _info "No bookmark entry or URL selected or entered, aborting." && return
      fi
      bookmark_entry="$(date --rfc-3339=seconds)"$'\t'"$url"$'\t'"$title"
  fi

  # Transfer the results to the vault's user bookmarks file.
  _info "Transfering entry to vault bookmarks file."
  if ! web.bookmark.url_bookmarked "${url}" ; then
      web.bookmark.url_save "${bookmark_entry}"
  fi

}

risk_config_set_command() {

  local key value

  key="${args['key']}"
  value="${args['value']}"

  config_set "$key" "$value"

}

risk_config_get_command() {

  local key

  key="${args['key']}"

  config_get "$key"

}

risk_config_unset_command() {

  local key

  key="${args['key']}"

  config_set "$key" ""

}

risk_config_list_command() {
  config_show

}

risk_config_keys_command() {
  config_keys

}

risk_help_command() {
  command="${args[command]}"
  long_usage=yes

  if [[ -z "$command" ]]; then
    # No command argument, show the global help
    help_function=risk_usage
  else
    # Show the help for the requested command
    help_function="risk_${command}_usage"
  fi

  # Call the help function if it exists
  if [[ $(type "$help_function") ]]; then
    "$help_function"
  else
    echo "No help available for this command"
    exit 1
  fi

}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        risk_usage
        exit
        ;;

      --verbose | -v)

        args['--verbose']=1
        shift
        ;;

      --log-file | -l)

        if [[ -n ${2+x} ]]; then

          args['--log-file']="$2"
          shift
          shift
        else
          printf "%s\n" "--log-file requires an argument: --log-file, -l LOGFILE" >&2
          exit 1
        fi
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    hush)
      action="hush"
      shift
      risk_hush_parse_requirements "$@"
      shift $#
      ;;

    backup)
      action="backup"
      shift
      risk_backup_parse_requirements "$@"
      shift $#
      ;;

    identity)
      action="identity"
      shift
      risk_identity_parse_requirements "$@"
      shift $#
      ;;

    slam)
      action="slam"
      shift
      risk_slam_parse_requirements "$@"
      shift $#
      ;;

    vpn)
      action="vpn"
      shift
      risk_vpn_parse_requirements "$@"
      shift $#
      ;;

    qube)
      action="qube"
      shift
      risk_qube_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      risk_use_parse_requirements "$@"
      shift $#
      ;;

    url)
      action="url"
      shift
      risk_url_parse_requirements "$@"
      shift $#
      ;;

    config)
      action="config"
      shift
      risk_config_parse_requirements "$@"
      shift $#
      ;;

    help)
      action="help"
      shift
      risk_help_parse_requirements "$@"
      shift $#
      ;;

    "")
      risk_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_hush_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_hush_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    attach)
      action="attach"
      shift
      risk_hush_attach_parse_requirements "$@"
      shift $#
      ;;

    detach)
      action="detach"
      shift
      risk_hush_detach_parse_requirements "$@"
      shift $#
      ;;

    "")
      risk_hush_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_hush_attach_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_hush_attach_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="hush attach"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --mount | -m)

        args['--mount']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['device']+x} ]]; then

          if [[ -n $(validate_device "$1") ]]; then
            printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_device "$1")" >&2
            exit 1
          fi

          args['device']=$1
          shift
        elif [[ -z ${args['vault_vm']+x} ]]; then

          if [[ -n $(validate_valid_vaultvm "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")" >&2
            exit 1
          fi

          args['vault_vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

risk_hush_detach_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_hush_detach_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="hush detach"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['device']+x} ]]; then

          args['device']=$1
          shift
        elif [[ -z ${args['vault_vm']+x} ]]; then

          if [[ -n $(validate_valid_vaultvm "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")" >&2
            exit 1
          fi

          args['vault_vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

risk_backup_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_backup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    attach)
      action="attach"
      shift
      risk_backup_attach_parse_requirements "$@"
      shift $#
      ;;

    detach)
      action="detach"
      shift
      risk_backup_detach_parse_requirements "$@"
      shift $#
      ;;

    "")
      risk_backup_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_backup_attach_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_backup_attach_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="backup attach"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['device']+x} ]]; then

          if [[ -n $(validate_device "$1") ]]; then
            printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_device "$1")" >&2
            exit 1
          fi

          args['device']=$1
          shift
        elif [[ -z ${args['vault_vm']+x} ]]; then

          if [[ -n $(validate_valid_vaultvm "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")" >&2
            exit 1
          fi

          args['vault_vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

risk_backup_detach_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_backup_detach_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="backup detach"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['device']+x} ]]; then

          args['device']=$1
          shift
        elif [[ -z ${args['vault_vm']+x} ]]; then

          if [[ -n $(validate_valid_vaultvm "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")" >&2
            exit 1
          fi

          args['vault_vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

risk_identity_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    create)
      action="create"
      shift
      risk_identity_create_parse_requirements "$@"
      shift $#
      ;;

    equip)
      action="equip"
      shift
      risk_identity_equip_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      risk_identity_delete_parse_requirements "$@"
      shift $#
      ;;

    nake)
      action="nake"
      shift
      risk_identity_nake_parse_requirements "$@"
      shift $#
      ;;

    open)
      action="open"
      shift
      risk_identity_open_parse_requirements "$@"
      shift $#
      ;;

    close)
      action="close"
      shift
      risk_identity_close_parse_requirements "$@"
      shift $#
      ;;

    start)
      action="start"
      shift
      risk_identity_start_parse_requirements "$@"
      shift $#
      ;;

    stop)
      action="stop"
      shift
      risk_identity_stop_parse_requirements "$@"
      shift $#
      ;;

    current)
      action="current"
      shift
      risk_identity_current_parse_requirements "$@"
      shift $#
      ;;

    "")
      risk_identity_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_identity_create_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="identity create"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --backup | -b)

        args['--backup']=1
        shift
        ;;

      --burner | -B)

        args['--burner']=1
        shift
        ;;

      --vault-only)

        args['--vault-only']=1
        shift
        ;;

      --mail | -m)

        args['--mail']=1
        shift
        ;;

      --prefix | -P)

        if [[ -n ${2+x} ]]; then

          args['--prefix']="$2"
          shift
          shift
        else
          printf "%s\n" "--prefix requires an argument: --prefix, -P NAME" >&2
          exit 1
        fi
        ;;

      --label | -L)

        if [[ -n ${2+x} ]]; then

          args['--label']="$2"
          shift
          shift
        else
          printf "%s\n" "--label requires an argument: --label, -L COLOR" >&2
          exit 1
        fi
        ;;

      --no-tor | -T)

        if [[ -n "${args['--clone-tor-from']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--clone-tor-from" >&2
          exit 1
        fi

        args['--no-tor']=1
        shift
        ;;

      --clone-tor-from)

        if [[ -n "${args['--no-gw']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-gw" >&2
          exit 1
        fi

        if [[ -n ${2+x} ]]; then

          args['--clone-tor-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-tor-from requires an argument: --clone-tor-from TOR_GW" >&2
          exit 1
        fi
        ;;

      --clone-web-from)

        if [[ -n ${2+x} ]]; then

          args['--clone-web-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-web-from requires an argument: --clone-web-from WEB_VM" >&2
          exit 1
        fi
        ;;

      --clone-split-from)

        if [[ -n ${2+x} ]]; then

          args['--clone-split-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-split-from requires an argument: --clone-split-from SPLIT_BROWSER_VM" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        elif [[ -z ${args['email']+x} ]]; then

          args['email']=$1
          shift
        elif [[ -z ${args['expiry_date']+x} ]]; then

          args['expiry_date']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

risk_identity_equip_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_equip_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="identity equip"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --prefix | -P)

        if [[ -n ${2+x} ]]; then

          args['--prefix']="$2"
          shift
          shift
        else
          printf "%s\n" "--prefix requires an argument: --prefix, -P NAME" >&2
          exit 1
        fi
        ;;

      --label | -L)

        if [[ -n ${2+x} ]]; then

          args['--label']="$2"
          shift
          shift
        else
          printf "%s\n" "--label requires an argument: --label, -L COLOR" >&2
          exit 1
        fi
        ;;

      --no-tor | -T)

        if [[ -n "${args['--clone-tor-from']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--clone-tor-from" >&2
          exit 1
        fi

        args['--no-tor']=1
        shift
        ;;

      --clone-tor-from)

        if [[ -n "${args['--no-gw']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-gw" >&2
          exit 1
        fi

        if [[ -n ${2+x} ]]; then

          args['--clone-tor-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-tor-from requires an argument: --clone-tor-from TOR_GW" >&2
          exit 1
        fi
        ;;

      --clone-web-from)

        if [[ -n ${2+x} ]]; then

          args['--clone-web-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-web-from requires an argument: --clone-web-from WEB_VM" >&2
          exit 1
        fi
        ;;

      --clone-split-from)

        if [[ -n ${2+x} ]]; then

          args['--clone-split-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-split-from requires an argument: --clone-split-from SPLIT_BROWSER_VM" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity equip IDENTITY [OPTIONS]\n" >&2
    exit 1
  fi

}

risk_identity_delete_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="identity delete"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --backup | -b)

        args['--backup']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity delete IDENTITY [OPTIONS]\n" >&2
    exit 1
  fi

}

risk_identity_nake_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_nake_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="identity nake"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity nake IDENTITY\n" >&2
    exit 1
  fi

}

risk_identity_open_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_open_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="identity open"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity open IDENTITY\n" >&2
    exit 1
  fi

}

risk_identity_close_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_close_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="identity close"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_identity_start_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_start_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="identity start"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity start IDENTITY\n" >&2
    exit 1
  fi

}

risk_identity_stop_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_stop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="identity stop"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_identity_current_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_current_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="identity current"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_slam_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_slam_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="slam"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_vpn_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    create)
      action="create"
      shift
      risk_vpn_create_parse_requirements "$@"
      shift $#
      ;;

    add)
      action="add"
      shift
      risk_vpn_add_parse_requirements "$@"
      shift $#
      ;;

    setup)
      action="setup"
      shift
      risk_vpn_setup_parse_requirements "$@"
      shift $#
      ;;

    start)
      action="start"
      shift
      risk_vpn_start_parse_requirements "$@"
      shift $#
      ;;

    stop)
      action="stop"
      shift
      risk_vpn_stop_parse_requirements "$@"
      shift $#
      ;;

    enable)
      action="enable"
      shift
      risk_vpn_enable_parse_requirements "$@"
      shift $#
      ;;

    disable)
      action="disable"
      shift
      risk_vpn_disable_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      risk_vpn_delete_parse_requirements "$@"
      shift $#
      ;;

    "")
      risk_vpn_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_vpn_create_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="vpn create"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --label | -L)

        if [[ -n ${2+x} ]]; then

          args['--label']="$2"
          shift
          shift
        else
          printf "%s\n" "--label requires an argument: --label, -L COLOR" >&2
          exit 1
        fi
        ;;

      --enable | -E)

        args['--enable']=1
        shift
        ;;

      --template | -T)

        if [[ -n ${2+x} ]]; then

          args['--template']="$2"
          shift
          shift
        else
          printf "%s\n" "--template requires an argument: --template, -T TEMPLATE" >&2
          exit 1
        fi
        ;;

      --clone | -c)

        args['--clone']=1
        shift
        ;;

      --from | -f)

        if [[ -n ${2+x} ]]; then

          args['--from']="$2"
          shift
          shift
        else
          printf "%s\n" "--from requires an argument: --from, -f VPN_GW" >&2
          exit 1
        fi
        ;;

      --config-in)

        if [[ -n "${args['--choose']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--choose" >&2
          exit 1
        fi

        if [[ -n ${2+x} ]]; then

          args['--config-in']="$2"
          shift
          shift
        else
          printf "%s\n" "--config-in requires an argument: --config-in CONFIG_VM" >&2
          exit 1
        fi
        ;;

      --choose)

        if [[ -n "${args['--config-in']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--config-in" >&2
          exit 1
        fi

        args['--choose']=1
        shift
        ;;

      --set-default)

        args['--set-default']=1
        shift
        ;;

      --netvm | -n)

        if [[ -n ${2+x} ]]; then

          if [[ -n $(validate_netvm "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--netvm, -n VM" "$(validate_netvm "$2")" >&2
            exit 1
          fi

          args['--netvm']="$2"
          shift
          shift
        else
          printf "%s\n" "--netvm requires an argument: --netvm, -n VM" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

risk_vpn_add_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="vpn add"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --enable | -E)

        args['--enable']=1
        shift
        ;;

      --set-default)

        args['--set-default']=1
        shift
        ;;

      --netvm | -n)

        if [[ -n ${2+x} ]]; then

          if [[ -n $(validate_netvm "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--netvm, -n VM" "$(validate_netvm "$2")" >&2
            exit 1
          fi

          args['--netvm']="$2"
          shift
          shift
        else
          printf "%s\n" "--netvm requires an argument: --netvm, -n VM" >&2
          exit 1
        fi
        ;;

      --config-in)

        if [[ -n "${args['--choose']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--choose" >&2
          exit 1
        fi

        if [[ -n ${2+x} ]]; then

          args['--config-in']="$2"
          shift
          shift
        else
          printf "%s\n" "--config-in requires an argument: --config-in CONFIG_VM" >&2
          exit 1
        fi
        ;;

      --choose)

        if [[ -n "${args['--config-in']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--config-in" >&2
          exit 1
        fi

        args['--choose']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn add VM [OPTIONS]\n" >&2
    exit 1
  fi

}

risk_vpn_setup_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_setup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="vpn setup"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --set-default)

        args['--set-default']=1
        shift
        ;;

      --netvm | -n)

        if [[ -n ${2+x} ]]; then

          if [[ -n $(validate_netvm "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--netvm, -n VM" "$(validate_netvm "$2")" >&2
            exit 1
          fi

          args['--netvm']="$2"
          shift
          shift
        else
          printf "%s\n" "--netvm requires an argument: --netvm, -n VM" >&2
          exit 1
        fi
        ;;

      --config-in)

        if [[ -n "${args['--choose']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--choose" >&2
          exit 1
        fi

        if [[ -n ${2+x} ]]; then

          args['--config-in']="$2"
          shift
          shift
        else
          printf "%s\n" "--config-in requires an argument: --config-in CONFIG_VM" >&2
          exit 1
        fi
        ;;

      --choose)

        if [[ -n "${args['--config-in']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--config-in" >&2
          exit 1
        fi

        args['--choose']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn setup VM [OPTIONS]\n" >&2
    exit 1
  fi

}

risk_vpn_start_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_start_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="vpn start"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn start VM\n" >&2
    exit 1
  fi

}

risk_vpn_stop_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_stop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="vpn stop"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn stop VM\n" >&2
    exit 1
  fi

}

risk_vpn_enable_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_enable_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="vpn enable"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn enable VM\n" >&2
    exit 1
  fi

}

risk_vpn_disable_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_disable_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="vpn disable"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn disable VM\n" >&2
    exit 1
  fi

}

risk_vpn_delete_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="vpn delete"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn delete VM\n" >&2
    exit 1
  fi

}

risk_qube_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_qube_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    add)
      action="add"
      shift
      risk_qube_add_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      risk_qube_delete_parse_requirements "$@"
      shift $#
      ;;

    enable)
      action="enable"
      shift
      risk_qube_enable_parse_requirements "$@"
      shift $#
      ;;

    disable)
      action="disable"
      shift
      risk_qube_disable_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      risk_qube_list_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      risk_qube_update_parse_requirements "$@"
      shift $#
      ;;

    dist-upgrade)
      action="dist-upgrade"
      shift
      risk_qube_dist_upgrade_parse_requirements "$@"
      shift $#
      ;;

    "")
      risk_qube_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_qube_add_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_qube_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="qube add"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --netvm | -n)

        if [[ -n ${2+x} ]]; then

          args['--netvm']="$2"
          shift
          shift
        else
          printf "%s\n" "--netvm requires an argument: --netvm, -n VM" >&2
          exit 1
        fi
        ;;

      --set-default)

        args['--set-default']=1
        shift
        ;;

      --enable | -E)

        args['--enable']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk qube add VM [OPTIONS]\n" >&2
    exit 1
  fi

}

risk_qube_delete_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_qube_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="qube delete"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk qube delete VM\n" >&2
    exit 1
  fi

}

risk_qube_enable_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_qube_enable_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="qube enable"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk qube enable VM\n" >&2
    exit 1
  fi

}

risk_qube_disable_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_qube_disable_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="qube disable"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk qube disable VM\n" >&2
    exit 1
  fi

}

risk_qube_list_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_qube_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="qube list"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_qube_update_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_qube_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="qube update"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --identity | -I)

        args['--identity']=1
        shift
        ;;

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)

        if [[ -z ${args['vms']+x} ]]; then

          args['vms']=$1
          shift
        else
          other_args+=("$1")
          shift
        fi

        ;;

    esac
  done

}

risk_qube_dist_upgrade_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_qube_dist_upgrade_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="qube dist-upgrade"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        elif [[ -z ${args['version']+x} ]]; then

          args['version']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk qube dist-upgrade VM VERSION\n" >&2
    exit 1
  fi
  if [[ -z ${args['version']+x} ]]; then
    printf "missing required argument: VERSION\nusage: risk qube dist-upgrade VM VERSION\n" >&2
    exit 1
  fi

}

risk_use_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="use"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)

        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          other_args+=("$1")
          shift
        fi

        ;;

    esac
  done

  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk use VM [...]\n" >&2
    exit 1
  fi

}

risk_url_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_url_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    open)
      action="open"
      shift
      risk_url_open_parse_requirements "$@"
      shift $#
      ;;

    bookmark)
      action="bookmark"
      shift
      risk_url_bookmark_parse_requirements "$@"
      shift $#
      ;;

    "")
      risk_url_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_url_open_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_url_open_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="url open"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['url']+x} ]]; then

          args['url']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

risk_url_bookmark_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_url_bookmark_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="url bookmark"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['url']+x} ]]; then

          args['url']=$1
          shift
        elif [[ -z ${args['title']+x} ]]; then

          args['title']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

risk_config_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    set)
      action="set"
      shift
      risk_config_set_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      risk_config_get_parse_requirements "$@"
      shift $#
      ;;

    unset)
      action="unset"
      shift
      risk_config_unset_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      risk_config_list_parse_requirements "$@"
      shift $#
      ;;

    keys)
      action="keys"
      shift
      risk_config_keys_parse_requirements "$@"
      shift $#
      ;;

    "")
      risk_config_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_config_set_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_set_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="config set"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        elif [[ -z ${args['value']+x} ]]; then

          args['value']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risk config set KEY VALUE\n" >&2
    exit 1
  fi
  if [[ -z ${args['value']+x} ]]; then
    printf "missing required argument: VALUE\nusage: risk config set KEY VALUE\n" >&2
    exit 1
  fi

}

risk_config_get_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="config get"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risk config get KEY\n" >&2
    exit 1
  fi

}

risk_config_unset_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_unset_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="config unset"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risk config unset KEY\n" >&2
    exit 1
  fi

}

risk_config_list_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="config list"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_config_keys_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_keys_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="config keys"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

risk_help_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_help_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="help"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['command']+x} ]]; then

          args['command']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

initialize() {
  version="8efd5b7a13c85983587ff4e9bb4e34e6cdfa8411"
  long_usage=''
  

  # Connected terminal
  typeset -H _TTY

  # Remove verbose errors when * don't yield any match in ZSH
  setopt +o nomatch

  # The generated script makes use of BASH_REMATCH, set compat for ZSH
  setopt BASH_REMATCH

  # Use colors unless told not to
  { ! option_is_set --no-color } && { autoload -Uz colors && colors }


  # Don't run as root
  if [[ $EUID -eq 0 ]]; then
     echo "This script must be run as user"
     exit 2
  fi

  # Configuration file -------------------------------------------------------------------------------
  #
  # Working state and configurations
  typeset -rg RISK_DIR="${HOME}/.risk"                         # Directory where risk stores its state
  typeset -rg RISK_IDENTITIES_DIR="${RISK_DIR}/identities"     # Idendities store their settings here
  typeset -rg RISK_IDENTITY_FILE="${RISK_DIR}/.identity"

  # Create the risk directory if needed
  [[ -e $RISK_DIR ]] || { mkdir -p $RISK_DIR && _info "Creating RISK directory in $RISK_DIR" }
  [[ -e $RISK_IDENTITIES_DIR ]] || mkdir -p $RISK_IDENTITIES_DIR

  # Write the default configuration if it does not exist.
  config_init

  # Default filesystem settings from configuration file ----------------------------------------------
  typeset -g VAULT_VM=$(config_get VAULT_VM)
  typeset -g DEFAULT_NETVM=$(config_get DEFAULT_NETVM)

  typeset -gr DOM0_TERMINAL=$(config_get DOM0_TERMINAL)
  typeset -gr VM_TERMINAL=$(config_get VM_TERMINAL)

  # Working state variables --------------------------------------------------------------------------
  typeset -r IDENTITY                 # The identity to use for this single risk execution
  typeset -g IDENTITY_DIR             # The directory where to store identity settings
  typeset -g IDENTITY_BOOKMARKS_FILE  # The file in mgmt tomb storing user bookmarks.

}

run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"
  initialize

  case "$action" in
    "hush") risk_hush_command ;;
    "hush attach") risk_hush_attach_command ;;
    "hush detach") risk_hush_detach_command ;;
    "backup") risk_backup_command ;;
    "backup attach") risk_backup_attach_command ;;
    "backup detach") risk_backup_detach_command ;;
    "identity") risk_identity_command ;;
    "identity create") risk_identity_create_command ;;
    "identity equip") risk_identity_equip_command ;;
    "identity delete") risk_identity_delete_command ;;
    "identity nake") risk_identity_nake_command ;;
    "identity open") risk_identity_open_command ;;
    "identity close") risk_identity_close_command ;;
    "identity start") risk_identity_start_command ;;
    "identity stop") risk_identity_stop_command ;;
    "identity current") risk_identity_current_command ;;
    "slam") risk_slam_command ;;
    "vpn") risk_vpn_command ;;
    "vpn create") risk_vpn_create_command ;;
    "vpn add") risk_vpn_add_command ;;
    "vpn setup") risk_vpn_setup_command ;;
    "vpn start") risk_vpn_start_command ;;
    "vpn stop") risk_vpn_stop_command ;;
    "vpn enable") risk_vpn_enable_command ;;
    "vpn disable") risk_vpn_disable_command ;;
    "vpn delete") risk_vpn_delete_command ;;
    "qube") risk_qube_command ;;
    "qube add") risk_qube_add_command ;;
    "qube delete") risk_qube_delete_command ;;
    "qube enable") risk_qube_enable_command ;;
    "qube disable") risk_qube_disable_command ;;
    "qube list") risk_qube_list_command ;;
    "qube update") risk_qube_update_command ;;
    "qube dist-upgrade") risk_qube_dist_upgrade_command ;;
    "use") risk_use_command ;;
    "url") risk_url_command ;;
    "url open") risk_url_open_command ;;
    "url bookmark") risk_url_bookmark_command ;;
    "config") risk_config_command ;;
    "config set") risk_config_set_command ;;
    "config get") risk_config_get_command ;;
    "config unset") risk_config_unset_command ;;
    "config list") risk_config_list_command ;;
    "config keys") risk_config_keys_command ;;
    "help") risk_help_command ;;
  esac
}

run "$@"
