#!/usr/bin/env zsh

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
risk_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk - RISKS Dom0 management application\n"
    echo

  else
    printf "risk - RISKS Dom0 management application\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk [OPTIONS] COMMAND\n"
  printf "  risk [COMMAND] --help | -h\n"
  printf "  risk --version\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Manage the risk global configuration\n" "$(red "config")  "
  printf "  %s   Manage the hush partition attach/detach from qubes\n" "$(red "hush")    "
  printf "  %s   Manage backup devices attach/detach from qubes\n" "$(red "backup")  "
  printf "  %s   Create, manage and use identities and/or use their machines\n" "$(red "identity")"
  printf "  %s   Close identity, infrastructure and detach hush/backup at once\n" "$(red "slam")    "
  printf "  %s   Create, configure, manage and use VPN gateways for an identity.\n" "$(red "vpn")     "
  printf "  %s   Manage generic VMs (identity settings, enable/disable, etc)\n" "$(red "vm")      "
  printf "  %s   Execute a command in a VM belong to an identity.\n" "$(red "use")     "
  printf "  %s   Browse, bookmark, verify and manage URLS/links\n" "$(red "url")     "
  printf "  %s   Strutured set of commands for managing Qubes in general\n" "$(red "qubes")   "
  printf "  %s   Show help about a command\n" "$(red "help")    "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
risk_config_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config - Manage the risk global configuration\n"
    echo

  else
    printf "risk config - Manage the risk global configuration\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config COMMAND\n"
  printf "  risk config [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Set a configuration variable to a value\n" "$(red "set")  "
  printf "  %s   Print the value of a configuration variable\n" "$(red "get")  "
  printf "  %s   Delete the value of a configuration variable\n" "$(red "unset")"
  printf "  %s   List all configuration variables\n" "$(red "list") "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_config_set_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config set - Set a configuration variable to a value\n"
    echo

  else
    printf "risk config set - Set a configuration variable to a value\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config set KEY VALUE\n"
  printf "  risk config set --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to set\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "VALUE")"
    printf "    Value to assign to the key\n"
    echo

  fi
}

# :command.usage
risk_config_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config get - Print the value of a configuration variable\n"
    echo

  else
    printf "risk config get - Print the value of a configuration variable\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config get KEY\n"
  printf "  risk config get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to show\n"
    echo

  fi
}

# :command.usage
risk_config_unset_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config unset - Delete the value of a configuration variable\n"
    echo

  else
    printf "risk config unset - Delete the value of a configuration variable\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config unset KEY\n"
  printf "  risk config unset --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to delete/unset\n"
    echo

  fi
}

# :command.usage
risk_config_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config list - List all configuration variables\n"
    echo

  else
    printf "risk config list - List all configuration variables\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config list\n"
  printf "  risk config list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_config_keys_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config keys - List all configuration variables as an array (for completions)\n"
    echo

  else
    printf "risk config keys - List all configuration variables as an array (for completions)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config keys\n"
  printf "  risk config keys --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_hush_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk hush - Manage the hush partition attach/detach from qubes\n"
    echo

  else
    printf "risk hush - Manage the hush partition attach/detach from qubes\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk hush COMMAND\n"
  printf "  risk hush [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Attach the hush device to a qube. Accepts optional args to override default hush/vault\n" "$(red "attach")"
  printf "  %s   Detach the hush device from its current qube, making sure it's not in a read-write state\n" "$(red "detach")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_hush_attach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk hush attach - Attach the hush device to a qube. Accepts optional args to override default hush/vault\n"
    echo

  else
    printf "risk hush attach - Attach the hush device to a qube. Accepts optional args to override default hush/vault\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk hush attach [DEVICE] [VAULT_VM] [OPTIONS]\n"
  printf "  risk hush attach --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--mount, -m"
    printf "    Mount the hush device in the vault (prompts for password)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "DEVICE")"
    printf "    (optional) qubes path to device to use as hush (defaults to SDCARD_BLOCK)\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "VAULT_VM")"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

# :command.usage
risk_hush_detach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk hush detach - Detach the hush device from its current qube, making sure it's not in a read-write state\n"
    echo

  else
    printf "risk hush detach - Detach the hush device from its current qube, making sure it's not in a read-write state\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk hush detach [DEVICE] [VAULT_VM]\n"
  printf "  risk hush detach --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "DEVICE")"
    printf "    (optional) qubes path to device to use as backup (defaults to BACKUP_BLOCK)\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "VAULT_VM")"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

# :command.usage
risk_backup_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk backup - Manage backup devices attach/detach from qubes\n"
    echo

  else
    printf "risk backup - Manage backup devices attach/detach from qubes\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk backup COMMAND\n"
  printf "  risk backup [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Attach a backup device to a qube. Accepts optional args to override default backup/vault\n" "$(red "attach")"
  printf "  %s   Detach the backup device from its current qube, making sure it's not in a read-write state\n" "$(red "detach")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_backup_attach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk backup attach - Attach a backup device to a qube. Accepts optional args to override default backup/vault\n"
    echo

  else
    printf "risk backup attach - Attach a backup device to a qube. Accepts optional args to override default backup/vault\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk backup attach [DEVICE] [VAULT_VM]\n"
  printf "  risk backup attach --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "DEVICE")"
    printf "    (optional) qubes path to device to use as backup (defaults to BACKUP_BLOCK)\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "VAULT_VM")"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

# :command.usage
risk_backup_detach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk backup detach - Detach the backup device from its current qube, making sure it's not in a read-write state\n"
    echo

  else
    printf "risk backup detach - Detach the backup device from its current qube, making sure it's not in a read-write state\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk backup detach [DEVICE] [VAULT_VM]\n"
  printf "  risk backup detach --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "DEVICE")"
    printf "    (optional) qubes path to device to use as backup (defaults to BACKUP_BLOCK)\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "VAULT_VM")"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

# :command.usage
risk_identity_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity - Create, manage and use identities and/or use their machines\n"
    echo

  else
    printf "risk identity - Create, manage and use identities and/or use their machines\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity COMMAND\n"
  printf "  risk identity [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)\n" "$(red "create")  "
  printf "  %s   Creates the infrastructure for an already exiting identity.\n" "$(red "equip")   "
  printf "  %s   Destroys an identity and all its associated machines and data\n" "$(red "delete")  "
  printf "  %s   Delete the VMs belonging to an identity, but not the identity in the vault.\n" "$(red "nake")    "
  printf "  %s   Simply open the identity store in the vault\n" "$(red "open")    "
  printf "  %s   Simply close the identity store in the vault\n" "$(red "close")   "
  printf "  %s   Start the identity in the vault and all of its enabled VMs\n" "$(red "start")   "
  printf "  %s   Stops all machines belonging to an identity, and close its vault if active.\n" "$(red "stop")    "
  printf "  %s   Forbid VMs not belonging to the identity from split/copy features when not active\n" "$(red "restrict")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_identity_create_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity create - Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)\n"
    echo

  else
    printf "risk identity create - Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity create NAME EMAIL EXPIRY_DATE [OPTIONS]\n"
  printf "  risk identity create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--prefix, -P NAME"
    printf "    Use a different name for naming identity VMs\n"
    echo

    # :flag.usage
    printf "  %s\n" "--label, -L COLOR"
    printf "    Specify a label color to be used for all VMs belonging to this identity\n"
    echo

    # :flag.usage
    printf "  %s\n" "--backup, -b"
    printf "    Device file of the backup drive (must be a whole drive without a partition\n    number, eg. /dev/sdb)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--vault-only"
    printf "    Only create the identity in the vault: do not create any machines\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-gw, -G"
    printf "    Don't create a Whonix TOR gateway\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone-gw-from TOR_GW"
    printf "    Instead of creating the TOR gateway from a template, clone an existing TOR\n    AppVM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone-web-from WEB_VM"
    printf "    Instead of creating the Web browsing VM from a template, clone an existing\n    browser AppVM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone-split-from SPLIT_BROWSER_VM"
    printf "    Instead of creating the split-browser VM from a template, clone an existing\n    one\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "NAME")"
    printf "    Name of the identity for which to initialize infrastructure\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "EMAIL")"
    printf "    Email address to use for the GPG identity\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "EXPIRY_DATE")"
    printf "    Human readable, or GPG-compliant expiry duration to use for the GPG subkeys\n    (eg. '1 year', '1 week', etc)\n"
    echo

  fi
}

# :command.usage
risk_identity_equip_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity equip - Creates the infrastructure for an already exiting identity.\n"
    echo

  else
    printf "risk identity equip - Creates the infrastructure for an already exiting identity.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity equip IDENTITY [OPTIONS]\n"
  printf "  risk identity equip --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--prefix, -P NAME"
    printf "    Use a different name for naming identity VMs\n"
    echo

    # :flag.usage
    printf "  %s\n" "--label, -L COLOR"
    printf "    Specify a label color to be used for all VMs belonging to this identity\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-gw, -G"
    printf "    Don't create a Whonix TOR gateway\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone-gw-from TOR_GW"
    printf "    Instead of creating the TOR gateway from a template, clone an existing TOR\n    AppVM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone-web-from WEB_VM"
    printf "    Instead of creating the Web browsing VM from a template, clone an existing\n    browser AppVM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone-split-from SPLIT_BROWSER_VM"
    printf "    Instead of creating the split-browser VM from a template, clone an existing\n    one\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity for which to setup infrastructure\n"
    echo

  fi
}

# :command.usage
risk_identity_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity delete - Destroys an identity and all its associated machines and data\n"
    echo

  else
    printf "risk identity delete - Destroys an identity and all its associated machines and data\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity delete IDENTITY [OPTIONS]\n"
  printf "  risk identity delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--backup, -b"
    printf "    If a backup medium is mounted in vault, also delete the backup if it exists.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity to delete along with machines\n"
    echo

  fi
}

# :command.usage
risk_identity_nake_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity nake - Delete the VMs belonging to an identity, but not the identity in the vault.\n"
    echo

  else
    printf "risk identity nake - Delete the VMs belonging to an identity, but not the identity in the vault.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity nake IDENTITY\n"
  printf "  risk identity nake --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity for which to delete machines\n"
    echo

  fi
}

# :command.usage
risk_identity_open_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity open - Simply open the identity store in the vault\n"
    echo

  else
    printf "risk identity open - Simply open the identity store in the vault\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity open IDENTITY\n"
  printf "  risk identity open --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity to open in the vault\n"
    echo

  fi
}

# :command.usage
risk_identity_close_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity close - Simply close the identity store in the vault\n"
    echo

  else
    printf "risk identity close - Simply close the identity store in the vault\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity close\n"
  printf "  risk identity close --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_identity_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity start - Start the identity in the vault and all of its enabled VMs\n"
    echo

  else
    printf "risk identity start - Start the identity in the vault and all of its enabled VMs\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity start IDENTITY\n"
  printf "  risk identity start --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity to start\n"
    echo

  fi
}

# :command.usage
risk_identity_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity stop - Stops all machines belonging to an identity, and close its vault if active.\n"
    echo

  else
    printf "risk identity stop - Stops all machines belonging to an identity, and close its vault if active.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity stop\n"
  printf "  risk identity stop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_identity_restrict_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity restrict - Forbid VMs not belonging to the identity from split/copy features when not active\n"
    echo

  else
    printf "risk identity restrict - Forbid VMs not belonging to the identity from split/copy features when not active\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity restrict\n"
  printf "  risk identity restrict --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_identity_current_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity current - Prints the active identity as a raw string, to be used by prompts.\n"
    echo

  else
    printf "risk identity current - Prints the active identity as a raw string, to be used by prompts.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity current\n"
  printf "  risk identity current --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_slam_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk slam - Close identity, infrastructure and detach hush/backup at once\n"
    echo

  else
    printf "risk slam - Close identity, infrastructure and detach hush/backup at once\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk slam\n"
  printf "  risk slam --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_vpn_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn - Create, configure, manage and use VPN gateways for an identity.\n"
    echo

  else
    printf "risk vpn - Create, configure, manage and use VPN gateways for an identity.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn COMMAND\n"
  printf "  risk vpn [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Create VPN gateway from a template, or by cloning an existing one.\n" "$(red "create") "
  printf "  %s   Manage, import network configurations and run associated setup wizards\n" "$(red "setup")  "
  printf "  %s   Start a VPN gateway in the background\n" "$(red "start")  "
  printf "  %s   Stop a VPN gateway\n" "$(red "stop")   "
  printf "  %s   Automatically start a VPN gateway when starting the identity.\n" "$(red "enable") "
  printf "  %s   Do not autostart this VM when the identity is started\n" "$(red "disable")"
  printf "  %s   Delete a VPN gateway\n" "$(red "delete") "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_vpn_create_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn create - Create VPN gateway from a template, or by cloning an existing one.\n"
    echo

  else
    printf "risk vpn create - Create VPN gateway from a template, or by cloning an existing one.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn create [VM] [OPTIONS]\n"
  printf "  risk vpn create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--name, -N NAME"
    printf "    Use a different name for naming identity VMs\n"
    echo

    # :flag.usage
    printf "  %s\n" "--label, -L COLOR"
    printf "    Specify a label color to be used for all VMs belonging to this identity\n"
    echo

    # :flag.usage
    printf "  %s\n" "--enable, -E"
    printf "    Autostart this VM when the identity is started\n"
    echo

    # :flag.usage
    printf "  %s\n" "--template, -T TEMPLATE"
    printf "    TemplateVM to use instead of the default VPN TemplateVM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone, -c"
    printf "    Instead of creating the VPN gateway from a template, clone an existing VPN\n    AppVM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--from, -f VPN_GW"
    printf "    VM to clone instead of the default VPN_VM configuration setting\n"
    echo

    # :flag.usage
    printf "  %s\n" "--set-default"
    printf "    Set this VM as the default NetVM for all identity client VMs (browsers,\n    messaging, etc)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--config-in CONFIG_VM"
    printf "    VM in which to browse for VPN configuration(s)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--netvm, -n VM"
    printf "    NetVM to use for the gateway\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    (optional) name to use for this VM (=> name-vpn)\n"
    echo

  fi
}

# :command.usage
risk_vpn_setup_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn setup - Manage, import network configurations and run associated setup wizards\n"
    echo

  else
    printf "risk vpn setup - Manage, import network configurations and run associated setup wizards\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn setup VM [OPTIONS]\n"
  printf "  risk vpn setup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--config-in CONFIG_VM"
    printf "    VM in which to browse for VPN configuration(s)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--set-default"
    printf "    Set this VM as the default NetVM for all identity client VMs (browsers,\n    messaging, etc)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--netvm, -n VM"
    printf "    NetVM to use for the gateway\n"
    echo

    # :flag.usage
    printf "  %s\n" "--choose"
    printf "    Choose an existing client config by running the setup wizard in the VPN VM\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to operate setup on\n"
    echo

  fi
}

# :command.usage
risk_vpn_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn start - Start a VPN gateway in the background\n"
    echo

  else
    printf "risk vpn start - Start a VPN gateway in the background\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn start VM\n"
  printf "  risk vpn start --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to start\n"
    echo

  fi
}

# :command.usage
risk_vpn_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn stop - Stop a VPN gateway\n"
    echo

  else
    printf "risk vpn stop - Stop a VPN gateway\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn stop VM\n"
  printf "  risk vpn stop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to stop\n"
    echo

  fi
}

# :command.usage
risk_vpn_enable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn enable - Automatically start a VPN gateway when starting the identity.\n"
    echo

  else
    printf "risk vpn enable - Automatically start a VPN gateway when starting the identity.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn enable VM\n"
  printf "  risk vpn enable --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to enable autostart for\n"
    echo

  fi
}

# :command.usage
risk_vpn_disable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn disable - Do not autostart this VM when the identity is started\n"
    echo

  else
    printf "risk vpn disable - Do not autostart this VM when the identity is started\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn disable VM\n"
  printf "  risk vpn disable --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to disable autostart for\n"
    echo

  fi
}

# :command.usage
risk_vpn_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn delete - Delete a VPN gateway\n"
    echo

  else
    printf "risk vpn delete - Delete a VPN gateway\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn delete VM\n"
  printf "  risk vpn delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to delete\n"
    echo

  fi
}

# :command.usage
risk_vm_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vm - Manage generic VMs (identity settings, enable/disable, etc)\n"
    echo

  else
    printf "risk vm - Manage generic VMs (identity settings, enable/disable, etc)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vm COMMAND\n"
  printf "  risk vm [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Tag an existing VM as belonging to the active identity, and change its netVM if one is already set\n" "$(red "add")    "
  printf "  %s   Delete a VM belonging to the current identity\n" "$(red "delete") "
  printf "  %s   Enable an identity VM to autostart\n" "$(red "enable") "
  printf "  %s   Disable an identity VM to autostart\n" "$(red "disable")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_vm_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vm add - Tag an existing VM as belonging to the active identity, and change its netVM if one is already set\n"
    echo

  else
    printf "risk vm add - Tag an existing VM as belonging to the active identity, and change its netVM if one is already set\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vm add VM [OPTIONS]\n"
  printf "  risk vm add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--netvm, -n VM"
    printf "    NetVM to use for this VM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--set-default"
    printf "    If VM provides network, set this VM as default NetVM for identity\n"
    echo

    # :flag.usage
    printf "  %s\n" "--enable, -E"
    printf "    Autostart this VM when the identity is started\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    VM to tag with identity settings\n"
    echo

  fi
}

# :command.usage
risk_vm_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vm delete - Delete a VM belonging to the current identity\n"
    echo

  else
    printf "risk vm delete - Delete a VM belonging to the current identity\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vm delete VM\n"
  printf "  risk vm delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    VM to delete\n"
    echo

  fi
}

# :command.usage
risk_vm_enable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vm enable - Enable an identity VM to autostart\n"
    echo

  else
    printf "risk vm enable - Enable an identity VM to autostart\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vm enable VM\n"
  printf "  risk vm enable --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    VM to enable for autostart\n"
    echo

  fi
}

# :command.usage
risk_vm_disable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vm disable - Disable an identity VM to autostart\n"
    echo

  else
    printf "risk vm disable - Disable an identity VM to autostart\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vm disable VM\n"
  printf "  risk vm disable --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    VM to disable from autostart\n"
    echo

  fi
}

# :command.usage
risk_use_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk use - Execute a command in a VM belong to an identity.\n"
    echo

  else
    printf "risk use - Execute a command in a VM belong to an identity.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk use VM [...]\n"
  printf "  risk use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    VM in which to execute the command\n"
    echo

    # :command.footer
    printf "The target VM does not mandatorily need to belong to the active identity, if there is one.\nIf it does not belongs to another non-active identity, risk will take care of:\n  - Closing the active identity in the vault\n  - Opening the new one\nAfter this, the target VM is launched with the command arguments.\n\n"
    echo

  fi
}

# :command.usage
risk_url_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk url - Browse, bookmark, verify and manage URLS/links\n"
    echo

  else
    printf "risk url - Browse, bookmark, verify and manage URLS/links\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk url COMMAND\n"
  printf "  risk url [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Open a target URL into a target VM, or bookmarks with no arguments.\n" "$(red "open")     "
  printf "  %s   Verify the authenticity/signatures and reputation of an onion URL.\n" "$(red "verify")   "
  printf "  %s   Add an onion to the user/system bookmarks without verifying it.\n" "$(red "bookmark") "
  printf "  %s   Add an onion to the system list of blacklisted onions\n" "$(red "blacklist")"
  printf "  %s   refresh the authenticity files, refered links and current news for an onion.\n" "$(red "news")     "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_url_open_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk url open - Open a target URL into a target VM, or bookmarks with no arguments.\n"
    echo

  else
    printf "risk url open - Open a target URL into a target VM, or bookmarks with no arguments.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk url open [URL]\n"
  printf "  risk url open --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "URL")"
    printf "    URL to browse\n"
    echo

  fi
}

# :command.usage
risk_url_verify_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk url verify - Verify the authenticity/signatures and reputation of an onion URL.\n"
    echo

  else
    printf "risk url verify - Verify the authenticity/signatures and reputation of an onion URL.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk url verify [URL]\n"
  printf "  risk url verify --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "URL")"
    printf "    URL to verify\n"
    echo

  fi
}

# :command.usage
risk_url_bookmark_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk url bookmark - Add an onion to the user/system bookmarks without verifying it.\n"
    echo

  else
    printf "risk url bookmark - Add an onion to the user/system bookmarks without verifying it.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk url bookmark [URL] [OPTIONS]\n"
  printf "  risk url bookmark --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user, -u"
    printf "    Add to identity bookmarks\n"
    echo

    # :flag.usage
    printf "  %s\n" "--system, -s"
    printf "    Add to system-wide (all identities) bookmarks\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "URL")"
    printf "    URL to bookmark (optional, if empty the split-bookmarks file is opened, or\n    the user is prompted for URL/info)\n"
    echo

  fi
}

# :command.usage
risk_url_blacklist_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk url blacklist - Add an onion to the system list of blacklisted onions\n"
    echo

  else
    printf "risk url blacklist - Add an onion to the system list of blacklisted onions\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk url blacklist [URL]\n"
  printf "  risk url blacklist --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "URL")"
    printf "    URL to blacklist\n"
    echo

  fi
}

# :command.usage
risk_url_news_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk url news - refresh the authenticity files, refered links and current news for an onion.\n"
    echo

  else
    printf "risk url news - refresh the authenticity files, refered links and current news for an onion.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk url news [URL]\n"
  printf "  risk url news --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "URL")"
    printf "    URL to fetch news for\n"
    echo

  fi
}

# :command.usage
risk_qubes_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk qubes - Strutured set of commands for managing Qubes in general\n"
    echo

  else
    printf "risk qubes - Strutured set of commands for managing Qubes in general\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk qubes COMMAND\n"
  printf "  risk qubes [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Update one or more VM templates, by name patterns or filters\n" "$(red "update")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_qubes_update_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk qubes update - Update one or more VM templates, by name patterns or filters\n"
    echo

  else
    printf "risk qubes update - Update one or more VM templates, by name patterns or filters\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk qubes update [VMS] [OPTIONS] [...]\n"
  printf "  risk qubes update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--identity, -I"
    printf "    Check for templates of all VMs belong to an identity\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VMS")"
    printf "    An arbitrary list of VMs name patterns to update.\n"
    echo

  fi
}

# :command.usage
risk_help_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk help - Show help about a command\n"
    echo

  else
    printf "risk help - Show help about a command\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk help [COMMAND]\n"
  printf "  risk help --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMMAND")"
    printf "    Help subject\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if ((${#args[@]})); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/config.sh
config_init() {
  RISK_CONFIG_FILE=${RISK_CONFIG_FILE-${RISK_DIR}/config.ini}
  [[ -f "$RISK_CONFIG_FILE" ]] || {
      _info "Writing default configuration file to ${RISK_CONFIG_FILE}"
      cat << EOF > "$RISK_CONFIG_FILE"
; RISKS Dom0 Configuration file

; You can either edit this file in place, set values
; through the 'risk config' command.

; Default Templates =============================================== #

; Default Whonix Workstation TemplateVM for TOR clients
WHONIX_WS_TEMPLATE=whonix-ws-16

; Default Whonix Gateway TemplateVM for TOR gateways
WHONIX_GW_TEMPLATE=whonix-gw-16

; Default TemplateVM to use for VPN VMs
VPN_TEMPLATE=sys-vpn

; Default TemplateVM to use for split-browser backend
SPLIT_BROWSER_TEMPLATE=

; Default AppVMs ================================================== #
;
; These VMs are used when we create new machines by cloning
; existing ones, instead of creating blank AppVMs from templates.

; Default Whonix Workstation AppVM to use for identity client machine
WHONIX_WS=

; Default AppVM to use for cloning new VPN qubes
VPN_VM=

; Default AppVM to clone for split-browser backend
SPLIT_BROWSER=

; Vault settings ================================================== #

; Default vault VM
VAULT_VM=vault

; Qubes path to hush device, such as 'dom0:mmcblk01', or 'sys-usb:sda2', etc
SDCARD_BLOCK=

; Qubes path to backup device, such as 'sys-usb:sdb1'
BACKUP_BLOCK=

; If true, AUTO_MOUNT_HUSH will automatically run the risks hush mount
; command in the target vault when invoking 'risk hush attach', prompting
; the user for the device password. Equivalent to 'risk hush attach -m'
AUTO_MOUNT_HUSH=false

; Other network settings ========================================= #

; Default VM to use as a firewall VM, to which either Tor or VPN gateways are bound
DEFAULT_NETVM=sys-firewall

; Default path to VPN client config in VPN VM, to be loaded when the service
; starts. This path is the default one used by qubes-vpn-support installs.
DEFAULT_VPN_CLIENT_CONF='/rw/config/vpn/vpn-client.conf'

; General Application Settings =================================== #

; Default terminal to use in Dom0
DOM0_TERMINAL=xterm

; Default shell to use in Dom0
DOM0_SHELL=bash

; Default terminal to use in AppVMs
VM_TERMINAL=xterm

; Default shell to use in AppVMs
VM_SHELL=bash

EOF
  }
}

config_get() {
  # zsh compat
  setopt local_options BASH_REMATCH

  local key=$1
  local regex="^$key *= *(.+)$"
  local value=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      value="${BASH_REMATCH[2]}" # Changed to 2 because ZSH indexes start at 1
      break
    fi
  done < "$RISK_CONFIG_FILE"

  echo "$value"
}

config_set() {
  # zsh compat
  setopt local_options BASH_REMATCH

  local key=$1
  shift
  local value="$*"

  config_init

  local regex="^($key) *= *.+$"
  local output=""
  local found_key=""
  local newline

  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line =~ $regex ]]; then
      found_key="${BASH_REMATCH[2]}"
      newline="$key = $value"
      output="$output$newline\n"
    elif [[ $line ]]; then
      output="$output$line\n"
    fi
  done < "$RISK_CONFIG_FILE"

  if [[ -z $found_key ]]; then
    output="$output$key = $value\n"
  fi

  printf "%b\n" "$output" > "$RISK_CONFIG_FILE"
}

config_del() {
  local key=$1

  local regex="^($key) *="
  local output=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line ]] && [[ ! $line =~ $regex ]]; then
      output="$output$line\n"
    fi
  done < "$RISK_CONFIG_FILE"

  printf "%b\n" "$output" > "$RISK_CONFIG_FILE"
}

config_show() {
  config_init
  cat "$RISK_CONFIG_FILE"
}

config_keys() {
  # zsh compat
  setopt local_options BASH_REMATCH

  local regex="^([a-zA-Z0-9_\-\/\.]+) *="

  config_init

  local keys=()
  local key

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      key="${BASH_REMATCH[1]}"
      key="${key//\=/}"
      [[ -n "$key" ]] && keys+=("$key")
    fi
  done < "$RISK_CONFIG_FILE"
  echo "${keys[@]}"
}

config_has_key() {
  [[ $(config_get "$1") ]]
}

# src/lib/device.sh

# Checks that a given device is attached to a given VM
check_is_device_attached ()
{
    local block="$1"
    local vm="$2"

    local ovm=$(qvm-block list | grep "${block}" | awk {'print $4'} | cut -d" " -f1)
    if [[ ${#ovm} -eq 0 ]] || [[ ${ovm} != "$vm" ]]; then
        _failure "Device block $block is not mounted on vault ${vm}"
    fi
}

# device_backup_mounted_on returns 0 if a backup is mounted in the target vault VM.
device_backup_mounted_on ()
{
    local vm="${1-$VAULT_VM}"
    local backup_status

    backup_status="$(qvm-run --pass-io "${vm}" 'risks backup status')"
    if [[ ${backup_status} =~ 'No backup device mounted' ]]; then
        return 1
    fi
}

# src/lib/identity.sh

# Refactors
# _identity_active > Remove ?

# identity_set is used to propagate our various IDENTITY related variables
# so that all functions that will be subsequently called can access them.
#
# This function also takes care of checking if there is already an active
# identity that should be used, in case the argument is empty or none.
#
# $1 - The identity to use.
identity_set ()
{
    local identity="$1"

    # This will throw an error if we don't have an identity from any source.
    IDENTITY=$(_identity_active_or_specified "$identity")
    _catch "Command requires either an identity to be active or given as argument"

    # Set the identity directory
    IDENTITY_DIR="${RISK_IDENTITIES_DIR}/${IDENTITY}"
}

# Upon unlocking a given identity, sets the name as an ENV
# variable that we can use in further functions and commands.
# $1 - The name to use. If empty, just resets the identity.
identity_set_active ()
{
    # If the identity is empty, wipe the identity file
    if [[ -z ${1} ]] && [[ -e ${RISK_IDENTITY_FILE} ]]; then
        identity=$(cat "${RISK_IDENTITY_FILE}")
        rm "${RISK_IDENTITY_FILE}" || _warning "Failed to wipe identity file !"

        _verbose "Identity '${identity}' is now inactive, (name file deleted)"
        _info "Identity '${identity}' is now INACTIVE"
        return
    fi

    # If we don't have a file containing the
    # identity name, populate it.
    if [[ ! -e ${RISK_IDENTITY_FILE} ]]; then
        print "$1" > "${RISK_IDENTITY_FILE}"
	fi

    _verbose "Identity '${1}' is now active (name file written)"
    _info "Identity '${1}' is now ACTIVE"
}

# identity_get_active returns the name of the vault active identity.
identity_get_active ()
{
    qvm-run --pass-io "$VAULT_VM" 'risks identity active' 2>/dev/null
}

# identity_delete_directory deletes the ~/.risk/identities/<identity> directory.
identity_delete_directory ()
{
    if ! _identity_active ; then
        return
    fi
    if [[ -z "${IDENTITY_DIR}" ]]; then
        return
    fi

    _info "Deleting identiy ${IDENTITY} home directory"
    _run -rf "${IDENTITY_DIR}"
}

# Returns 0 if an identity is unlocked, 1 if not.
_identity_active ()
{
    local active_identity

    active_identity=$(qvm-run --pass-io "$VAULT_VM" 'risks identity active' 2>/dev/null)
    if [[ -z "${active_identity}" ]]; then
        return 1
	fi

    return 0
}

# Given an argument potentially containing the active identity, checks
# that either an identity is active, or that the argument is not empty.
# $1 - An identity name
# Exits the program if none is specified, or echoes the identity if found.
# Returns:
# 0 - Identity is non-nil, provided either from arg or by the active
# 1 - None have been given
_identity_active_or_specified ()
{
    local active_identity

    if [[ -z "${1}" ]] ; then
        active_identity=$(qvm-run --pass-io "$VAULT_VM" 'risks identity active' 2>/dev/null)
        if [[ -z "${active_identity}" ]]; then
            return 1
        fi
    fi

    # Print the identity
    if [[ -n "${1}" ]]; then
        print "${1}" && return
    fi

    print "$active_identity"
}

# check that no identity is active in the vault, and fail if there is.
identity_check_none_active ()
{
    active_identity=$(qvm-run --pass-io "$VAULT_VM" 'risks identity active' 2>/dev/null)
    if [[ -n $active_identity ]]; then
        # It might be the same
        if [[ $active_identity == "$1" ]]; then
            _info "Identity $1 is already active"
            exit 0
        fi

        _failure "Identity $active_identity is active. Close/slam/fold it and rerun this command"
    fi
}

# Checks that an identity exists in the vault
identity_check_exists ()
{
    # Get the resulting encrypted name
    local encrypted_identity
    encrypted_identity="$(_encrypt_filename "${IDENTITY}")"

    # And check the directory exists
    _run_exec "$VAULT_VM" "stat /home/user/.graveyard/$encrypted_identity &>/dev/null"
    _catch "Invalid identity: $1 does not exists in ${VAULT_VM}"
}

# Returns the name of the identity to which a VM belongs.
_vm_owner ()
{
    print "$(qvm-tags "$1" "$RISK_VM_OWNER_TAG" 2>/dev/null)"
}

# Returns the default network VM for the active identity
_identity_default_netvm ()
{
    cat "${IDENTITY_DIR}/netvm" 2>/dev/null
}

# Get the default VM label/color for an identity
_identity_default_vm_label ()
{
    cat "${IDENTITY_DIR}/vm_label" 2>/dev/null
}

# Get the TOR gateway for the identity
_identity_tor_gateway ()
{
    cat "${IDENTITY_DIR}/tor_gw" 2>/dev/null
}

# Get the browser VM for the identity
_identity_browser_vm ()
{
    cat "${IDENTITY_DIR}/browser_vm" 2>/dev/null
}

# _identity_proxies returns an array of proxy VMs
# (VPNs and TOR gateways for the current identity)
_identity_proxies ()
{
    [[ -f "${IDENTITY_DIR}/proxy_vms" ]] || return
    read -d '' -r -A proxies <"${IDENTITY_DIR}/proxy_vms"
    echo "${proxies[@]}"
}

# returns all identity VMs that are not gateways/proxies,
# but are potentially (most of the time) accessing network
# from one or more of these gateways.
_identity_client_vms ()
{
    [[ -f "${IDENTITY_DIR}/client_vms" ]] || return
    read -d '' -r -A clients <"${IDENTITY_DIR}/client_vms"
    echo "${clients[@]}"
}

# returns all identity VMs that are not gateways/proxies,
# but are potentially (most of the time) accessing network
# from one or more of these gateways.
_identity_autovm_starts ()
{
    [[ -f "${IDENTITY_DIR}/autovm_starts" ]] || return
    read -d '' -r -A clients <"${IDENTITY_DIR}/autovm_starts"
    echo "${clients[@]}"
}

# _get_name either returns the name given as parameter, or
# generates a random (burner) one and prints it to the screen.
_get_name ()
{
    local name

    if [[ -z "${1}" ]] && [[ "${args['--burner']}" -eq 0 ]]; then
        _failure "Either an identity name is required, or the --burner flag"
    fi

    # Either use the provided one
    if [[ -n "${1}" ]]; then
        name="${1}"
    elif [[ "${args['--burner']}" -eq 1 ]]; then
        name="$(rig -m | head -n 1)"
        name="${name// /_}"
    fi

    print "${name}"
}

# _get_mail returns a correctly formatted mail given either a fully specified
# one as positional, or a generated/concatenated one from the username argument.
_get_mail ()
{
    local name="$1"
    local email="$2"

    [[ -n "${email}" ]] && print "${email}" && return

    email="${args['--mail']}"

    # Return either the mail flag with the name
    [[ -n "${email}" ]] && print "${name}@${email}"
    # Or the lowercase name without spaces
    print "${name// /_}"
}

# _get_expiry returns a correctly formatted expiry date for a GPG key.
# If no arguments are passed to the call, the expiry date is never.
_get_expiry ()
{
    local expiry

    if [[ -z "${1}" ]]; then
        expiry_date="never"
    else
        expiry="${1}"
        expiry_date="$(date +"%Y-%m-%d" --date="${expiry}")"
    fi

    print "${expiry_date}"
}

# src/lib/log.sh


# Section is set either by functions or simple calls,
# so that logging can inform on the component working.
section='risk'

# When multiple sections are used within a single risks
# operation, we padd them, for clearer/better aesthetics.
section_padding=0

# Last log level used. Inline logging uses this.
last_level="message"

# maps levels to their display color
declare -A log_colors
log_colors=(
    [verbose]="blue"
    [message]="white"
    [warning]="yellow"
    [success]="green"
    [failure]="red"
)

# maps levels to notice characters.
declare -A log_chars
log_chars=(
    [inline]=" > "
    [verbose]="[D]"
    [message]=" . "
    [warning]="[W]"
    [success]="(*)"
    [failure]="[E]"
)


# Simple way of setting the section and to update the padding
_in_section ()
{
    section="$1"
    if [[ "${#1}" -gt "${section_padding}" ]]; then
        section_padding="${#1}"
    fi

    if [[ -n "${2}" ]]; then
        section_padding="$2"
    fi
}

function is_verbose_set () {
    if [[ "${args['--verbose']}" -eq 1 ]]; then
        return 0
    else
        return 1
    fi
}

# Messaging function with pretty coloring
function _msg()
{
    # Check if we have been provided a section name,
    # and if not, that the section is set to a default.
    if [[ ${#@} -lt 3 ]]; then
        local progname="$section"
        if [[ -z "$progname" ]]; then
            progname='risk'
        fi
        local msg="$2"
    else
        local progname="$2"
        local msg="$3"
    fi

    # Padd the program/section name
    progname="$(printf %"${section_padding}"s "${progname}")"

    # Apply any translation for non-english users
	# local i
	# command -v gettext 1>/dev/null 2>/dev/null && msg="$(gettext -s "$3")"
	# for i in {3..${#}}; do
	# 	msg=${(S)msg//::$(($i - 2))*::/$*[$i]}
	# done

    # Apply log chars & color
    local pcolor=${log_colors[$1]}
    local pchars=${log_chars[$1]}

    # Use the display of last message when inline
    [[ "$1" == "inline" ]] && { pcolor=${log_colors[$last_level]}; pchars=${log_chars[inline]} }
    last_level="$1"

	local command="print -P"
	local fd=2
	local -i returncode

	case "$1" in
		inline)
			command+=" -n"
			;;
		failure)
			returncode=1
			;;
		print)
			progname=""
			fd=1
			;;
		# *)
		# 	pchars="[F]"; pcolor="red"
		# 	msg="Developer oops!  Usage: _msg MESSAGE_TYPE \"MESSAGE_CONTENT\""
		# 	returncode=127
			# ;;
	esac

	[[ -n $_MSG_FD_OVERRIDE ]] && fd=$_MSG_FD_OVERRIDE

    # If there is a log-file specified with flag --log-file,
    # output the message to it, instead of the current file descriptor
    logfile="${args[--log-file]}"
    if [[ -n "${logfile}" ]]; then
        ${=command} "${progname}" "${pchars}" "${msg}" >> "$logfile"
        return $returncode
    fi

    # Else, print to stdout, with colors
	if [[ -t $fd ]]; then
       [[ -n "$progname" ]] && progname="${fg[magenta]}$progname$reset_color"
       [[ -n "$pchars" ]] && pchars="${fg_bold[$pcolor]}$pchars$reset_color"
       msg="$fg[$pcolor]$msg$reset_color"
	fi

    ${=command} "${progname}" "${pchars}" "${msg}" >&"$fd"
	return $returncode
}

function _info() {
	local notice="message"
	[[ "$1" = "-n" ]] && shift && notice="inline"
    option_is_set -q || _msg "$notice" "$@"
	return 0
}

function _verbose() {
    is_verbose_set && _msg verbose "$@"
	return 0
}

function _success() {
    option_is_set -q || _msg success "$@"
	return 0
}

function _warning() {
    option_is_set -q || _msg warning "$@"
	return 1
}

# failure first prints the message we have passed following the catch
# of an error exit code, and then looks at the contents of erroring
# command's stderr buffer, which is printed just below our message.
# We then exit the program.
function _failure()
{
	typeset -i exitcode=${exitv:-1}

    _msg failure "$@"

    # Trim the message from any risks/risq header and print
    if [[ -n "$COMMAND_STDERR" ]]; then
        stderr=$(sed -r 's/^(risks|risq) \[[^][]*\]//' <<< "${COMMAND_STDERR}")
        stderr=$(sed -r 's/^(risks|risq)[ ]{1,}>//' <<< "${stderr}")
        stderr=$(sed -r 's/^[ ]{1,}//' <<< "${stderr}")

        _msg inline "$stderr"
    fi

	# Be sure we forget the secrets we were told
    exit "$exitcode"
}

# function _failure() {
# 	typeset -i exitcode=${exitv:-1}
#     option_is_set -q || _msg failure "$@"
# 	# be sure we forget the secrets we were told
#     exit "$exitcode"
# }

function _print() {
    option_is_set -q || _msg print "$@"
	return 0
}

# src/lib/messenger.sh

# Creates a new Messaging AppVM.
# $1 - Name to use for new VM
# $2 - Netvm for this VM
# $3 - Label
create_messenger_vm ()
{
    local msg="${1}-msg"
    local netvm="${2-$(config_get DEFAULT_NETVM)}"
    local gw_label="${3-orange}"

    local ws_template="$(config_get WHONIX_WS_TEMPLATE)"

    local -a create_command
    create_command+=(qvm-create --property netvm="$netvm" --label "$gw_label" --template "$ws_template")

    _info "Creating messaging VM (name: $msg / netvm: $netvm / template: $ws_template)"
}

# very similar to create_messenger_vm , except that we clone
# an existing AppVM instead of creating a new one from a Template.
clone_messenger_vm ()
{
    local msg="${1}-msg"
    local gw_clone="$2"
    local netvm="${3-$(config_get DEFAULT_NETVM)}"
    local gw_label="${4-orange}"

    create_command+=(qvm-clone "${gw_clone}" "${msg}")

    local label_command=(qvm-prefs "$msg" label "$gw_label")
    local netvm_command=(qvm-prefs "$msg" netvm "$netvm")

    _info "Cloning messaging VM (name: $msg / netvm: $netvm / template: $gw_clone)"
}

# src/lib/network.sh

#

# check_vm_owner verifies that the VM is owned by the current identity.
check_valid_netvm ()
{
    local vm="$1"
    local owner
    local tor_gw

    # Or if the owner is either non-existant or not the good one, we must fail.
    owner="$(_vm_owner "$vm")"
    [[ -n "$owner" ]] || _failure "VM $vm has no RISKS owner. Aborting"
    [[ "$owner" == "$IDENTITY" ]] || _failure "VM $vm does not belong to identity $IDENTITY"

    # If there is not network VM, there is nothing to do
    netvm="$(qvm-prefs "$vm" netvm)"
    [[ -z "$netvm" ]] && return 0

    # If the VM is the whonix gateway for the identity, we are done with the chain
    [[ "$vm" == "$(_identity_tor_gateway)" ]] && return 0

    # We also return if its the sys-firewall, which does not belong to any identity.
    [[ "$vm" == "$(config_get DEFAULT_NETVM)" ]] && return 0

    # Or check if the netVM is in one of the identity proxies, or if its the default VM
    _vm_is_identity_proxy "$netvm" || _failure "NetworkVM $vm is not listed as one of the identity's proxies"

    # Else, we go on with the netvm and do the same steps
    check_valid_netvm "$netvm"
}

# network_check_identity_chain verifies that the NetVM of a given VM indeed belongs
# to the same owner, and does this recursively for each NetVM found in the chain.
network_check_identity_chain ()
{
    local vm="$1"
    local netvm
    local owner

    _verbose "Checking network chain (starting from VM $vm)"

    # If there is not network VM, there is nothing to do
    netvm="$(qvm-prefs "$vm" netvm)"
    [[ -z "$netvm" ]] && return 0

    # This call recursively checks for all netVMs
    check_valid_netvm "$netvm"
}

# fail_vm_provides_network fails if the VM provides network to any other VM
fail_vm_provides_network ()
{
    local vm="$1"
    local vms connected_vms

    # If it does not provide network at all, don't go further.
    [[ $(qvm-prefs "$vm" provides_network) == "True" ]] || return 0

    # Check if it provides network to any VM, and if yes, fail.
    vms=( $(_vm_list) )
    for svm in "${vms[@]}" ; do
        local netvm
        if [[ "$(qvm-prefs "$svm" netvm)" == "$vm" ]]; then
            connected_vms+=( "$svm" )
        fi
    done

    [[ ${#connected_vms} -gt 0 ]] && _failure "VM $vm is netVM for [ ${connected_vms[*]} ] VMs"
}

# src/lib/run.sh

COMMAND_STDOUT=''           # Stores a command's stdout output.
COMMAND_STDERR=''           # Stores a command's stderr output.

# do a command, splitting and storing stdout/stderr output and printing
# the former to screen only if the command is ran with verbose flag.
# Returns the command's exit code, so we can catch any errors and inform.
_run ()
{
    # The STDOUT/STDERR variables are populated, which
    # makes their content available to any subsequent call
    # to _failure, which needs STDERR output
    {
        IFS=$'\n' read -r -d '' COMMAND_STDERR;
        IFS=$'\n' read -r -d '' COMMAND_STDOUT;
        (IFS=$'\n' read -r -d '' _ERRNO_; exit "${_ERRNO_}");
    } < <((printf '\0%s\0%d\0' "$("$@")" "${?}" 1>&2) 2>&1)

    local ret="$?"

    # Output the command's result depending on the verbose mode
    # and if the command ran successfully. We check that either
    # stdout or stderr are non-empty: sometimes commands might
    # output to stderr, like wipe.
    if [[ $ret -eq 0 ]] && is_verbose_set ; then
        if [[ -n "$COMMAND_STDOUT" ]]; then
            _verbose "$COMMAND_STDOUT"
        fi
    fi

    # Return the command's exit code
    return $ret
}

# run a command in a qube
# $1 - Qube name
# $@ - Command string to run
_run_qube ()
{
    local vm="$1" ; shift
    local command="$*"
    local terminal shell shell_command full_command

    # Prepare the full command
    terminal="$(config_get VM_TERMINAL)"
    shell="$(config_get VM_SHELL)"
    # shell_command='zsh -c "'"$command"'"'
    shell_command="${shell} -c '$command'"
    full_command=(qvm-run --pass-io "$vm" "$shell_command")

    _verbose "Running command: ${full_command[*]}"

    # Split io like in _run, and store the return value
    # Note that we don't double quote the $full_command variable.
    {
        IFS=$'\n' read -r -d '' COMMAND_STDERR;
        IFS=$'\n' read -r -d '' COMMAND_STDOUT;
        (IFS=$'\n' read -r -d '' _ERRNO_; exit "${_ERRNO_}");
    } < <((printf '\0%s\0%d\0' "$( "${full_command[@]}" )" "${?}" 1>&2) 2>&1)

    local ret="$?"

    # Output the command's result depending on the verbose mode
    # and if the command ran successfully like in _run also.
    if [[ $ret -eq 0 ]] && is_verbose_set ; then
        if [[ -n "$COMMAND_STDOUT" ]]; then
            _verbose "$COMMAND_STDOUT"
        fi
    fi

    return $ret
}

# _run_exec is a simplified version of _run_qube, without stdout/err split & store.
_run_exec ()
{
    local vm="$1"
    shift
    local command="$*"

    # If we don't have any command arguments, we run the default terminal
    [[ -z "$command" ]] && command="$VM_TERMINAL"

    _verbose "Running command: ${command}"

    # Run the command raw, so that we get the output as it is.
    qvm-run --pass-io "$vm" "${command}"
}

# _run_qube_term spawns a terminal on a target qube, with an associated command to run.
_run_qube_term ()
{
    local vm="$1" ; shift
    local command="$*"
    local terminal shell shell_command

    # Prepare the full command
    terminal="$(config_get VM_TERMINAL)"
    shell="$(config_get VM_SHELL)"
    shell_command="${shell} -c '$command'"

    # Run the raw command, so that we get the output as it is.
    qvm-run --pass-io "$vm" "$terminal" -e "$shell_command"
}

# Checks the return code of a command, and if not successful,
# fails with the associated error message. Usage:
# catch $ret "hush" "Failed to execute this command"
function _catch ()
{
    local ret="$?"

    if [[ ! $ret -eq 0 ]]; then
        _failure "$@"
    fi
}

# src/lib/secrets.sh

# _encrypt_filename takes a filename as input, and uses the currently
# set identity to produce an random name to use as a file/directory name.
_encrypt_filename ()
{
    local encryption_key_cmd="echo '$1' | spectre -q -n -s 0 -F n -t n -u '$1' 'file_encryption_key'"
    encryption_key="$(qvm-run --pass-io "$VAULT_VM" "$encryption_key_cmd")"

    local encrypted_identity_command="echo '$encryption_key' | spectre -q -n -s 0 -F n -t n -u '$IDENTITY' '$1'"

    # -q            Quiet: just output the password/filename
    # -n            Don't append a newline to the password output
    # -s 0          Read passphrase from stdinput (fd 0)
    # -F n          No config file output
    # -t n          Output a nine characters name, without symbols
    # -u ${user}    User for which to produce the password/name
    print "$(qvm-run --pass-io "$VAULT_VM" "$encrypted_identity_command")"
}

# src/lib/tor_gateway.sh

# Creates a new TOR Whonix gateway AppVM.
# $1 - Name to use for new VM
# $2 - Netvm for this gateway
# $3 - Label
tor_gateway_create ()
{
    local gw="${1}-gw"
    local netvm="${2-$(config_get DEFAULT_NETVM)}"
    local gw_label="${3-yellow}"

    local gw_template="$(config_get WHONIX_GW_TEMPLATE)"

    _info "Creating TOR gateway VM (name: $gw / netvm: $netvm / template: $gw_template)"
    _run qvm-create "${gw}" --property netvm="$netvm" --label "$gw_label" --template "$gw_template"
    _run qvm-prefs "$gw" provides_network true

    # Tag the VM with its owner, and save as identity tor gateway
    _run qvm-tags "$gw" set "$IDENTITY"
    echo "$gw" > "${IDENTITY_DIR}/tor_gw"
    echo "$gw" > "${IDENTITY_DIR}/net_vm"
}

# very similar to tor_gateway_create, except that we clone an existing
# gateway AppVM instead of creating a new one from a Template.
tor_gateway_clone ()
{
    local gw="${1}-gw"
    local gw_clone="$2"
    local netvm="${3-$(config_get DEFAULT_NETVM)}"
    local gw_label="${4-yellow}"

    _info "Cloning TOR gateway VM (name: $gw / netvm: $netvm / template: $gw_clone)"
    _run qvm-clone "${gw_clone}" "${gw}"
    _catch "Failed to clone VM ${gw_clone}"

    # For now disposables are not allowed, since it would create too many VMs,
    # and complicate a bit the setup steps for VPNs. If the clone is a template
    # for disposables, unset it
    local disp_template
    disp_template=$(qvm-prefs "${gw}" template_for_dispvms)
    if [[ "$disp_template" = "True" ]]; then
        qvm-prefs "${gw}" template_for_dispvms False
    fi

    _info "Getting network from $netvm"
    _run qvm-prefs "$gw" netvm "$netvm"

    _verbose "Setting label to $gw_label"
    _run qvm-prefs "$gw" label "$gw_label"

    # Tag the VM with its owner, and save as identity tor gateway
    _run qvm-tags "$gw" set "$IDENTITY"
    echo "$gw" > "${IDENTITY_DIR}/tor_gw"
    echo "$gw" > "${IDENTITY_DIR}/net_vm"
}

# src/lib/utils.sh

# Return 0 if is set, 1 otherwise
option_is_set() {
	local -i r	 # the return code (0 = set, 1 = unset)

	[[ -n ${(k)OPTS[$1]} ]];
	r=$?

	[[ $2 == "out" ]] && {
		[[ $r == 0 ]] && { print 'set' } || { print 'unset' }
	}

	return $r;
}

# Retrieves the value of a variable first by looking in the risk
# config file, and optionally overrides it if the flag is set.
# $1 - Flag argument
# $2 - Key name in config
config_or_flag ()
{
    local value config_value

    config_value=$(config_get $2)   # From config
    value="${1:=$config_value}"      # overriden by flag if set

    print $value
}

# contains(string, substring)
#
# Returns 0 if the specified string contains the specified substring,
# otherwise returns 1.
contains() {
    string="$1"
    substring="$2"
    if test "${string#*$substring}" != "$string"
    then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

# src/lib/validations/validate_devices.sh

validate_device () {
    local block="$1"

    # And check not already attached to another qube
    ovm=$(qvm-block list | grep "${block}" | awk {'print $4'} | cut -d" " -f1)

    if [[ ${#ovm} -gt 0 ]]; then
        echo -e "Block ${block} is currently attached to ${ovm}."
        echo "Please umount it properly from there and rerun this program."
        return
    fi
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# src/lib/validations/validate_vm.sh

# does the vm exist?
validate_vm_exists () {
    vm=""
    for item in $(qvm-ls | grep -v dom0 | awk '{print $1}' | grep "${1}")
    do
        if [ "${item}" == "${1}" ]; then
            vm=${1}
        fi
    done
    if [ ${#vm} -eq 0 ]; then
        echo "No vm with name ${1} exists or can not be used. Aborted."
        return
    fi
}

# Checks that the vault VM obeys a few requirements, like no network
validate_valid_vaultvm () {
    vm=""
    for item in $(qvm-ls | grep -v dom0 | awk '{print $1}' | grep "${1}")
    do
        if [ "${item}" == "${1}" ]; then
            vm=${1}
        fi
    done
    if [ ${#vm} -eq 0 ]; then
        echo "No vm with name ${1} exists or can not be used. Aborted."
        return
    fi

    netvm=$(qvm-prefs "${vm}" | grep "netvm" | awk '{print $3}')
    if [ "${netvm}" != "None" ]; then
        echo "${vm} might be connected to the internet. Aborted."
        echo "Check: qvm-prefs ${vm} | grep netvm"
    fi
}

# src/lib/vm.sh

#
# ========================================================================================
# Attributes functions
# ========================================================================================
#
# Functions starting with an underscore
# give information and values related to VMs,
#

# Returns the name of the identity to which a VM belongs.
_vm_owner ()
{
    print "$(qvm-tags "$1" "$RISK_VM_OWNER_TAG" 2>/dev/null)"
}

# Returns the template used by a given AppVM
_vm_updatevm_template ()
{
    qvm-ls | grep "$(qubes-prefs updatevm)" | grep "TemplateVM" | awk '{print $1}'
}

# _vm_focused returns the name of the VM owning the currently active window.
_vm_focused ()
{
    local window_class parts vm
    window_class="$(xdotool getwindowclassname "$(xdotool getactivewindow)")"

    # No colon means dom0
    if [[ ${window_class} == *:* ]]; then
        parts=( ${(s[:])window_class} )
        print "${parts[1]}"
    else
        print "dom0"
    fi
}

# Returns an array of all VMs
_vm_list ()
{
    local -a vms

    while IFS= read -r VM_NAME ; do
        vms+=("${VM_NAME}")
    done < <(qvm-ls --raw-list | sort)

    echo "${vms[@]}"
}

# _vm_list_updateable returns all templates and standalone VMs
_vm_list_updateable ()
{
    local templates=()
    while read line ; do
        IFS="|" read -r name class <<< "${line}"
        if [[ "$class" == "TemplateVM" ]]; then
            templates+=( "$name" )
        elif [[ "$class" == "StandaloneVM" ]]; then
            templates+=( "$name" )
        fi
    done < <(qvm-ls --raw-data --fields name,class | sort)

    echo "${templates[@]}"
}

# _vm_args returns a list of VMs that are either explicitly named
# in the array passed as arguments, or those belonging to some
# "group keyword" of this same array.
_vm_args ()
{
    local vms=("$@")
    local _vm_list=()
    local can_update=()
    local updatevm

    # Return if our only argument is empty

    # All updateable VMs, except the updater one
    read -rA can_update <<< "$(_vm_list_updateable)"
    updatevm="$(_vm_updatevm_template)"
    can_update=( ${can_update:#$~updatevm} )

    for word in "${vms[@]}"; do
        case "${word}" in
            # First check for group keywords
            all)
                _vm_list+=( "${updatevm}" )
                _vm_list+=( "${can_update[@]}" )
                ;;
            cacher)
                _vm_list+=( "${updatevm}" )
                ;;
            torbrowser)
                ;;
            dom0)
                ;;
            # Else return the VM name itself
            *)
                for vm in "${can_update[@]}"; do
                    [[ "${vm}" =~ ${word} ]] && _vm_list+=( "${vm}" )
                done
                ;;
        esac

    done

    echo "${_vm_list[@]}"
}

# _vm_is_identity_proxy verifies that the identity's proxy VMs arrays contains a given VM.
_vm_is_identity_proxy ()
{
    local vm="$1"
    local match proxies

    match=1
    read -rA proxies < <(_identity_proxies)

    for proxy in "${proxies[@]}"; do
        if [[ $vm == "$proxy" ]]; then
            match=0
            break
        fi
    done

    return $match
}

# _vm_root_template returns the updateable template of a given VM.
# Example: if a disposable VM is given as argument, the first resolved
# template is the dispvm template, which itself is an AppVM, so we get
# the template of the dispvm template.
_vm_root_template ()
{
    local vm="${1}"
    local updateable

    template="$(qvm-prefs "${vm}" template 2>/dev/null)"
    updateable="$(qvm-prefs "${vm}" updateable 2>/dev/null)"

    while [[ "${updateable}" == "False" ]]; do
        template="$(qvm-prefs "${template}" template 2>/dev/null)"
        updateable="$(qvm-prefs "${template}" updateable 2>/dev/null)"
    done

    echo "${template}"
}

# ========================================================================================
#  VM control and settings management
# ========================================================================================
#

# vm_init_identity_settings is used once when creating
# VMs for an identity, and requires access to argu

# Enables a VM to autostart
vm_enable_autostart ()
{
    local name="$1"
    local autovm_starts=( "$(_identity_autovm_starts)" )

    # Check if the VM is already marked autostart
    for vm in "${autovm_starts[@]}" ; do
        if [[ $vm == "$name" ]]; then
            already_enabled=true
        fi
    done

    if [[ ! $already_enabled ]]; then
        _info "Enabling VM ${name} to autostart"
        echo "$name" >> "${IDENTITY_DIR}/autovm_starts"
    else
        _info "VM ${name} is already enabled"
    fi
}

# Disables a VM to autostart
vm_disable_autostart ()
{
    local name="$1"
    _info "Disabling VM $name"
    sed -i /"$name"/d "${IDENTITY_DIR}/autovm_starts"
}

# vm_start [vm 1] ... [vm n]
#Start the given VMs without executing any command.
vm_start ()
{
    local ret=0

    local vm=
    declare -A pids=() #VM --> pid
    for vm in "$@" ; do
        [[ "$vm" == "dom0" ]] && continue
        _verbose "Starting: $vm"
        vm_assert_running "$vm" &
        pids["$vm"]=$!
    done

    local failed=""
    local ret=
    for vm in "${(@k)pids}" ; do
        wait "${pids["$vm"]}"
        ret=$?
        [ $ret -ne 0 ] && failed="$failed"$'\n'"$vm ($ret)"
    done

    [ -z "$failed" ] || _verbose "Starting the following VMs failed: $failed"

    #set exit code
    [ -z "$failed" ]
}

# vm_shutdown [vm 1] ... [vm n]
#Shut the given VMs down.
vm_shutdown ()
{
    local ret=0

    if [ $# -gt 0 ] ; then
        #make sure the VMs are unpaused
        #cf. https://github.com/QubesOS/qubes-issues/issues/5967
        local vm=
        for vm in "$@" ; do
            qvm-unpause "$vm" &> /dev/null
        done

        _verbose "Shutting down: $*"
        qvm-shutdown --wait "$@"
        ret=$?
    fi

    return $ret
}

#vm_assert_running [vm] [start]
#Assert that the given VM is running. Will unpause paused VMs and may start shut down VMs.
#[vm]: VM for which to make sure it's running.
#[start]: If it's not running and not paused, start it (default: 0/true). If set to 1, this function will return a non-zero exit code.
#returns: A non-zero exit code, if it's not running and/or we failed to start the VM.
vm_assert_running ()
{
    local vm="$1"
    local start="${2:-0}"

    #make sure the VM is unpaused
    if qvm-check --paused "$vm" &> /dev/null ; then
        qvm-unpause "$vm" &> /dev/null || return 1
    else
        if [ "$start" -eq 0 ] ; then
            qvm-start --skip-if-running "$vm" &> /dev/null || return 1
        else
            #we don't attempt to start
            return 2
        fi
    fi

    return 0
}

# vm_delete deletes a VM belonging to the identity, and removes its from the
# specified file. If this file is empty after this, it is deleted here.
# $1 - VM name.
# $2 - The file to search under ${IDENTITY_DIR}/ for deletion.
vm_delete ()
{
    local vm="${1}"
    local file="${2}"

    if [[ -z "${vm}" ]]; then
        return
    fi

    # Attempt to delete: if fails, return without touching the specified file.
    _info "Deleting VM ${vm}"
    _run qvm-remove --force --verbose "${vm}"
    if [[ $? -gt 0 ]]; then
        return
    fi

    if [[ -z "${file}" ]]; then
        return
    fi

    # Delete the VM from the file
    sed -i "/${vm}/d" "${IDENTITY_DIR}/${file}"
    if [[ -z "$(cat "${IDENTITY_DIR}/${file}")" ]]; then
        rm "${IDENTITY_DIR}/${file}"
    fi
}

# vm_shutdown_identity powers off all running VMs belonging to the identity.
vm_shutdown_identity ()
{
    local clients proxies tor_gateway browser_vm net_vm other_vms

    # Client VMs
    read -rA clients < <(_identity_client_vms)
    for vm in "${clients[@]}" ; do
        if [[ -z "${vm}" ]]; then
            continue
        fi
        _info "Shutting down $vm"
        vm_shutdown "$vm"
    done

    # Browser VMs (disposables to find from template/tag)
    browser_vm="$(_identity_browser_vm)"
    if [[ -n "${browser_vm}" ]]; then
        _info "Shutting down $browser_vm"
        vm_shutdown "$browser_vm"
    fi

    # Proxy VMs
    read -rA proxies < <(_identity_client_vms)
    for vm in "${proxies[@]}" ; do
        if [[ -z "${vm}" ]]; then
            continue
        fi
        _info "Shutting down $vm"
        vm_shutdown "$vm"
    done

    # Tor gateway.
    tor_gateway="$(_identity_tor_gateway)"
    if [[ -n "${tor_gateway}" ]]; then
        _info "Shutting down $tor_gateway"
        vm_shutdown "$tor_gateway"
    fi

    # Other VMs that are tagged with the identity.
    read -rA other_vms < <(_vm_list)
    for vm in "${other_vms[@]}" ; do
        if [[ -z "${vm}" ]]; then
            continue
        fi

        if [[ "$(_vm_owner "${vm}")" == "${IDENTITY}" ]]; then
            _info "Shutting down $vm"
            vm_shutdown "$vm"
        fi
    done
}

# vm_delete_identity deletes all VMs belonging to an identity.
vm_delete_identity ()
{
    local clients proxies tor_gateway browser_vm net_vm other_vms

    # Client VMs
    read -rA clients < <(_identity_client_vms)
    for client in "${clients[@]}"; do
        vm_delete "${client}" "client_vms"
    done

    # Browser VM
    browser_vm="$(_identity_browser_vm)"
    if [[ -n "${browser_vm}" ]]; then
        vm_delete "${browser_vm}" "browser_vm"
    fi

    # Proxy VMs
    read -rA proxies < <(_identity_client_vms)
    for proxy in "${proxies[@]}"; do
        vm_delete "${proxy}" "proxy_vms"
    done

    # Tor gateway.
    tor_gateway="$(_identity_tor_gateway)"
    if [[ -n "${tor_gateway}" ]]; then
        vm_delete "${tor_gateway}" "tor_gw"
    fi

    # Net VM

    # Other VMs that are tagged with the identity.
    read -rA other_vms < <(_vm_list)
    for vm in "${other_vms[@]}"; do
        if [[ "$(_vm_owner "${vm}")" == "${IDENTITY}" ]]; then
            vm_delete "${vm}"
        fi
    done
}

# src/lib/vpn_gateway.sh

# Creates a new VPN gateway from a TemplateVM
vpn_create ()
{
    local gw="${1}"
    local netvm="${2-$(config_get DEFAULT_NETVM)}"
    local gw_label="${3:=blue}"
    local template="${4:=$(config_get VPN_TEMPLATE)}"

    _verbose "VPN gateway properties (name: $gw / netvm: $netvm / template: $template)"
    _run qvm-create --property netvm="$netvm" --label "$gw_label" --template "$template"

    _info "Getting network from $netvm"

    # Tag the VM with its owner, and add the gateway to the list of proxies
    _run qvm-tags "$gw" set "$IDENTITY"
    echo "$gw" >> "${IDENTITY_DIR}/proxy_vms"
}

# Creates a new VPN gateway from an existing VPN AppVM
vpn_clone ()
{
    local gw="${1}"
    local netvm="${2-$(config_get DEFAULT_NETVM)}"
    local gw_label="${3:=blue}"
    local gw_clone="$4"

    # Create the VPN
    _verbose "VPN gateway properties (name: $gw / netvm: $netvm / clone: $gw_clone)"
    _run qvm-clone "${gw_clone}" "${gw}"
    _catch "Failed to clone VM ${gw_clone}"

    # For now disposables are not allowed, since it would create too many VMs,
    # and complicate a bit the setup steps for VPNs. If the clone is a template
    # for disposables, unset it
    local disp_template
    disp_template=$(qvm-prefs "${gw}" template_for_dispvms)
    [[ "$disp_template" = "True" ]] && qvm-prefs "${gw}" template_for_dispvms False

    _info "Getting network from $netvm"
    _run qvm-prefs "$gw" netvm "$netvm"

    _verbose "Setting label to $gw_label"
    _run qvm-prefs "$gw" label "$gw_label"

    # Tag the VM with its owner, and add the gateway to the list of proxies
    _run qvm-tags "$gw" set "$IDENTITY"
    echo "$gw" >> "${IDENTITY_DIR}/proxy_vms"
}

# function to browse for one or more (as zip) VPN client configurations
# in another VM, import them in our VPN VM, and run the setup wizard if
# there is more than one configuration to choose from.
# $1 - Name of VPN VM
# $2 - Name of VM in which to browse for configuration
# $ $3 - Path to the VPN client config to which one (only) should be copied, if not a zip file
vpn_import_configs ()
{
    local name="$1"
    local config_vm="$2"
    local client_conf_path="$3"

    local config_path
    local new_path

    config_path=$(_run_exec "$config_vm" "zenity --file-selection --title='VPN configuration selection' 2>/dev/null")
    if [[ -z "$config_path" ]]; then
        _info "Canceling setup: no file selected in VM $config_vm"
    else
        _verbose "Copying file $config_path to VPN VM"
        _run_exec "$config_vm" qvm-copy-to-vm "$name" "$config_path"

        # Now our configuration is the QubesIncoming directory of our VPN,
        # so we move it where the VPN will look for when starting.
        new_path="/home/user/QubesIncoming/${config_vm}/$(basename "$config_path")"

        # If the file is a zip file, unzip it in the configs directory
        # and immediately run the setup prompt to choose one.
        if [[ $new_path:t:e == "zip" ]]; then
            local configs_dir="/rw/config/vpn/configs"
            _verbose "Unzipping files into $configs_dir"
            _run_exec "$name" mkdir -p "$configs_dir"
            _run_exec "$name" unzip -j -d "$configs_dir"
            _run_exec "$name" /usr/local/bin/setup_VPN
        else
            _verbose "Copying file directly to the VPN client config path"
            _run_exec "$name" mv "$new_path" "$client_conf_path"
        fi

        _info "Done transfering VPN client configuration to VM"
    fi

    # Add the gateway to the list of existing proxies for this identity
    echo "$gw" > "${IDENTITY_DIR}/proxy_vms"
}

# vpn_next_vm_name returns a name for a new VPN VM, such as vpn-1,
# where the number is the next value after the ones found in existing
# VPN vms.
vpn_next_vm_name ()
{
    local base_name="$1"

    # First get the array of ProxyVMs names
    local proxies=( $(_identity_proxies) )

    local next_number=1

    for proxy in "${proxies[@]}"; do
        if contains "$proxy" "vpn-"; then
            next_number=$((next_number + 1))
        fi
    done

    print "$base_name-vpn-$next_number"
}

# vpn_check__vm_is_identity_proxy fails if the VM is not listed as an identity proxy.
vpn_check__vm_is_identity_proxy ()
{
    local name="$1"
    local proxies

    proxies=($(_identity_proxies))
    for proxy in "${proxies[@]}" ; do
        if [[ $proxy == "$name" ]]; then
            found=true
        fi
    done

    if [[ ! $found ]]; then
        _info "VM $name is not listed as a VPN gateway. Aborting."
        exit 1
    fi
}

# src/lib/web.sh

# Create a web browsing VM from a template
web_create_browser_vm ()
{
    local web="${1}-web"
    local web_netvm="${2-$(config_get DEFAULT_NETVM)}"
    local web_label="${3-orange}"
    local ws_template="$(config_get WHONIX_WS_TEMPLATE)"
    local template_disp="$(qvm-prefs "${ws_template}" template_for_dispvms 2>/dev/null)"

    _info "Creating web browsing VM (name: $web / netvm: $web_netvm / template: $ws_template)"
    local create_command=(qvm-create "${web}" --property netvm="$web_netvm" --label="$web_label" --template="$ws_template")

    # If the template used is a disposable_template,
    # this means we must create a named disposable VM.
    if [[ "${template_disp}" == True ]]; then
        create_command+=(--class DispVM)
    fi

    # Generate the VM
    "${create_command[@]}"
    if [[ $? -gt 0 ]]; then
        _warning "Failed to create browser VM $web" && return
    fi

    # Mark this VM as a disposable template, and tag it with our identity
    if [[ "${template_disp}" != True ]]; then
        qvm-prefs "${web}" template_for_dispvms True
    fi

    _run qvm-tags "$web" set "$IDENTITY"
    echo "${web}" > "${IDENTITY_DIR}/browser_vm"
}

# Clone a web browsing VM from an existing one
web_clone_browser_vm ()
{
    local web="${1}-web"
    local web_clone="$2"
    local netvm="${3-$(config_get DEFAULT_NETVM)}"
    local web_label="${4-orange}"

    _info "Cloning web browsing VM (name: $web / netvm: $netvm / template: $web_clone)"
    _run qvm-clone "${web_clone}" "${web}"
    if [[ $? -gt 0 ]] ; then
        _warning "Failed to clone browser VM $web" && return
    fi

    _run qvm-prefs "$web" label "$web_label"
    _run qvm-prefs "$web" netvm "$netvm"

    # Only mark this VM as disposable template when it's not one already.
    if [[ "$(qvm-prefs "${ws_template}" template_for_dispvms 2>/dev/null)" == False ]]; then
        _run qvm-prefs "${web}" template_for_dispvms True
    fi

    _run qvm-tags "$web" set "$IDENTITY"
    echo "${web}" > "${IDENTITY_DIR}/browser_vm"
}

# Create a split-browser VM from a template
web_create_split_browser_backend ()
{
    local web="${1}-split-web"
    local web_label="${2-gray}"
    local split_template="$(config_get SPLIT_BROWSER_TEMPLATE)"

    _info "Creating split-browser (name: $web / netvm: $netvm / template: $split_template)"
    qvm-create --property netvm=None --label "$web_label" --template "$split_template"

    qvm-tags "$web" set "$IDENTITY"
    echo "${web}" > "${IDENTITY_DIR}/browser_vm"
}

# Clone an existing split-browser VM, and change its dispvms
web_clone_split_browser_backend ()
{
    local web="${1}-split-web"
    local web_clone="$2"
    local web_label="${3-gray}"

    _info "Cloning split-browser VM (name: $web / netvm: $netvm / template: $web_clone)"
    qvm-clone "${web_clone}" "${web}"

    qvm-prefs "$web" label "$web_label"
    qvm-prefs "$web" netvm None

    qvm-tags "$web" set "$IDENTITY"
}

# create_bookmark_system_file writes and encrypts a file to store all-users bookmarks.
create_bookmark_system_file ()
{
    local filename="bookmarks.tsv"

    # A hush device should be mounted.

    # If the file exists, return

    # Ask for a password to use, or generate a random seed to use for the encryption.

    # Get an encrypted name for the file.

    # And create it.
}

# create_bookmark_system_file writes and encrypts a file to store per-user bookmarks.
web_create_identity_bookmarks ()
{
    local filename="$(_encrypt_filename "bookmarks.tsv")"
    bookmarks_path="/home/user/.tomb/mgmt/${filename}"
    _run_exec "$VAULT_VM" "touch ${bookmarks_path}"
}

# create_bookmark_system_file writes and encrypts a file for blacklisted links.
create_links_blacklist_file ()
{
    echo
}

# bookmark_system_file_exists returns 0 if the file exists, or 1.
bookmark_system_file_exists ()
{
    echo
    # _run_exec "$VAULT" "ls /home/user/.graveyard/$encrypted_identity"
}

# bookmark_display_command returns a command string
# to use as the dmenu displayer of a bookmarks file.
bookmark_display_command ()
{
    # This command will not work if qubes-split-browser is not installed in the split-browser VM
    local window_focus_command='_NET_WM_NAME="Split Browser" x11-unoverride-redirect stdbuf -oL'

    if [[ -n "$(config_get BOOKMARKS_DMENU_COMMAND)" ]]; then
        echo "${window_focus_command} $(config_get BOOKMARKS_DMENU_COMMAND)"
    else
        echo "${window_focus_command} dmenu -i -l 20 -b -p 'RISKS Bookmark'"
    fi
}

# _web_bookmarks_empty returns 0 if no bookmark
# file exists in split-browser or if it is empty.
_web_bookmarks_empty ()
{
    local split_command contents
    split_command=( qvm-run --pass-io "$(config_get SPLIT_BROWSER)" "cat .local/share/split-browser/bookmarks.tsv" )
    if ! "${split_command[@]}" &>/dev/null; then
        return 0
    fi

    contents="$("${split_command[@]}")"
    if [[ -z "${contents}" ]]; then
        return 0
    fi

    return 1
}

# web_set_identity_split_browser updates the default disposable VM
# used by the split browser backend to use the active identity's one.
web_set_identity_split_browser ()
{
    local browser_vm
    browser_vm=$(cat "${IDENTITY_DIR}/browser_vm" 2>/dev/null)

    if [[ -n "${browser_vm}" ]]; then
        _info "Setting identity browser VM with split-browser"
        qvm-prefs "$(config_get SPLIT_BROWSER)" default_dispvm "${browser_vm}"
    fi
}

# web_unset_identity_split_browser removes the dispvm setting of the
# tor split-browser backend if it is set to the identity browser VM.
web_unset_identity_split_browser ()
{
    local browser_vm
    browser_vm=$(cat "${IDENTITY_DIR}/browser_vm" 2>/dev/null)

    if [[ -z "${browser_vm}" ]]; then
        return
    fi

    if [[ "$(qvm-prefs "$(config_get SPLIT_BROWSER)" default_dispvm)" == "${browser_vm}" ]]; then
        qvm-prefs "$(config_get SPLIT_BROWSER)" default_dispvm ''
    fi
}

# web_select_identity_bookmark prompts the user with bookmarks,
# and returns the URL extracted from the selection.
web_select_identity_bookmark ()
{
    local bookmarks_command result

    # bookmark_prompt=( $(bookmark_display_command) )
    bookmarks_command='export SB_CMD_INPUT=bookmark; touch $SB_CMD_INPUT; split-browser-bookmark get'
    qvm-run --pass-io "${vm}" "${bookmarks_command}"
    result="$(qvm-run --pass-io "${vm}" cat bookmark)"
    print "$result" | awk '{print $2}'
}

# web_pop_identity_bookmark prompts the user with bookmarks, returns the URL
# extracted from the selection and deletes the line in the file.
# Returns the complete bookmark entry.
web_pop_identity_bookmark ()
{
    local bookmarks_command result bookmark_line vm
    bookmark_file=".local/share/split-browser/bookmarks.tsv"
    vm="$(config_get SPLIT_BROWSER)"

    # Get the URL
    bookmarks_command='export SB_CMD_INPUT=bookmark; touch $SB_CMD_INPUT; split-browser-bookmark get'
    qvm-run --pass-io "${vm}" "${bookmarks_command}"
    result=$( qvm-run --pass-io "${vm}" cat bookmark | awk '{print $2}')
    qvm-run --pass-io "${vm}" "rm bookmark"

    # Get the entire line, with the title and timestamp.
    bookmark_line="$(qvm-run --pass-io "${vm}" "cat ${bookmark_file}")"
    line="$(echo "${bookmark_line}" | grep "${result}")"

    # Abort if the user did not select anything
    [[ -z "${result}" ]] && return

    # Remove the line from the file.
    remove_command="sed -i '\#${result}#d' .local/share/split-browser/bookmarks.tsv"
    qvm-run --pass-io "${vm}" "${remove_command}"

    print "${line}"
}

# get_browser_vm_from requires a VM name to be passed as argument.
# If this VM is a disposable based on the identity's browser VM,
# the argument is returned, otherwise the identity's browser VM.
get_browser_vm_from ()
{
    echo
}

# :command.command_functions

# :command.function
risk_config_set_command() {
  # src/config_set_command.sh

  local key value

  key="${args['key']}"
  value="${args['value']}"

  config_set "$key" "$value"

}

# :command.function
risk_config_get_command() {
  # src/config_get_command.sh

  local key

  key="${args['key']}"

  config_get "$key"

}

# :command.function
risk_config_unset_command() {
  # src/config_unset_command.sh

  local key

  key="${args['key']}"

  config_set "$key" ""

}

# :command.function
risk_config_list_command() {
  # src/config_list_command.sh
  config_show

}

# :command.function
risk_config_keys_command() {
  # src/config_keys_command.sh
  config_keys

}

# :command.function
risk_hush_attach_command() {
  # src/hush_attach_command.sh

  local block vm
  local error_invalid_vm error_device
  local must_mount

  block="${args['device']-$(config_get SDCARD_BLOCK)}"
  vm="${args['vault_vm']-$(config_get VAULT_VM)}"

  # If the validations were not performed because
  # we use a default environment variable for the
  # vault VM, perform them again here.
  error_invalid_vm=$(validate_valid_vaultvm "$vm")
  if [[ -n "$error_invalid_vm" ]]; then
      _failure "$error_invalid_vm"
  fi

  # Do the same for the hush device
  error_device=$(validate_device "$block")
  if [[ -n "$error_device" ]]; then
      _failure "$error_device"
  fi

  # is the vm running?
  qvm-ls | grep Running | awk {'print $1'} | grep '^'"${vm}"'$' &> /dev/null
  if [ "$?" != "0" ]; then
      _verbose "Starting VM $vm"
      qvm-start "${vm}"
  	sleep 5
  fi

  # finally attach the sdcard encrypted partition to the qube
  qvm-block attach "${vm}" "${block}"
  if [[ $? -eq 0 ]]; then
  	_success "Block ${block} has been attached to ${vm}"
  else
  	_failure "Block ${block} can not be attached to ${vm}"
  fi

  # If user wants to mount it now, do it
  if [[ ${args['--mount']} -eq 1 ]]; then
      must_mount=1
  elif [[ "$(config_get AUTO_MOUNT_HUSH)" == True ]]; then
      must_mount=1
  elif [[ "$(config_get AUTO_MOUNT_HUSH)" == true ]]; then
      must_mount=1
  elif [[ "$(config_get AUTO_MOUNT_HUSH)" == yes ]]; then
      must_mount=1
  elif [[ "$(config_get AUTO_MOUNT_HUSH)" == 1 ]]; then
      must_mount=1
  fi

  if [[ "${must_mount}" -eq 1 ]]; then
      _info "Mounting hush device"
      _run_qube_term "$vm" risks hush mount
  fi

}

# :command.function
risk_hush_detach_command() {
  # src/hush_detach_command.sh

  local block vm

  block="${args['device']-$(config_get SDCARD_BLOCK)}"
  vm="${args['vault_vm']-$(config_get VAULT_VM)}"

  # First unmount the hush device in vault
  _info "Unmounting hush device before detaching"
  _run_qube "$vm" risks hush umount
  _catch "Failed to unmount hush device ($block)"

  # detach the sdcard encrypted partition to the qube
  if qvm-block detach "${vm}" "${block}" &>/dev/null ; then
  	_success "Block ${block} has been detached from ${vm}"
  else
  	_failure "Block ${block} can not be detached from ${vm}"
  fi

}

# :command.function
risk_backup_attach_command() {
  # src/backup_attach_command.sh

  local block vm

  block="${args['device']-$(config_get BACKUP_BLOCK)}"
  vm="${args['vault_vm']-$(config_get VAULT_VM)}"

  local error_invalid_vm error_device

  # If the validations were not performed because
  # we use a default environment variable for the
  # vault VM, perform them again here.
  error_invalid_vm=$(validate_vm_exists "$vm")
  if [[ -n "$error_invalid_vm" ]]; then
      _failure "$error_invalid_vm"
  fi

  # Do the same for the hush device
  error_device=$(validate_device "$block")
  if [[ -n "$error_device" ]]; then
      _failure "$error_device"
  fi

  # is the vm running?
  qvm-ls | grep Running | awk {'print $1'} | grep '^'"${vm}"'$' &> /dev/null
  if [ "$?" != "0" ]; then
      _verbose "Starting VM $vm"
      qvm-start "${vm}"
  	sleep 15
  fi

  # finally attach the sdcard encrypted partition to the qube
  qvm-block attach "${vm}" "${block}"
  if [[ $? -eq 0 ]]; then
  	_success "Block ${block} has been attached to ${vm}"
  else
  	_success "Block ${block} can not be attached to ${vm}"
  fi

}

# :command.function
risk_backup_detach_command() {
  # src/backup_detach_command.sh
  local block vm

  block="${args['device']:-$(config_get BACKUP_BLOCK)}"
  vm="${args['vault_vm']-$(config_get VAULT_VM)}"

  # Always umount first
  _info "Locking/unmounting backup device before detaching"
  _run_qube "$vm" risks backup umount
  _catch "Failed to unmount backup device ($block)"

  # detach the backup device
  if qvm-block detach "${vm}" "${block}" ; then
  	_success "Block ${block} has been detached from to ${vm}"
  else
  	_failure "Block ${block} can not be detached from ${vm}"
  fi

}

# :command.function
risk_identity_create_command() {
  # src/identity_create_command.sh

  # Variables setup ==========================================================

  # Variables populated from command-line args/flags
  name="${args['name']}"
  name="$(_get_name "${name}")"
  identity="${name// /_}"
  expiry="$(_get_expiry "${args['expiry_date']}")"
  email="$(_get_mail "${name}" "${args['email']}")"
  pendrive="${args['--backup']}" # Backup is optional

  # Other variables
  local vm_name           # Default prefix to use for newly created vm (eg. 'joe' => joe-vpn, joe-web)
  local label             # Default label color to use for all VMs, varies if not specified
  local other_args        # Other args/flags to pass to vault identity create command (backup/burner, etc)
  local gw_netvm          # NetVM for the tor gateway
  local web_netvm         # NetVM for the Web browser VM
  local clone             # A variable that might be overritten several times, used to assign a VM to clone.

  # Propagate the identity and its settings (in the script only)
  identity_set "${identity}"

  # Identity checks and basic setup ==========================================

  # Check no active identity is here,
  if _identity_active ; then
      _failure "Another identity ($IDENTITY) is active. Close/slam/stop it and rerun this command"
  fi

  # or that the one we want to create does not exists already
  if identity_check_exists "$IDENTITY" ; then
      _failure "Identity $IDENTITY already exists"
  fi

  # We're good to go
  _info "Creating identity $IDENTITY and infrastructure"

  # Make a directory for this identity, and store the associated VM name
  [[ -e ${IDENTITY_DIR} ]] || mkdir -p "$IDENTITY_DIR"

  # If the user wants to use a different vm_name for the VMs
  vm_name="${args['--prefix']-$IDENTITY}"
  echo "$vm_name" > "${IDENTITY_DIR}/vm_name"
  _info "Using vm_name ${fg_bold[green]}'$name'${reset_color} as VM base name"

  label="${args['--label']}"
  echo "$vm_name" > "${IDENTITY_DIR}/vm_label"
  _info "Using label ${fg_bold[green]}'$label'${reset_color} as VM default label"

  # Prepare the root NetVM for this identity
  config_get DEFAULT_NETVM > "${IDENTITY_DIR}/net_vm"

  # Create identity in vault =================================================

  # Simply pass the arguments to the vault
  _in_section "identity" 8 && _info "Creating identity in vault"

  if [[ -n "$pendrive" ]]; then
      other_args=(--backup "$pendrive")
  fi
  if [[ "${args['--burner']}" -eq 1 ]]; then
      other_args+=( --burner )
  fi

  # Create it
  _run_qube_term "$VAULT_VM" risks identity create "$name" "$email" "$expiry" "${other_args[@]}"
  _catch "Failed to create identity in vault"

  # And open it, in case the last command backed up the identity, which closed it.
  _run_qube_term "$VAULT_VM" risks identity open "$name"
  _catch "Failed to open identity in vault"

  # If the user only wanted to create the identity in the vault, exit.
  if [[ ${args['--vault-only']} -eq 1 ]] ; then
      _success "Successfully created identity $IDENTITY"
      _info "Skipping infrastructure setup" && exit
  fi

  # Network VMs ==============================================================
  _in_section "network" && _info "Creating network VMs:"
  gw_netvm="$(cat "${IDENTITY_DIR}/net_vm")"

  # 1 - Tor gateway, if not explicitly disabled
  if [[ ${args['--no-gw']} -eq 0 ]]; then
      if [[ -n ${args['--clone-gw-from']} ]]; then
          clone="${args['--clone-gw-from']}"
          tor_gateway_clone "$vm_name" "$clone" "$gw_netvm" "$label"
      else
          tor_gateway_create "$vm_name" "$gw_netvm" "$label"
      fi
  else
      _info "Skipping TOR gateway"
  fi

  # Browser VMs ==============================================================
  _in_section "web" && _info "Creating browsing VMs:"
  web_netvm="$(cat "${IDENTITY_DIR}/net_vm")"

  # Browser VMs are disposable, but we make a template for this identity,
  # since we might  either modify stuff in there, and we need them at least
  # to have a different network route.
  if [[ -n ${args['--clone-web-from']} ]]; then
      clone="${args['--clone-web-from']}"
      web_clone_browser_vm "$vm_name" "$clone" "$web_netvm" "$label"
  else
      web_create_browser_vm "$vm_name" "$web_netvm" "$label"
  fi

  # Per-identity bookmarks file in vault management tomb.
  web_create_identity_bookmarks

  _success "Successfully initialized infrastructure for identity $IDENTITY"

}

# :command.function
risk_identity_equip_command() {
  # src/identity_equip_command.sh

  local name="${args['identity']}"

  # Other variables
  local vm_name           # Default prefix to use for newly created vm (eg. 'joe' => joe-vpn, joe-web)
  local label             # Default label color to use for all VMs, varies if not specified
  local gw_netvm          # NetVM for the tor gateway
  local web_netvm         # NetVM for the Web browser VM
  local clone             # A variable that might be overritten several times, used to assign a VM to clone.

  # Propagate the identity and its settings (in the script only)
  identity_set "${args['identity']}"

  # Identity checks and basic setup ==========================================

  identity_check_exists "$IDENTITY"

  _in_section "identity" 8 && _info "Creating infrastructure for identity $IDENTITY"

  # Make a directory for this identity, and store the associated VM name
  [[ -e ${IDENTITY_DIR} ]] || mkdir -p "$IDENTITY_DIR"

  # If the user wants to use a different vm_name for the VMs
  vm_name="${args['--prefix']-$IDENTITY}"
  _info "Using '$name' as VM prefix"
  echo "$vm_name" > "${IDENTITY_DIR}/vm_name"

  label="${args['--label']-orange}"
  _info "Using label '$label' as VM default label"
  echo "$vm_name" > "${IDENTITY_DIR}/vm_label"

  # Prepare the root NetVM for this identity
  config_get DEFAULT_NETVM > "${IDENTITY_DIR}/net_vm"

  # Network VMs ==============================================================
  _in_section "network" && _info "Creating network VMs"
  gw_netvm="$(cat "${IDENTITY_DIR}/net_vm")"

  # 1 - Tor gateway, if not explicitly disabled
  if [[ ${args['--no-gw']} -eq 0 ]]; then
      if [[ -n ${args['--clone-gw-from']} ]]; then
          clone="${args['--clone-gw-from']}"
          tor_gateway_clone "$vm_name" "$clone" "$gw_netvm" "$label"
      else
          tor_gateway_create "$vm_name" "$gw_netvm" "$label"
      fi
  else
      _info "Skipping TOR gateway"
  fi

  # Browser VMs ==============================================================
  _in_section "web" && _info "Creating browsing VMs"
  web_netvm="$(cat "${IDENTITY_DIR}/net_vm")"

  # Browser VMs are disposable, but we make a template for this identity,
  # since we might  either modify stuff in there, and we need them at least
  # to have a different network route.
  if [[ -n ${args['--clone-web-from']} ]]; then
      clone="${args['--clone-web-from']}"
      web_clone_browser_vm "$vm_name" "$clone" "$web_netvm" "$label"
  else
      web_create_browser_vm "$vm_name" "$web_netvm" "$label"
  fi

  # Per-identity bookmarks file in vault management tomb.
  web_create_identity_bookmarks

  _success "Successfully initialized infrastructure for identity $IDENTITY"

}

# :command.function
risk_identity_delete_command() {
  # src/identity_delete_command.sh

  local delete_vault_cmd

  # First check the identity is valid
  identity_set "${args['identity']}"
  identity_check_exists

  # Check access to hush device in vault
  sdcard_block="$(config_get SDCARD_BLOCK)"
  check_is_device_attached "${sdcard_block}" "${VAULT_VM}"

  # Close the identity and all its running VMs
  risk_identity_stop_command

  _info "Deleting identity VMs"
  vm_delete_identity

  _info "Deleting identity in vault"
  delete_vault_cmd=( risks identity delete "${IDENTITY}" )

  # If a backup medium is mounted and backup
  # removal is asked, add the corresponding flags.
  if device_backup_mounted_on "${VAULT_VM}"; then
      if [[ "${args['--backup']}" -eq 1 ]]; then
          delete_vault_cmd+=( --backup )
      fi
  fi

  _run_qube_term "${VAULT_VM}" "${delete_vault_cmd[@]}"

  # Finally, delete its dom0 directory.
  identity_delete_directory

  _success "Successfully deleted identity $IDENTITY"

}

# :command.function
risk_identity_nake_command() {
  # src/identity_nake_command.sh

  # First check the identity is valid
  identity_set "${args['identity']}"
  identity_check_exists

  # Close the identity and all its running VMs
  _info "Stopping machines of identity $IDENTITY"
  vm_shutdown_identity

  # If the identity browser VM is used with the split-browser backend.
  web_unset_identity_split_browser

  _info "Deleting identity VMs"
  vm_delete_identity

  _success "Successfully deleted VMs of identity $IDENTITY"

}

# :command.function
risk_identity_open_command() {
  # src/identity_open_command.sh

  local sdcard_block

  sdcard_block="$(config_get SDCARD_BLOCK)"

  identity_set "${args['identity']}"

  # 1 - Check that hush is mounted on vault
  check_is_device_attached "${sdcard_block}" "${VAULT_VM}"

  # 2 - Check that no identity is currently opened
  # The second line should be empty, as opposed to being an encrypted coffin name
  identity_check_none_active "$IDENTITY"

  # 3 - Send commands to vault
  _info "Opening identity $IDENTITY"
  _run_qube_term "$VAULT_VM" risks identity open "$IDENTITY"
  _catch "Failed to open identity"

  # Set the identity browser VM, if any, as the disposable VM of split-browser backend.
  web_set_identity_split_browser

  _info "Identity $IDENTITY is active"

}

# :command.function
risk_identity_close_command() {
  # src/identity_close_command.sh

  local active_identity

  # Check we have an active identity
  active_identity="$(identity_get_active)"
  if [[ -z $active_identity ]]; then
      _info "No active identity to close"
      return
  fi

  # If the identity browser VM is used with the split-browser backend.
  web_unset_identity_split_browser

  _info "Closing identity $active_identity"

  _run_qube_term "${VAULT_VM}" risks identity close "$active_identity"
  _catch "Failed to close identity $active_identity"

  _info "Identity $active_identity is closed"

}

# :command.function
risk_identity_start_command() {
  # src/identity_start_command.sh

  local active_identity enabled_vms

  # Check the identity is valid, and open in vault if needed.
  identity_set "${args['identity']}"
  identity_check_exists

  active_identity="$(identity_get_active)"
  if [[ -n "${active_identity}" ]]; then
      if [[ "${active_identity}" != "${IDENTITY}" ]]; then
          identity_check_none_active "$IDENTITY"
      fi
      _info "Identity ${IDENTITY} already opened in vault"
  else
      risk_identity_open_command
  fi

  # Start all enabled identity machines
  read -rA enabled_vms < <(_identity_autovm_starts)
  for vm in "${enabled_vms[@]}"; do
      if [[ -z "${vm}" ]]; then
          continue
      fi
      _info "Starting VM ${vm}"
      _run vm_start "${vm}"
  done

  _success "Opened identity '$IDENTITY' and started enabled VMs"

}

# :command.function
risk_identity_stop_command() {
  # src/identity_stop_command.sh

  # Else get the active identity
  local active_identity
  active_identity=$(_identity_active_or_specified)

  _info "Stopping machines of identity $active_identity"
  vm_shutdown_identity

  _info "Closing identity in vault"
  risk_identity_close_command

}

# :command.function
risk_identity_restrict_command() {
  # src/identity_restrict_command.sh
  echo "# this file is located in 'src/identity_restrict_command.sh'"
  echo "# code for 'risk identity restrict' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risk_identity_current_command() {
  # src/identity_current_command.sh
  # Simply print the active identity in the vault
  _identity_active_or_specified

}

# :command.function
risk_slam_command() {
  # src/slam_command.sh

  # If no active identity to slam, nothing to do except umounting the hush device
  if ! _identity_active ; then
      _info "No active identity, only detaching hush and backup devices"
      risk_hush_detach_command
      risk_backup_detach_command
      exit 0
  fi

  # Else get the active identity, and propagate values to the script
  local active_identity
  active_identity=$(_identity_active_or_specified)
  identity_set "$active_identity"

  _info "Slamming infrastructure, vault and devices: identity $active_identity"

  # First shut down all client VMs
  read -rA client_vms < <(identity_client_vms)
  for vm in "${client_vms[@]}" ; do
      _info "Shutting down $vm"
      vm_shutdown "$vm"
  done

  # Do the same for proxyVMs
  read -rA proxy_vms < <(identity_proxies)
  for vm in "${proxy_vms[@]}" ; do
      _info "Shutting down $vm"
      vm_shutdown "$vm"
  done

  # Close the identity in the vault, unmount hush and backup
  risk_identity_close_command
  risk_hush_detach_command
  risk_backup_detach_command

  _success "Done"

}

# :command.function
risk_vpn_create_command() {
  # src/vpn_create_command.sh

  identity_set

  # Prepare some settings for this new VM
  local name netvm clone template label

  name="${args['vm']:-$(cat "${IDENTITY_DIR}/vm_name" 2>/dev/null)}"
  label="${args['--label']:=$(_identity_default_vm_label)}"
  netvm="$(config_or_flag "${args['--netvm']}" DEFAULT_NETVM)"
  clone="$(config_or_flag "${args['--from']}" VPN_VM)"
  template="$(config_or_flag "${args['--template']}" VPN_TEMPLATE)"

  # 0 - Last-time setup

  # If the --name flag is empty, this means we are using a default one,
  # either the configured default one, or the name of the identity.
  # In this case, we add 'vpn-1' to it (number varying).
  if [[ -z "${args['vm']}" ]]; then
      name="$(vpn_next_vm_name "$name")"
  fi

  # 1 - Creation
  #
  # We either clone the gateway from an existing one,
  # or we create it from a template.
  if [[ "${args['--clone']}" -eq 1 ]]; then
      _info "Cloning VPN gateway (from VM $clone)"
      vpn_clone "$name" "$netvm" "$label" "$clone"
  else
      _info "Creating VPN gateway (from template $template)"
      vpn_create "$name" "$netvm" "$label" "$template"
  fi

  # Tag the VM with its owner
  _run qvm-tags "$name" "$RISK_VM_OWNER_TAG" "$IDENTITY"
  _catch "Failed to tag VM with identity"

  # 2 - Setup
  #
  # Simply run the setup command, which has access to all the flags
  # it needs to do its job. Tweak the args array for this to work.
  args['vm']="$name"
  risk_vpn_setup_command

  # If the VM is marked autostart
  if [[ -n ${args['--enable']} ]]; then
      _verbose "Enabling VM to autostart"
      risk_vpn_enable_command
  fi

  _info "Done creating VPN gateway $name"

}

# :command.function
risk_vpn_setup_command() {
  # src/vpn_setup_command.sh

  identity_set

  local name config_vm client_conf_path netvm

  name="${args['vm']}"
  config_vm="${args['--config-in']}"
  client_conf_path="$(config_or_flag "" DEFAULT_VPN_CLIENT_CONF)"
  netvm="$(config_or_flag "${args['--netvm']}" DEFAULT_NETVM)"

  # There are different ways to setup a VPN VM, often mutually exclusive.

  # We might be asked to change the netVM, but this can be combined
  # with other settings to be handled below.
  if [[ -n "${netvm}" ]]; then
      _info "Getting network from $netvm"
      qvm-prefs "$name" netvm "$netvm"
  fi

  # If the user wants this VM to be the default NetVM for all clients
  # like browsers, messaging VMs, etc.
  if [[ ${args['--set-default']} -eq 1 ]]; then
      echo "$name" > "${IDENTITY_DIR}/net_vm"
      _info "Setting '$name' as default NetVM for all client machines"

      # Here, find all existing client VMs (not gateways)
      # and change their netVMs to this one.
      local clients=($(_identity_client_vms))
      for client in "${clients[@]}"; do
          if [[ -n "$client" ]]; then
              _verbose "Changing $client netVM"
              qvm-prefs "$client" netvm "$name"
          fi
      done
  fi

  # Client VPN Configurations
  if [[ "${args['--choose']}" -eq 1 ]]; then
      # If we are asked to choose an existing configuration in the VM
      _run_exec "$name" /usr/local/bin/setup_VPN
  elif [[ -n "${args['--config-in']}" ]]; then
      # Or if we are asked to browse one or more configuration files in another VM.
      vpn_import_configs "$name" "$config_vm" "$client_conf_path"
  fi

}

# :command.function
risk_vpn_start_command() {
  # src/vpn_start_command.sh

  local name="${args['vm']}"

  _info "Starting gateway $name in the background"

  # First check all the network VMs that will be started
  # actually belong to the identity, otherwise we fail.
  network_check_identity_chain "$name"

  # Then start the VM, which will start all dependent ones.
  vm_start "$name"
  _catch "Failed to start $name"

  _info "Started VM $name"

}

# :command.function
risk_vpn_stop_command() {
  # src/vpn_stop_command.sh

  local name="${args['vm']}"

  _info "Shutting down gateway $name"
  vm_shutdown "$name"
  _catch "Failed to shutdown $name"
  _info "Shut down $name"

}

# :command.function
risk_vpn_enable_command() {
  # src/vpn_enable_command.sh

  identity_set

  local name autovm_starts already_enabled

  name="${args['vm']}"

  vm_enable_autostart "$name"

}

# :command.function
risk_vpn_disable_command() {
  # src/vpn_disable_command.sh

  identity_set

  local name="${args['vm']}"

  vm_disable_autostart "$name"

}

# :command.function
risk_vpn_delete_command() {
  # src/vpn_delete_command.sh

  local name

  name="${args['vm']}"

  identity_set

  # Check that the selected VM is indeed one of the identity
  # proxy VMs, so that we don't accidentally delete another one.
  vpn_check__vm_is_identity_proxy "$name"

  # Do not even attempt to delete if the VM provides network to another VM.
  fail_vm_provides_network "$vm"

  _info "Deleting gateway VM $name"

  # If the VPN was the default NetVM for the identity,
  # update the NetVM to Whonix.
  netvm="$(_identity_default_netvm)"
  if [[ $netvm == "$name" ]]; then
      _warning "Gateway $name is the default NetVM for identity clients !"

      # Check if we have a TOR gateway
      local tor_gw=$(_identity_tor_gateway)

      if [[ -n $tor_gw ]]; then
          _info -n "Updating the default identity NetVM to $tor_gw"
          echo "$tor_gw" > "${IDENTITY_DIR}/net_vm"
      else
          _info -n "The identity has no default NetVM anymore, please set it."
      fi
  fi

  # Check if there are some existing VMs that use this gateway as NetVM,
  # and change their netVM to None: this is unpractical, especially for
  # those that might be up, but it's better than assigning a new netVM
  # despite this presenting a security risk.

  # Delete without asking to confirm
  echo "y" | _run qvm-remove "$name"
  _catch "Failed to delete (fully or partially) VM $name"

  # Remove from VMs marked autostart
  sed -i /"$name"/d "${IDENTITY_DIR}/autovm_starts"
  # And remove from proxy VMs
  sed -i /"$name"/d "${IDENTITY_DIR}/proxy_vms"

  # Finally, delete the VM,
  _run qvm-remove "$name"
  _catch "Failed to delete VM $name:"

  _info "Deleted $name"

}

# :command.function
risk_vm_add_command() {
  # src/vm_add_command.sh

  local vm vm_owner

  vm="${args['vm']}"

  identity_set

  # We need a valid identity
  identity_check_exists "$IDENTITY"

  # Check VM ownership
  vm_owner=$(_vm_owner "$vm")

  # If already belongs to an identity, ask for confirmation to update the settings.
  if [[ -n "$vm_owner" ]] && [[ "$vm_owner" != "$IDENTITY" ]]; then
      _warning "VM $vm already belongs to $vm_owner"
      printf >&2 '%s ' "Do you really want to assign a new identity ($IDENTITY) to this VM ? (YES/n)"
      read ans

      if [[ "$ans" != 'YES' ]]; then
          _info "Aborting identity change. Exiting"
          exit 0
      fi
  fi

  # Tag the VM with its owner
  _run qvm-tags "$vm" set "$IDENTITY"
  _catch "Failed to tag VM with identity"

  # Change its network VM, either with the default for the identity,
  # or with the netvm flag, which has precedence.
  if [[ "$(qvm-tags "$vm" netvm)" != 'None' ]]; then
      _info "VM is networked. Updating its network VM"
      local netvm="$(_identity_default_netvm)"

      # If the user overrode the default netVM, check that it belongs
      # to the identity, or ask confirmation.
      if [[ -n "${args['--netvm']}" ]]; then
          netvm_owner=$(_vm_owner "${args['--netvm']}")
          if [[ "$vm_owner" != "$IDENTITY" ]]; then
              _warning "Network VM $vm already belongs to $vm_owner"
              printf >&2 '%s ' "Do you really want to use this VM as netvm for $vm? (YES/n)"
              read ans

              if [[ "$ans" == 'YES' ]]; then
                  netvm="${args['--netvm']}"
              fi
          fi
      fi

      _info "Setting network VM to $netvm"
      _run qvm-tags "$vm" netvm "$netvm"
      _catch "Failed to set netvm"
  fi

  # Check if the VM provides network. If yes we naturally consider
  # it to be a gateway, and we add it to the list of proxy_vms.
  if [[ "$(qvm-tags "$vm" provides_network)" == 'True' ]]; then
      _info "VM provides network. Treating it as a gateway VM"

      # Add as a proxy VM
      echo "$vm" > "${IDENTITY_DIR}/proxy_vms"

      # If the user specified to use it as the default netvm
      if [[ ${args['--set-default']} -eq 1 ]]; then
          echo "$vm" > "${IDENTITY_DIR}/net_vm"
          _info "Setting '$vm' as default NetVM for all client machines"
      fi
  fi

  # Enable autostart if asked to
  [[ "${args['--enable']}" -eq 1 ]] && vm_enable_autostart "$vm"

  _success "Succesfully set VM $vm as belonging to identity $IDENTITY"

}

# :command.function
risk_vm_delete_command() {
  # src/vm_delete_command.sh
  local vm

  vm="${args['vm']}"

  identity_set

  # Check VM ownership
  [[ "$(_vm_owner "$vm")" != "$IDENTITY" ]] || _failure "VM $vm does not belong to $IDENTITY"

  # Do not even attempt to delete if the VM provides network to another VM.
  fail_vm_provides_network "$vm"

  # If the VM is a gateway, just call the VPN command to do the work.
  if _vm_is_identity_proxy "$vm" ; then
      risk_vpn_delete_command
      return
  fi

  # Remove from autostart enabled commands
  sed -i /"$vm"/d "${IDENTITY_DIR}/autovm_starts"

  # Finally, delete the VM,
  _run qvm-remove "$vm"
  _catch "Failed to delete VM $vm:"

}

# :command.function
risk_vm_enable_command() {
  # src/vm_enable_command.sh
  local vm

  vm="${args['vm']}"

  identity_set

  # Check VM ownership
  [[ "$(_vm_owner "$vm")" != "$IDENTITY" ]] || _failure "VM $vm does not belong to $IDENTITY"

  vm_enable_autostart "$vm"

}

# :command.function
risk_vm_disable_command() {
  # src/vm_disable_command.sh
  local vm

  vm="${args['vm']}"

  identity_set

  # Check VM ownership
  [[ "$(_vm_owner "$vm")" != "$IDENTITY" ]] || _failure "VM $vm does not belong to $IDENTITY"

  vm_disable_autostart "$vm"

}

# :command.function
risk_use_command() {
  # src/use_command.sh

  local vm arguments

  # Note that we concatenate all command arguments in a string (with *), to be passed to qvm-run
  vm="${args['vm']}"
  arguments="${other_args[@]}"

  local owner active_identity
  owner=$(_vm_owner "$vm")
  active_identity="$(_identity_active_or_specified)"

  # If the VM does not belong to any identity, then we don't have
  # to interact with any of them, and this branch is skipped.
  #
  # However if the VM does not belong the active identity, we must:
  if [[ -n "$owner" ]] && [[ $owner != "$active_identity" ]]; then
      # Close the active identity
      _info "Closing identity $active_identity"
      risk_identity_close_command

      # Open the new one
      args['identity']="$owner"
      risk_identity_open_command
  fi

  # At this point everything identity-related should be cleared and done.
  _run_exec "$vm" "${arguments[@]}"
  _catch "Failed to execute command in $vm:"

}

# :command.function
risk_url_open_command() {
  # src/url_open_command.sh
  echo "# this file is located in 'src/url_open_command.sh'"
  echo "# code for 'risk url open' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risk_url_verify_command() {
  # src/url_verify_command.sh
  echo "# this file is located in 'src/url_verify_command.sh'"
  echo "# code for 'risk url verify' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risk_url_bookmark_command() {
  # src/url_bookmark_command.sh

  local active_vm         # The VM owning the focused window
  local bookmark_entry    # Complete entry (date/url/title)
  local url               # The URL to bookmark
  local title             # The URL page title to use if/when prompting the user for input.

  identity_set ""

  url="${args['url']}"
  split_vm="$(config_get SPLIT_BROWSER)"
  active_vm="$(_vm_focused)"

  if [[ -z "${url}" ]]; then
      if _web_bookmarks_empty; then
          _info "No bookmarks file in ${split_vm}, prompting user to enter it."
          zenity_prompt="zenity --text 'URL Bookmark' --forms --add-entry='URL' --add-entry='Page Title' --separator=\$'\t'"
          result="$(qvm-run --pass-io "${active_vm}" "${zenity_prompt}")"
          url="$( echo "${result}" | cut -f 1 -d $'\t')"
          title="$( echo "${result}" | cut -f 2- -d $'\t')"
      else
          _info "No URL argument, starting dmenu with bookmarks list in ${split_vm}"
          bookmark_entry="$(web_pop_identity_bookmark)"
          url="$( echo "${bookmark_entry}" | awk '{print $2}' )"
          title="$( echo "${bookmark_entry}" | awk '{print $3}' )"
      fi
  fi

  # We either have an entry, or some information to build one, otherwise abort.
  if [[ -z "${bookmark_entry}" ]] ; then
      if [[ -z "${url}" ]]; then
          _info "No bookmark entry or URL selected or entered, aborting." && return
      fi
      bookmark_entry="$(date --rfc-3339=seconds)"$'\t'"$url"$'\t'"$title"
  fi

  _info "Transfering entry to vault bookmarks file."
  bookmarks_path="/home/user/.tomb/mgmt/$(_encrypt_filename 'bookmarks.tsv')"

  if ! qvm-run --pass-io "${VAULT_VM}" "cat ${bookmarks_path} | grep ${url}" &>/dev/null; then
  # grep -m 1 -F -- \$'\t'${url}\$'\t'"
      qvm-run --pass-io "${VAULT_VM}" "echo '${bookmark_entry}' >> ${bookmarks_path}"
  fi

}

# :command.function
risk_url_blacklist_command() {
  # src/url_blacklist_command.sh
  echo "# this file is located in 'src/url_blacklist_command.sh'"
  echo "# code for 'risk url blacklist' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risk_url_news_command() {
  # src/url_news_command.sh
  echo "# this file is located in 'src/url_news_command.sh'"
  echo "# code for 'risk url news' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risk_qubes_update_command() {
  # src/qubes_update_command.sh
  # Analyze the arguments and extract all VMs
  # corresponding to those names/groups.
  read -rA vms < <(_vm_args "${args['vms']}" "${other_args[@]}")

  # Update matching VMs.
  if [[ -n "${vms[*]}" ]]; then
      _info "Updating following VMs:"
      for template in "${vms[@]}"; do
              _info "$template"
      done

      printf -v targets '%s,' "${vms[@]}"
      _run sudo qubesctl --skip-dom0 --targets "${targets%,}" state.apply update.qubes-vm
  fi

  # Update dom0 if required
  if [[ ${args['vms']} == dom0 ]] || [[ ${other_args[(r)dom0]} == dom0 ]]; then
      _info "Updating dom0"
      sudo qubes-dom0-update
  fi

  # If torbrowser update is required, get identity browsing VM template and update
  # We need to know for which identity to update, so we need one active.
  if [[ ${args['vms']} == torbrowser ]] || [[ ${other_args[(r)torbrowser]} == torbrowser ]]; then
      identity_set

      local browser_vm browser_template
      browser_vm="$(_identity_browser_vm)"

      if [[ -n "${browser_vm}" ]]; then
          browser_template="$(_vm_root_template "${browser_vm}")"
          _info "Updating Tor browser in ${browser_template}"
          _run_qube_term "${browser_template}" sudo update-torbrowser
      fi
  fi

}

# :command.function
risk_help_command() {
  # src/help_command.sh
  command="${args[command]}"
  long_usage=yes

  if [[ -z "$command" ]]; then
    # No command argument, show the global help
    help_function=risk_usage
  else
    # Show the help for the requested command
    help_function="risk_${command}_usage"
  fi

  # Call the help function if it exists
  if [[ $(type "$help_function") ]]; then
    "$help_function"
  else
    echo "No help available for this command"
    exit 1
  fi

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        risk_usage
        exit
        ;;

      # :flag.case
      --verbose | -v)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    config)
      action="config"
      shift
      risk_config_parse_requirements "$@"
      shift $#
      ;;

    hush)
      action="hush"
      shift
      risk_hush_parse_requirements "$@"
      shift $#
      ;;

    backup)
      action="backup"
      shift
      risk_backup_parse_requirements "$@"
      shift $#
      ;;

    identity)
      action="identity"
      shift
      risk_identity_parse_requirements "$@"
      shift $#
      ;;

    slam)
      action="slam"
      shift
      risk_slam_parse_requirements "$@"
      shift $#
      ;;

    vpn)
      action="vpn"
      shift
      risk_vpn_parse_requirements "$@"
      shift $#
      ;;

    vm)
      action="vm"
      shift
      risk_vm_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      risk_use_parse_requirements "$@"
      shift $#
      ;;

    url)
      action="url"
      shift
      risk_url_parse_requirements "$@"
      shift $#
      ;;

    qubes)
      action="qubes"
      shift
      risk_qubes_parse_requirements "$@"
      shift $#
      ;;

    help)
      action="help"
      shift
      risk_help_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_config_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    set)
      action="set"
      shift
      risk_config_set_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      risk_config_get_parse_requirements "$@"
      shift $#
      ;;

    unset)
      action="unset"
      shift
      risk_config_unset_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      risk_config_list_parse_requirements "$@"
      shift $#
      ;;

    keys)
      action="keys"
      shift
      risk_config_keys_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_config_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_config_set_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_set_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config set"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        elif [[ -z ${args['value']+x} ]]; then

          args['value']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risk config set KEY VALUE\n" >&2
    exit 1
  fi
  if [[ -z ${args['value']+x} ]]; then
    printf "missing required argument: VALUE\nusage: risk config set KEY VALUE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_config_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risk config get KEY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_config_unset_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_unset_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config unset"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risk config unset KEY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_config_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_config_keys_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_keys_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config keys"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_hush_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_hush_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    attach)
      action="attach"
      shift
      risk_hush_attach_parse_requirements "$@"
      shift $#
      ;;

    detach)
      action="detach"
      shift
      risk_hush_detach_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_hush_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_hush_attach_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_hush_attach_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="hush attach"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --mount | -m)

        # :flag.case_no_arg
        args['--mount']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['device']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_device "$1") ]]; then
            printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_device "$1")" >&2
            exit 1
          fi

          args['device']=$1
          shift
        elif [[ -z ${args['vault_vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_valid_vaultvm "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")" >&2
            exit 1
          fi

          args['vault_vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_hush_detach_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_hush_detach_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="hush detach"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['device']+x} ]]; then

          args['device']=$1
          shift
        elif [[ -z ${args['vault_vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_valid_vaultvm "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")" >&2
            exit 1
          fi

          args['vault_vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_backup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_backup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    attach)
      action="attach"
      shift
      risk_backup_attach_parse_requirements "$@"
      shift $#
      ;;

    detach)
      action="detach"
      shift
      risk_backup_detach_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_backup_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_backup_attach_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_backup_attach_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="backup attach"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['device']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_device "$1") ]]; then
            printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_device "$1")" >&2
            exit 1
          fi

          args['device']=$1
          shift
        elif [[ -z ${args['vault_vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_valid_vaultvm "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")" >&2
            exit 1
          fi

          args['vault_vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_backup_detach_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_backup_detach_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="backup detach"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['device']+x} ]]; then

          args['device']=$1
          shift
        elif [[ -z ${args['vault_vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_valid_vaultvm "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")" >&2
            exit 1
          fi

          args['vault_vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_identity_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    create)
      action="create"
      shift
      risk_identity_create_parse_requirements "$@"
      shift $#
      ;;

    equip)
      action="equip"
      shift
      risk_identity_equip_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      risk_identity_delete_parse_requirements "$@"
      shift $#
      ;;

    nake)
      action="nake"
      shift
      risk_identity_nake_parse_requirements "$@"
      shift $#
      ;;

    open)
      action="open"
      shift
      risk_identity_open_parse_requirements "$@"
      shift $#
      ;;

    close)
      action="close"
      shift
      risk_identity_close_parse_requirements "$@"
      shift $#
      ;;

    start)
      action="start"
      shift
      risk_identity_start_parse_requirements "$@"
      shift $#
      ;;

    stop)
      action="stop"
      shift
      risk_identity_stop_parse_requirements "$@"
      shift $#
      ;;

    restrict)
      action="restrict"
      shift
      risk_identity_restrict_parse_requirements "$@"
      shift $#
      ;;

    current)
      action="current"
      shift
      risk_identity_current_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_identity_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_identity_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --prefix | -P)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--prefix']="$2"
          shift
          shift
        else
          printf "%s\n" "--prefix requires an argument: --prefix, -P NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --label | -L)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--label']="$2"
          shift
          shift
        else
          printf "%s\n" "--label requires an argument: --label, -L COLOR" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --backup | -b)

        # :flag.case_no_arg
        args['--backup']=1
        shift
        ;;

      # :flag.case
      --vault-only)

        # :flag.case_no_arg
        args['--vault-only']=1
        shift
        ;;

      # :flag.case
      --no-gw | -G)
        # :flag.conflicts
        if [[ -n "${args['--clone-gw-from']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--clone-gw-from" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no-gw']=1
        shift
        ;;

      # :flag.case
      --clone-gw-from)
        # :flag.conflicts
        if [[ -n "${args['--no-gw']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-gw" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--clone-gw-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-gw-from requires an argument: --clone-gw-from TOR_GW" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --clone-web-from)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--clone-web-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-web-from requires an argument: --clone-web-from WEB_VM" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --clone-split-from)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--clone-split-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-split-from requires an argument: --clone-split-from SPLIT_BROWSER_VM" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['name']+x} ]]; then

          args['name']=$1
          shift
        elif [[ -z ${args['email']+x} ]]; then

          args['email']=$1
          shift
        elif [[ -z ${args['expiry_date']+x} ]]; then

          args['expiry_date']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: risk identity create NAME EMAIL EXPIRY_DATE [OPTIONS]\n" >&2
    exit 1
  fi
  if [[ -z ${args['email']+x} ]]; then
    printf "missing required argument: EMAIL\nusage: risk identity create NAME EMAIL EXPIRY_DATE [OPTIONS]\n" >&2
    exit 1
  fi
  if [[ -z ${args['expiry_date']+x} ]]; then
    printf "missing required argument: EXPIRY_DATE\nusage: risk identity create NAME EMAIL EXPIRY_DATE [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_equip_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_equip_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity equip"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --prefix | -P)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--prefix']="$2"
          shift
          shift
        else
          printf "%s\n" "--prefix requires an argument: --prefix, -P NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --label | -L)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--label']="$2"
          shift
          shift
        else
          printf "%s\n" "--label requires an argument: --label, -L COLOR" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no-gw | -G)
        # :flag.conflicts
        if [[ -n "${args['--clone-gw-from']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--clone-gw-from" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no-gw']=1
        shift
        ;;

      # :flag.case
      --clone-gw-from)
        # :flag.conflicts
        if [[ -n "${args['--no-gw']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-gw" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--clone-gw-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-gw-from requires an argument: --clone-gw-from TOR_GW" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --clone-web-from)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--clone-web-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-web-from requires an argument: --clone-web-from WEB_VM" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --clone-split-from)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--clone-split-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-split-from requires an argument: --clone-split-from SPLIT_BROWSER_VM" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity equip IDENTITY [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --backup | -b)

        # :flag.case_no_arg
        args['--backup']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity delete IDENTITY [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_nake_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_nake_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity nake"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity nake IDENTITY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_open_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_open_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity open"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity open IDENTITY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_close_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_close_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity close"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_identity_start_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_start_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity start"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity start IDENTITY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_stop_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_stop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity stop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_identity_restrict_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_restrict_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity restrict"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_identity_current_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_current_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity current"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_slam_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_slam_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="slam"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_vpn_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    create)
      action="create"
      shift
      risk_vpn_create_parse_requirements "$@"
      shift $#
      ;;

    setup)
      action="setup"
      shift
      risk_vpn_setup_parse_requirements "$@"
      shift $#
      ;;

    start)
      action="start"
      shift
      risk_vpn_start_parse_requirements "$@"
      shift $#
      ;;

    stop)
      action="stop"
      shift
      risk_vpn_stop_parse_requirements "$@"
      shift $#
      ;;

    enable)
      action="enable"
      shift
      risk_vpn_enable_parse_requirements "$@"
      shift $#
      ;;

    disable)
      action="disable"
      shift
      risk_vpn_disable_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      risk_vpn_delete_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_vpn_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_vpn_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --name | -N)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -N NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --label | -L)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--label']="$2"
          shift
          shift
        else
          printf "%s\n" "--label requires an argument: --label, -L COLOR" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --enable | -E)

        # :flag.case_no_arg
        args['--enable']=1
        shift
        ;;

      # :flag.case
      --template | -T)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--template']="$2"
          shift
          shift
        else
          printf "%s\n" "--template requires an argument: --template, -T TEMPLATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --clone | -c)

        # :flag.case_no_arg
        args['--clone']=1
        shift
        ;;

      # :flag.case
      --from | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--from']="$2"
          shift
          shift
        else
          printf "%s\n" "--from requires an argument: --from, -f VPN_GW" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --set-default)

        # :flag.case_no_arg
        args['--set-default']=1
        shift
        ;;

      # :flag.case
      --config-in)
        # :flag.conflicts
        if [[ -n "${args['--choose']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--choose" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--config-in']="$2"
          shift
          shift
        else
          printf "%s\n" "--config-in requires an argument: --config-in CONFIG_VM" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --netvm | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--netvm']="$2"
          shift
          shift
        else
          printf "%s\n" "--netvm requires an argument: --netvm, -n VM" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_vpn_setup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_setup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn setup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --config-in)
        # :flag.conflicts
        if [[ -n "${args['--choose']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--choose" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--config-in']="$2"
          shift
          shift
        else
          printf "%s\n" "--config-in requires an argument: --config-in CONFIG_VM" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --set-default)

        # :flag.case_no_arg
        args['--set-default']=1
        shift
        ;;

      # :flag.case
      --netvm | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--netvm']="$2"
          shift
          shift
        else
          printf "%s\n" "--netvm requires an argument: --netvm, -n VM" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --choose)
        # :flag.conflicts
        if [[ -n "${args['--config-in']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--config-in" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--choose']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn setup VM [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_start_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_start_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn start"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn start VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_stop_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_stop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn stop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn stop VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_enable_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_enable_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn enable"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn enable VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_disable_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_disable_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn disable"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn disable VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn delete VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vm_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    add)
      action="add"
      shift
      risk_vm_add_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      risk_vm_delete_parse_requirements "$@"
      shift $#
      ;;

    enable)
      action="enable"
      shift
      risk_vm_enable_parse_requirements "$@"
      shift $#
      ;;

    disable)
      action="disable"
      shift
      risk_vm_disable_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_vm_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_vm_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vm_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vm add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --netvm | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--netvm']="$2"
          shift
          shift
        else
          printf "%s\n" "--netvm requires an argument: --netvm, -n VM" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --set-default)

        # :flag.case_no_arg
        args['--set-default']=1
        shift
        ;;

      # :flag.case
      --enable | -E)

        # :flag.case_no_arg
        args['--enable']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vm add VM [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vm_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vm_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vm delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vm delete VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vm_enable_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vm_enable_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vm enable"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vm enable VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vm_disable_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vm_disable_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vm disable"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vm disable VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          other_args+=("$1")
          shift
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk use VM [...]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_url_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_url_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    open)
      action="open"
      shift
      risk_url_open_parse_requirements "$@"
      shift $#
      ;;

    verify)
      action="verify"
      shift
      risk_url_verify_parse_requirements "$@"
      shift $#
      ;;

    bookmark)
      action="bookmark"
      shift
      risk_url_bookmark_parse_requirements "$@"
      shift $#
      ;;

    blacklist)
      action="blacklist"
      shift
      risk_url_blacklist_parse_requirements "$@"
      shift $#
      ;;

    news)
      action="news"
      shift
      risk_url_news_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_url_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_url_open_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_url_open_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="url open"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['url']+x} ]]; then

          args['url']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_url_verify_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_url_verify_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="url verify"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['url']+x} ]]; then

          args['url']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_url_bookmark_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_url_bookmark_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="url bookmark"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user | -u)

        # :flag.case_no_arg
        args['--user']=1
        shift
        ;;

      # :flag.case
      --system | -s)

        # :flag.case_no_arg
        args['--system']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['url']+x} ]]; then

          args['url']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_url_blacklist_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_url_blacklist_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="url blacklist"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['url']+x} ]]; then

          args['url']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_url_news_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_url_news_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="url news"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['url']+x} ]]; then

          args['url']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_qubes_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_qubes_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    update)
      action="update"
      shift
      risk_qubes_update_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_qubes_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_qubes_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_qubes_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="qubes update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --identity | -I)

        # :flag.case_no_arg
        args['--identity']=1
        shift
        ;;

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        if [[ -z ${args['vms']+x} ]]; then

          args['vms']=$1
          shift
        else
          other_args+=("$1")
          shift
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_help_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_help_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="help"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['command']+x} ]]; then

          args['command']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -euo pipefail

  # src/initialize.sh

  # Connected terminal
  typeset -H _TTY
  GPG_TTY=$(tty)  # Needed for GPG operations
  export GPG_TTY

  # Remove verbose errors when * don't yield any match in ZSH
  setopt +o nomatch

  # The generated script makes use of BASH_REMATCH, set compat for ZSH
  setopt BASH_REMATCH


  # Don't run as root
  if [[ $EUID -eq 0 ]]; then
     echo "This script must be run as user"
     exit 2
  fi

  # Use colors unless told not to
  { ! option_is_set --no-color } && { autoload -Uz colors && colors }

  # Configuration file -------------------------------------------------------------------------------
  #
  # Working state and configurations
  typeset -rg RISK_DIR="${HOME}/.risk"                         # Directory where risk stores its state
  typeset -rg RISK_IDENTITIES_DIR="${RISK_DIR}/identities"     # Idendities store their settings here
  typeset -rg RISK_IDENTITY_FILE="${RISK_DIR}/.identity"

  # Create the risk directory if needed
  [[ -e $RISK_DIR ]] || { mkdir -p $RISK_DIR && _info "Creating RISK directory in $RISK_DIR" }
  [[ -e $RISK_IDENTITIES_DIR ]] || mkdir -p $RISK_IDENTITIES_DIR

  # Write the default configuration if it does not exist.
  config_init

  # Default filesystem settings from configuration file ----------------------------------------------
  typeset -g VAULT_VM=$(config_get VAULT_VM)
  typeset -g DEFAULT_NETVM=$(config_get DEFAULT_NETVM)

  typeset -gr DOM0_TERMINAL=$(config_get DOM0_TERMINAL)
  typeset -gr VM_TERMINAL=$(config_get VM_TERMINAL)

  # Working state variables --------------------------------------------------------------------------
  typeset -r IDENTITY            # The identity to use for this single risk execution
  typeset -g IDENTITY_DIR        # The directory where to store identity settings

}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"
  initialize

  case "$action" in
    "config")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_config_usage
      else
        risk_config_command
      fi
      ;;

    "config set")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_config_set_usage
      else
        risk_config_set_command
      fi
      ;;

    "config get")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_config_get_usage
      else
        risk_config_get_command
      fi
      ;;

    "config unset")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_config_unset_usage
      else
        risk_config_unset_command
      fi
      ;;

    "config list")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_config_list_usage
      else
        risk_config_list_command
      fi
      ;;

    "config keys")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_config_keys_usage
      else
        risk_config_keys_command
      fi
      ;;

    "hush")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_hush_usage
      else
        risk_hush_command
      fi
      ;;

    "hush attach")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_hush_attach_usage
      else
        risk_hush_attach_command
      fi
      ;;

    "hush detach")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_hush_detach_usage
      else
        risk_hush_detach_command
      fi
      ;;

    "backup")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_backup_usage
      else
        risk_backup_command
      fi
      ;;

    "backup attach")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_backup_attach_usage
      else
        risk_backup_attach_command
      fi
      ;;

    "backup detach")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_backup_detach_usage
      else
        risk_backup_detach_command
      fi
      ;;

    "identity")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_usage
      else
        risk_identity_command
      fi
      ;;

    "identity create")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_create_usage
      else
        risk_identity_create_command
      fi
      ;;

    "identity equip")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_equip_usage
      else
        risk_identity_equip_command
      fi
      ;;

    "identity delete")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_delete_usage
      else
        risk_identity_delete_command
      fi
      ;;

    "identity nake")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_nake_usage
      else
        risk_identity_nake_command
      fi
      ;;

    "identity open")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_open_usage
      else
        risk_identity_open_command
      fi
      ;;

    "identity close")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_close_usage
      else
        risk_identity_close_command
      fi
      ;;

    "identity start")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_start_usage
      else
        risk_identity_start_command
      fi
      ;;

    "identity stop")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_stop_usage
      else
        risk_identity_stop_command
      fi
      ;;

    "identity restrict")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_restrict_usage
      else
        risk_identity_restrict_command
      fi
      ;;

    "identity current")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_current_usage
      else
        risk_identity_current_command
      fi
      ;;

    "slam")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_slam_usage
      else
        risk_slam_command
      fi
      ;;

    "vpn")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_usage
      else
        risk_vpn_command
      fi
      ;;

    "vpn create")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_create_usage
      else
        risk_vpn_create_command
      fi
      ;;

    "vpn setup")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_setup_usage
      else
        risk_vpn_setup_command
      fi
      ;;

    "vpn start")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_start_usage
      else
        risk_vpn_start_command
      fi
      ;;

    "vpn stop")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_stop_usage
      else
        risk_vpn_stop_command
      fi
      ;;

    "vpn enable")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_enable_usage
      else
        risk_vpn_enable_command
      fi
      ;;

    "vpn disable")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_disable_usage
      else
        risk_vpn_disable_command
      fi
      ;;

    "vpn delete")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_delete_usage
      else
        risk_vpn_delete_command
      fi
      ;;

    "vm")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vm_usage
      else
        risk_vm_command
      fi
      ;;

    "vm add")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vm_add_usage
      else
        risk_vm_add_command
      fi
      ;;

    "vm delete")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vm_delete_usage
      else
        risk_vm_delete_command
      fi
      ;;

    "vm enable")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vm_enable_usage
      else
        risk_vm_enable_command
      fi
      ;;

    "vm disable")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vm_disable_usage
      else
        risk_vm_disable_command
      fi
      ;;

    "use")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_use_usage
      else
        risk_use_command
      fi
      ;;

    "url")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_url_usage
      else
        risk_url_command
      fi
      ;;

    "url open")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_url_open_usage
      else
        risk_url_open_command
      fi
      ;;

    "url verify")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_url_verify_usage
      else
        risk_url_verify_command
      fi
      ;;

    "url bookmark")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_url_bookmark_usage
      else
        risk_url_bookmark_command
      fi
      ;;

    "url blacklist")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_url_blacklist_usage
      else
        risk_url_blacklist_command
      fi
      ;;

    "url news")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_url_news_usage
      else
        risk_url_news_command
      fi
      ;;

    "qubes")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_qubes_usage
      else
        risk_qubes_command
      fi
      ;;

    "qubes update")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_qubes_update_usage
      else
        risk_qubes_update_command
      fi
      ;;

    "help")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_help_usage
      else
        risk_help_command
      fi
      ;;

  esac
}

run "$@"
