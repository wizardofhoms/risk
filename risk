#!/usr/bin/env zsh

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
risk_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk - RISKS Dom0 management application\n"
    echo

  else
    printf "risk - RISKS Dom0 management application\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk [OPTIONS] COMMAND\n"
  printf "  risk [COMMAND] --help | -h\n"
  printf "  risk --version\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Manage the risk global configuration\n" "$(red "config")  "
  printf "  %s   Manage the hush partition attach/detach from qubes\n" "$(red "hush")    "
  printf "  %s   Manage backup devices attach/detach from qubes\n" "$(red "backup")  "
  printf "  %s   Create, manage and use identities and/or use their machines\n" "$(red "identity")"
  printf "  %s   Close identity, infrastructure and detach hush/backup at once\n" "$(red "slam")    "
  printf "  %s   Create, configure, manage and use VPN gateways for an identity.\n" "$(red "vpn")     "
  printf "  %s   Manage generic VMs (identity settings, enable/disable, etc)\n" "$(red "vm")      "
  printf "  %s   Execute a command in a VM belong to an identity.\n" "$(red "use")     "
  printf "  %s   Strutured set of commands for managing Qubes in general\n" "$(red "qubes")   "
  printf "  %s   Show help about a command\n" "$(red "help")    "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
risk_config_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config - Manage the risk global configuration\n"
    echo

  else
    printf "risk config - Manage the risk global configuration\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config COMMAND\n"
  printf "  risk config [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Set a configuration variable to a value\n" "$(red "set")  "
  printf "  %s   Print the value of a configuration variable\n" "$(red "get")  "
  printf "  %s   Delete the value of a configuration variable\n" "$(red "unset")"
  printf "  %s   List all configuration variables\n" "$(red "list") "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_config_set_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config set - Set a configuration variable to a value\n"
    echo

  else
    printf "risk config set - Set a configuration variable to a value\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config set KEY VALUE\n"
  printf "  risk config set --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to set\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "VALUE")"
    printf "    Value to assign to the key\n"
    echo

  fi
}

# :command.usage
risk_config_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config get - Print the value of a configuration variable\n"
    echo

  else
    printf "risk config get - Print the value of a configuration variable\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config get KEY\n"
  printf "  risk config get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to show\n"
    echo

  fi
}

# :command.usage
risk_config_unset_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config unset - Delete the value of a configuration variable\n"
    echo

  else
    printf "risk config unset - Delete the value of a configuration variable\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config unset KEY\n"
  printf "  risk config unset --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to delete/unset\n"
    echo

  fi
}

# :command.usage
risk_config_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config list - List all configuration variables\n"
    echo

  else
    printf "risk config list - List all configuration variables\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config list\n"
  printf "  risk config list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_config_keys_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config keys - List all configuration variables as an array (for completions)\n"
    echo

  else
    printf "risk config keys - List all configuration variables as an array (for completions)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk config keys\n"
  printf "  risk config keys --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_hush_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk hush - Manage the hush partition attach/detach from qubes\n"
    echo

  else
    printf "risk hush - Manage the hush partition attach/detach from qubes\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk hush COMMAND\n"
  printf "  risk hush [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Attach the hush device to a qube. Accepts optional args to override default hush/vault\n" "$(red "attach")"
  printf "  %s   Detach the hush device from its current qube, making sure it's not in a read-write state\n" "$(red "detach")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_hush_attach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk hush attach - Attach the hush device to a qube. Accepts optional args to override default hush/vault\n"
    echo

  else
    printf "risk hush attach - Attach the hush device to a qube. Accepts optional args to override default hush/vault\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk hush attach [DEVICE] [VAULT_VM] [OPTIONS]\n"
  printf "  risk hush attach --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--mount, -m"
    printf "    Mount the hush device in the vault (prompts for password)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "DEVICE")"
    printf "    (optional) qubes path to device to use as hush (defaults to SDCARD_BLOCK)\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "VAULT_VM")"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

# :command.usage
risk_hush_detach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk hush detach - Detach the hush device from its current qube, making sure it's not in a read-write state\n"
    echo

  else
    printf "risk hush detach - Detach the hush device from its current qube, making sure it's not in a read-write state\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk hush detach [DEVICE] [VAULT_VM]\n"
  printf "  risk hush detach --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "DEVICE")"
    printf "    (optional) qubes path to device to use as backup (defaults to BACKUP_BLOCK)\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "VAULT_VM")"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

# :command.usage
risk_backup_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk backup - Manage backup devices attach/detach from qubes\n"
    echo

  else
    printf "risk backup - Manage backup devices attach/detach from qubes\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk backup COMMAND\n"
  printf "  risk backup [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Attach a backup device to a qube. Accepts optional args to override default backup/vault\n" "$(red "attach")"
  printf "  %s   Detach the backup device from its current qube, making sure it's not in a read-write state\n" "$(red "detach")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_backup_attach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk backup attach - Attach a backup device to a qube. Accepts optional args to override default backup/vault\n"
    echo

  else
    printf "risk backup attach - Attach a backup device to a qube. Accepts optional args to override default backup/vault\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk backup attach [DEVICE] [VAULT_VM]\n"
  printf "  risk backup attach --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "DEVICE")"
    printf "    (optional) qubes path to device to use as backup (defaults to BACKUP_BLOCK)\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "VAULT_VM")"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

# :command.usage
risk_backup_detach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk backup detach - Detach the backup device from its current qube, making sure it's not in a read-write state\n"
    echo

  else
    printf "risk backup detach - Detach the backup device from its current qube, making sure it's not in a read-write state\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk backup detach [DEVICE] [VAULT_VM]\n"
  printf "  risk backup detach --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "DEVICE")"
    printf "    (optional) qubes path to device to use as backup (defaults to BACKUP_BLOCK)\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "VAULT_VM")"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

# :command.usage
risk_identity_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity - Create, manage and use identities and/or use their machines\n"
    echo

  else
    printf "risk identity - Create, manage and use identities and/or use their machines\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity COMMAND\n"
  printf "  risk identity [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)\n" "$(red "create")"
  printf "  %s   Creates the infrastructure for an already exiting identity.\n" "$(red "equip") "
  printf "  %s   Destroys an identity and all its associated machines and data\n" "$(red "delete")"
  printf "  %s   Simply open the identity store in the vault\n" "$(red "open")  "
  printf "  %s   Simply close the identity store in the vault\n" "$(red "close") "
  printf "  %s   Start the identity in the vault and all of its enabled VMs\n" "$(red "start") "
  printf "  %s   Stops all machines belonging to an identity, and close its vault if active.\n" "$(red "stop")  "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_identity_create_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity create - Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)\n"
    echo

  else
    printf "risk identity create - Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity create IDENTITY EMAIL EXPIRY_DATE [OPTIONS]\n"
  printf "  risk identity create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--prefix, -P NAME"
    printf "    Use a different name for naming identity VMs\n"
    echo

    # :flag.usage
    printf "  %s\n" "--label, -L COLOR"
    printf "    Specify a label color to be used for all VMs belonging to this identity\n"
    echo

    # :flag.usage
    printf "  %s\n" "--backup, -b"
    printf "    Device file of the backup drive (must be a whole drive without a partition\n    number, eg. /dev/sdb)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--only"
    printf "    Only create the identity in the vault: do not create any machines\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-gw, -G"
    printf "    Don't create a Whonix TOR gateway\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone-gw-from TOR_GW"
    printf "    Instead of creating the TOR gateway from a template, clone an existing TOR\n    AppVM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone-web-from WEB_VM"
    printf "    Instead of creating the Web browsing VM from a template, clone an existing\n    browser AppVM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone-split-from SPLIT_BROWSER_VM"
    printf "    Instead of creating the split-browser VM from a template, clone an existing\n    one\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Name of the identity for which to initialize infrastructure\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "EMAIL")"
    printf "    Email address to use for the GPG identity\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "EXPIRY_DATE")"
    printf "    Human readable, or GPG-compliant expiry duration to use for the GPG subkeys\n    (eg. '1 year', '1 week', etc)\n"
    echo

  fi
}

# :command.usage
risk_identity_equip_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity equip - Creates the infrastructure for an already exiting identity.\n"
    echo

  else
    printf "risk identity equip - Creates the infrastructure for an already exiting identity.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity equip IDENTITY [OPTIONS]\n"
  printf "  risk identity equip --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--prefix, -P NAME"
    printf "    Use a different name for naming identity VMs\n"
    echo

    # :flag.usage
    printf "  %s\n" "--label, -L COLOR"
    printf "    Specify a label color to be used for all VMs belonging to this identity\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-gw, -G"
    printf "    Don't create a Whonix TOR gateway\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone-gw-from TOR_GW"
    printf "    Instead of creating the TOR gateway from a template, clone an existing TOR\n    AppVM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone-web-from WEB_VM"
    printf "    Instead of creating the Web browsing VM from a template, clone an existing\n    browser AppVM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone-split-from SPLIT_BROWSER_VM"
    printf "    Instead of creating the split-browser VM from a template, clone an existing\n    one\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity for which to setup infrastructure\n"
    echo

  fi
}

# :command.usage
risk_identity_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity delete - Destroys an identity and all its associated machines and data\n"
    echo

  else
    printf "risk identity delete - Destroys an identity and all its associated machines and data\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity delete IDENTITY\n"
  printf "  risk identity delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity to delete along with machines\n"
    echo

  fi
}

# :command.usage
risk_identity_open_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity open - Simply open the identity store in the vault\n"
    echo

  else
    printf "risk identity open - Simply open the identity store in the vault\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity open IDENTITY\n"
  printf "  risk identity open --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity to open in the vault\n"
    echo

  fi
}

# :command.usage
risk_identity_close_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity close - Simply close the identity store in the vault\n"
    echo

  else
    printf "risk identity close - Simply close the identity store in the vault\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity close\n"
  printf "  risk identity close --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_identity_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity start - Start the identity in the vault and all of its enabled VMs\n"
    echo

  else
    printf "risk identity start - Start the identity in the vault and all of its enabled VMs\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity start IDENTITY\n"
  printf "  risk identity start --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity to start\n"
    echo

  fi
}

# :command.usage
risk_identity_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity stop - Stops all machines belonging to an identity, and close its vault if active.\n"
    echo

  else
    printf "risk identity stop - Stops all machines belonging to an identity, and close its vault if active.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity stop\n"
  printf "  risk identity stop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_identity_current_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity current - Prints the active identity as a raw string, to be used by prompts.\n"
    echo

  else
    printf "risk identity current - Prints the active identity as a raw string, to be used by prompts.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk identity current\n"
  printf "  risk identity current --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_slam_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk slam - Close identity, infrastructure and detach hush/backup at once\n"
    echo

  else
    printf "risk slam - Close identity, infrastructure and detach hush/backup at once\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk slam\n"
  printf "  risk slam --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_vpn_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn - Create, configure, manage and use VPN gateways for an identity.\n"
    echo

  else
    printf "risk vpn - Create, configure, manage and use VPN gateways for an identity.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn COMMAND\n"
  printf "  risk vpn [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Create VPN gateway from a template, or by cloning an existing one.\n" "$(red "create") "
  printf "  %s   Manage, import network configurations and run associated setup wizards\n" "$(red "setup")  "
  printf "  %s   Start a VPN gateway in the background\n" "$(red "start")  "
  printf "  %s   Stop a VPN gateway\n" "$(red "stop")   "
  printf "  %s   Automatically start a VPN gateway when starting the identity.\n" "$(red "enable") "
  printf "  %s   Do not autostart this VM when the identity is started\n" "$(red "disable")"
  printf "  %s   Delete a VPN gateway\n" "$(red "delete") "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_vpn_create_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn create - Create VPN gateway from a template, or by cloning an existing one.\n"
    echo

  else
    printf "risk vpn create - Create VPN gateway from a template, or by cloning an existing one.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn create [VM] [OPTIONS]\n"
  printf "  risk vpn create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--name, -N NAME"
    printf "    Use a different name for naming identity VMs\n"
    echo

    # :flag.usage
    printf "  %s\n" "--label, -L COLOR"
    printf "    Specify a label color to be used for all VMs belonging to this identity\n"
    echo

    # :flag.usage
    printf "  %s\n" "--enable, -E"
    printf "    Autostart this VM when the identity is started\n"
    echo

    # :flag.usage
    printf "  %s\n" "--template, -T TEMPLATE"
    printf "    TemplateVM to use instead of the default VPN TemplateVM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clone, -c"
    printf "    Instead of creating the VPN gateway from a template, clone an existing VPN\n    AppVM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--from, -f VPN_GW"
    printf "    VM to clone instead of the default VPN_VM configuration setting\n"
    echo

    # :flag.usage
    printf "  %s\n" "--set-default"
    printf "    Set this VM as the default NetVM for all identity client VMs (browsers,\n    messaging, etc)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--config-in CONFIG_VM"
    printf "    VM in which to browse for VPN configuration(s)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--netvm, -n VM"
    printf "    NetVM to use for the gateway\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    (optional) name to use for this VM (=> name-vpn)\n"
    echo

  fi
}

# :command.usage
risk_vpn_setup_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn setup - Manage, import network configurations and run associated setup wizards\n"
    echo

  else
    printf "risk vpn setup - Manage, import network configurations and run associated setup wizards\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn setup VM [OPTIONS]\n"
  printf "  risk vpn setup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--config-in CONFIG_VM"
    printf "    VM in which to browse for VPN configuration(s)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--set-default"
    printf "    Set this VM as the default NetVM for all identity client VMs (browsers,\n    messaging, etc)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--netvm, -n VM"
    printf "    NetVM to use for the gateway\n"
    echo

    # :flag.usage
    printf "  %s\n" "--choose"
    printf "    Choose an existing client config by running the setup wizard in the VPN VM\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to operate setup on\n"
    echo

  fi
}

# :command.usage
risk_vpn_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn start - Start a VPN gateway in the background\n"
    echo

  else
    printf "risk vpn start - Start a VPN gateway in the background\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn start VM\n"
  printf "  risk vpn start --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to start\n"
    echo

  fi
}

# :command.usage
risk_vpn_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn stop - Stop a VPN gateway\n"
    echo

  else
    printf "risk vpn stop - Stop a VPN gateway\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn stop VM\n"
  printf "  risk vpn stop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to stop\n"
    echo

  fi
}

# :command.usage
risk_vpn_enable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn enable - Automatically start a VPN gateway when starting the identity.\n"
    echo

  else
    printf "risk vpn enable - Automatically start a VPN gateway when starting the identity.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn enable VM\n"
  printf "  risk vpn enable --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to enable autostart for\n"
    echo

  fi
}

# :command.usage
risk_vpn_disable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn disable - Do not autostart this VM when the identity is started\n"
    echo

  else
    printf "risk vpn disable - Do not autostart this VM when the identity is started\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn disable VM\n"
  printf "  risk vpn disable --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to disable autostart for\n"
    echo

  fi
}

# :command.usage
risk_vpn_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn delete - Delete a VPN gateway\n"
    echo

  else
    printf "risk vpn delete - Delete a VPN gateway\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vpn delete VM\n"
  printf "  risk vpn delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    gateway VM to delete\n"
    echo

  fi
}

# :command.usage
risk_vm_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vm - Manage generic VMs (identity settings, enable/disable, etc)\n"
    echo

  else
    printf "risk vm - Manage generic VMs (identity settings, enable/disable, etc)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vm COMMAND\n"
  printf "  risk vm [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Tag an existing VM as belonging to the active identity, and change its netVM if one is already set\n" "$(red "add")    "
  printf "  %s   Delete a VM belonging to the current identity\n" "$(red "delete") "
  printf "  %s   Enable an identity VM to autostart\n" "$(red "enable") "
  printf "  %s   Disable an identity VM to autostart\n" "$(red "disable")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_vm_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vm add - Tag an existing VM as belonging to the active identity, and change its netVM if one is already set\n"
    echo

  else
    printf "risk vm add - Tag an existing VM as belonging to the active identity, and change its netVM if one is already set\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vm add VM [OPTIONS]\n"
  printf "  risk vm add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--netvm, -n VM"
    printf "    NetVM to use for this VM\n"
    echo

    # :flag.usage
    printf "  %s\n" "--set-default"
    printf "    If VM provides network, set this VM as default NetVM for identity\n"
    echo

    # :flag.usage
    printf "  %s\n" "--enable, -E"
    printf "    Autostart this VM when the identity is started\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    VM to tag with identity settings\n"
    echo

  fi
}

# :command.usage
risk_vm_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vm delete - Delete a VM belonging to the current identity\n"
    echo

  else
    printf "risk vm delete - Delete a VM belonging to the current identity\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vm delete VM\n"
  printf "  risk vm delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    VM to delete\n"
    echo

  fi
}

# :command.usage
risk_vm_enable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vm enable - Enable an identity VM to autostart\n"
    echo

  else
    printf "risk vm enable - Enable an identity VM to autostart\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vm enable VM\n"
  printf "  risk vm enable --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    VM to enable for autostart\n"
    echo

  fi
}

# :command.usage
risk_vm_disable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vm disable - Disable an identity VM to autostart\n"
    echo

  else
    printf "risk vm disable - Disable an identity VM to autostart\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk vm disable VM\n"
  printf "  risk vm disable --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    VM to disable from autostart\n"
    echo

  fi
}

# :command.usage
risk_use_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk use - Execute a command in a VM belong to an identity.\n"
    echo

  else
    printf "risk use - Execute a command in a VM belong to an identity.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk use VM [...]\n"
  printf "  risk use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VM")"
    printf "    VM in which to execute the command\n"
    echo

    # :command.footer
    printf "The target VM does not mandatorily need to belong to the active identity, if there is one.\nIf it does not belongs to another non-active identity, risk will take care of:\n  - Closing the active identity in the vault\n  - Opening the new one\nAfter this, the target VM is launched with the command arguments.\n\n"
    echo

  fi
}

# :command.usage
risk_qubes_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk qubes - Strutured set of commands for managing Qubes in general\n"
    echo

  else
    printf "risk qubes - Strutured set of commands for managing Qubes in general\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk qubes COMMAND\n"
  printf "  risk qubes [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Update one or more VM templates, by name patterns or filters\n" "$(red "update")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_qubes_update_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk qubes update - Update one or more VM templates, by name patterns or filters\n"
    echo

  else
    printf "risk qubes update - Update one or more VM templates, by name patterns or filters\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk qubes update VMS [OPTIONS]\n"
  printf "  risk qubes update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--identity, -I"
    printf "    Check for templates of all VMs belong to an identity\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VMS")"
    printf "    An arbitrary list of VMs name patterns to update.\n"
    echo

  fi
}

# :command.usage
risk_help_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk help - Show help about a command\n"
    echo

  else
    printf "risk help - Show help about a command\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risk help [COMMAND]\n"
  printf "  risk help --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMMAND")"
    printf "    Help subject\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if ((${#args[@]})); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/config.sh
config_init() {
  RISK_CONFIG_FILE=${RISK_CONFIG_FILE-${RISK_DIR}/config.ini}
  [[ -f "$RISK_CONFIG_FILE" ]] || {

      _info "Writing default configuration file to ${RISK_CONFIG_FILE}"
      cat << EOF > "$RISK_CONFIG_FILE"

; RISKS Dom0 Configuration file

; You can either edit this file in place, set values
; through the 'risk config' command.

; Default Templates =============================================== #

; Default Whonix Workstation TemplateVM for TOR clients
WHONIX_WS_TEMPLATE=whonix-ws-16

; Default Whonix Gateway TemplateVM for TOR gateways
WHONIX_GW_TEMPLATE=whonix-gw-16

; Default TemplateVM to use for VPN VMs
VPN_TEMPLATE=sys-vpn

; Default TemplateVM to use for split-browser backend
SPLIT_BROWSER_TEMPLATE=

; Default AppVMs ================================================== #
;
; These VMs are used when we create new machines by cloning
; existing ones, instead of creating blank AppVMs from templates.

; Default Whonix Workstation AppVM to use for identity client machine
WHONIX_WS=

; Default AppVM to use for cloning new VPN qubes
VPN_VM=

; Default AppVM to clone for split-browser backend
SPLIT_BROWSER=

; Vault settings ================================================== #

; Default vault VM
VAULT_VM=vault

; Qubes path to hush device, such as 'dom0:mmcblk01', or 'sys-usb:sda2', etc
SDCARD_BLOCK=

; Qubes path to backup device, such as 'sys-usb:sdb1'
BACKUP_BLOCK=

; Other network settings ========================================= #

; Default VM to use as a firewall VM, to which either Tor or VPN gateways are bound
DEFAULT_NETVM=sys-firewall

; Default path to VPN client config in VPN VM, to be loaded when the service
; starts. This path is the default one used by qubes-vpn-support installs.
DEFAULT_VPN_CLIENT_CONF='/rw/config/vpn/vpn-client.conf'

; General Application Settings =================================== #

; Default terminal to use in Dom0
DOM0_TERMINAL=xterm

; Default shell to use in Dom0
DOM0_SHELL=bash

; Default terminal to use in AppVMs
VM_TERMINAL=xterm

; Default shell to use in AppVMs

VM_SHELL=bash

EOF
  }
}

config_get() {
  # zsh compat
  setopt local_options BASH_REMATCH

  local key=$1
  local regex="^$key *= *(.+)$"
  local value=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      value="${BASH_REMATCH[2]}" # Changed to 2 because ZSH indexes start at 1
      break
    fi
  done < "$RISK_CONFIG_FILE"

  echo "$value"
}

config_set() {
  # zsh compat
  setopt local_options BASH_REMATCH

  local key=$1
  shift
  local value="$*"

  config_init

  local regex="^($key) *= *.+$"
  local output=""
  local found_key=""
  local newline

  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line =~ $regex ]]; then
      found_key="${BASH_REMATCH[2]}"
      newline="$key = $value"
      output="$output$newline\n"
    elif [[ $line ]]; then
      output="$output$line\n"
    fi
  done < "$RISK_CONFIG_FILE"

  if [[ -z $found_key ]]; then
    output="$output$key = $value\n"
  fi

  printf "%b\n" "$output" > "$RISK_CONFIG_FILE"
}

config_del() {
  local key=$1

  local regex="^($key) *="
  local output=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line ]] && [[ ! $line =~ $regex ]]; then
      output="$output$line\n"
    fi
  done < "$RISK_CONFIG_FILE"

  printf "%b\n" "$output" > "$RISK_CONFIG_FILE"
}

config_show() {
  config_init
  cat "$RISK_CONFIG_FILE"
}

config_keys() {
  # zsh compat
  setopt local_options BASH_REMATCH

  local regex="^([a-zA-Z0-9_\-\/\.]+) *="

  config_init

  local keys=()
  local key

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      key="${BASH_REMATCH[1]}"
      key="${key//\=/}"
      [[ -n "$key" ]] && keys+=("$key")
    fi
  done < "$RISK_CONFIG_FILE"
  echo "${keys[@]}"
}

config_has_key() {
  [[ $(config_get "$1") ]]
}

# src/lib/device.sh

# Checks that a given device is attached to a given VM
check_is_device_attached ()
{
    local block="$1"
    local vm="$2"

    local ovm=$(qvm-block list | grep "${block}" | awk {'print $4'} | cut -d" " -f1)
    if [[ ${#ovm} -eq 0 ]] || [[ ${ovm} != "$vm" ]]; then
        _failure "Device block $block is not mounted on vault ${vm}"
    fi
}

# src/lib/identity.sh

# _set_identity is used to propagate our various IDENTITY related variables
# so that all functions that will be subsequently called can access them.
#
# This function also takes care of checking if there is already an active
# identity that should be used, in case the argument is empty or none.
#
# $1 - The identity to use.
_set_identity ()

{
    local identity="$1"

    # This will throw an error if we don't have an identity from any source.
    IDENTITY=$(_identity_active_or_specified "$identity")
    _catch "Command requires either an identity to be active or given as argument"

    # Set the identity directory
    IDENTITY_DIR="${RISK_IDENTITIES_DIR}/${IDENTITY}"
}

# Upon unlocking a given identity, sets the name as an ENV

# variable that we can use in further functions and commands.
# $1 - The name to use. If empty, just resets the identity.
_set_active_identity ()
{
    # If the identity is empty, wipe the identity file
    if [[ -z ${1} ]] && [[ -e ${RISK_IDENTITY_FILE} ]]; then
        identity=$(cat "${RISK_IDENTITY_FILE}")
        rm "${RISK_IDENTITY_FILE}" || _warning "Failed to wipe identity file !"

        _verbose "Identity '${identity}' is now inactive, (name file deleted)"
        _info "Identity '${identity}' is now INACTIVE"
        return
    fi

    # If we don't have a file containing the

    # identity name, populate it.
    if [[ ! -e ${RISK_IDENTITY_FILE} ]]; then
        print "$1" > "${RISK_IDENTITY_FILE}"
	fi

    _verbose "Identity '${1}' is now active (name file written)"
    _info "Identity '${1}' is now ACTIVE"
}

# Returns 0 if an identity is unlocked, 1 if not.
_identity_active ()

{
    local active_identity

    active_identity=$(qvm-run --pass-io "$VAULT_VM" 'risks identity' 2>/dev/null)
    if [[ -z "${active_identity}" ]]; then
        return 1
	fi

    return 0
}

# Given an argument potentially containing the active identity, checks
# that either an identity is active, or that the argument is not empty.
# $1 - An identity name
# Exits the program if none is specified, or echoes the identity if found.
# Returns:
# 0 - Identity is non-nil, provided either from arg or by the active
# 1 - None have been given
_identity_active_or_specified ()
{
    local active_identity

    if [[ -z "${1}" ]] ; then
        active_identity=$(qvm-run --pass-io "$VAULT_VM" 'risks identity' 2>/dev/null)
        if [[ -z "${active_identity}" ]]; then
            return 1
        fi
    fi

    # Print the identity
    if [[ -n "${1}" ]]; then
        print "${1}" && return
    fi

    print "$active_identity"
}

# check that no identity is active in the vault, and fail if there is.
check_no_active_identity ()
{
    active_identity=$(qvm-run --pass-io "$VAULT_VM" 'risks identity' 2>/dev/null)
    if [[ -n $active_identity ]]; then
        # It might be the same
        if [[ $active_identity == "$1" ]]; then
            _info "Identity $1 is already active"
            exit 0
        fi

        _failure "Identity $active_identity is active. Close/slam/fold it and rerun this command"
    fi
}

# Checks that an identity exists in the vault
check_identity_exists ()
{
    local encryption_key        # The supposed key for the identity we want to verify
    local encrypted_identity    # The corresponding identity encrypted name

    encryption_key="print ""$1"" | spectre -q -n -s 0 -F n -t n -u ""$1"" 'file_encryption_key'"
    encrypted_identity_command="print ""$encryption_key"" | spectre -q -n -s 0 -F n -t n -u ""$1"" ""$1"""

    # Get the resulting encrypted name
    encrypted_identity="$(_qvrun "$VAULT_VM" "$encrypted_identity_command")"

    # And check the directory exists
    _qvrun "$VAULT" "ls /home/user/.graveyard/$encrypted_identity"
    _catch "Invalid identity: $1 does not exists in vault"
}

# Returns the name of the identity to which a VM belongs.
get_vm_owner ()
{
    print "$(qvm-tags "$1" "$RISK_VM_OWNER_TAG" 2>/dev/null)"
}

# Returns the default network VM for the active identity
identity_default_netvm ()
{
    cat "${IDENTITY_DIR}/netvm" 2>/dev/null
}

# Get the default VM label/color for an identity
get_identity_label ()
{
    cat "${IDENTITY_DIR}/vm_label" 2>/dev/null
}

# Get the TOR gateway for the identity
identity_tor_gw ()
{
    cat "${IDENTITY_DIR}/tor_gw" 2>/dev/null
}

# _identity_proxies returns an array of proxy VMs

# (VPNs and TOR gateways for the current identity)
_identity_proxies ()
{
    [[ -f "${IDENTITY_DIR}/proxy_vms" ]] || return
    read -d '' -r -A proxies <"${IDENTITY_DIR}/proxy_vms"
    echo "${proxies[@]}"
}

# returns all identity VMs that are not gateways/proxies,
# but are potentially (most of the time) accessing network
# from one or more of these gateways.
_identity_client_vms ()
{
    [[ -f "${IDENTITY_DIR}/client_vms" ]] || return
    read -d '' -r -A clients <"${IDENTITY_DIR}/client_vms"
    echo "${clients[@]}"
}

# returns all identity VMs that are not gateways/proxies,
# but are potentially (most of the time) accessing network
# from one or more of these gateways.
_identity_autostart_vms ()
{
    [[ -f "${IDENTITY_DIR}/autostart_vms" ]] || return
    read -d '' -r -A clients <"${IDENTITY_DIR}/autostart_vms"
    echo "${clients[@]}"
}

# src/lib/log.sh


# Section is set either by functions or simple calls,
# so that logging can inform on the component working.
section='risk'

# When multiple sections are used within a single risks
# operation, we padd them, for clearer/better aesthetics.
section_padding=0

# Last log level used. Inline logging uses this.
last_level="message"

# maps levels to their display color
declare -A log_colors
log_colors=(
    [verbose]="blue"
    [message]="white"
    [warning]="yellow"
    [success]="green"
    [failure]="red"
)

# maps levels to notice characters.
declare -A log_chars
log_chars=(
    [inline]=" > "
    [verbose]="[D]"
    [message]=" . "
    [warning]="[W]"
    [success]="(*)"
    [failure]="[E]"
)


# Simple way of setting the section and to update the padding
_in_section ()
{
    section="$1"
    if [[ -n "${2}" ]]; then
        section_padding="$2"
    fi
}

function is_verbose_set () {
    if [[ "${args['--verbose']}" -eq 1 ]]; then
        return 0
    else
        return 1
    fi
}

# Messaging function with pretty coloring
function _msg()

{
    # Check if we have been provided a section name,

    # and if not, that the section is set to a default.
    if [[ ${#@} -lt 3 ]]; then
        local progname="$section"
        if [[ -z "$progname" ]]; then
            progname='risk'
        fi
        local msg="$2"
    else
        local progname="$2"
        local msg="$3"
    fi

    # Padd the program/section name
    progname="$(printf %"${section_padding}"s "${progname}")"

    # Apply any translation for non-english users
	# local i
	# command -v gettext 1>/dev/null 2>/dev/null && msg="$(gettext -s "$3")"
	# for i in {3..${#}}; do
	# 	msg=${(S)msg//::$(($i - 2))*::/$*[$i]}
	# done

    # Apply log chars & color
    local pcolor=${log_colors[$1]}
    local pchars=${log_chars[$1]}

    # Use the display of last message when inline
    [[ "$1" == "inline" ]] && { pcolor=${log_colors[$last_level]}; pchars=${log_chars[inline]} }
    last_level="$1"

	local command="print -P"
	local fd=2
	local -i returncode

	case "$1" in
		inline)
			command+=" -n"
			;;
		failure)
			returncode=1
			;;
		print)
			progname=""
			fd=1
			;;
		# *)
		# 	pchars="[F]"; pcolor="red"
		# 	msg="Developer oops!  Usage: _msg MESSAGE_TYPE \"MESSAGE_CONTENT\""
		# 	returncode=127
			# ;;
	esac

	[[ -n $_MSG_FD_OVERRIDE ]] && fd=$_MSG_FD_OVERRIDE

    # If there is a log-file specified with flag --log-file,
    # output the message to it, instead of the current file descriptor
    logfile="${args[--log-file]}"
    if [[ -n "${logfile}" ]]; then
        ${=command} "${progname}" "${pchars}" "${msg}" >> "$logfile"
        return $returncode
    fi

    # Else, print to stdout, with colors
	if [[ -t $fd ]]; then
       [[ -n "$progname" ]] && progname="${fg[magenta]}$progname$reset_color"
       [[ -n "$pchars" ]] && pchars="${fg_bold[$pcolor]}$pchars$reset_color"
       msg="$fg[$pcolor]$msg$reset_color"
	fi

    ${=command} "${progname}" "${pchars}" "${msg}" >&"$fd"
	return $returncode
}

function _info() {
	local notice="message"
	[[ "$1" = "-n" ]] && shift && notice="inline"
    option_is_set -q || _msg "$notice" "$@"
	return 0
}

function _verbose() {
    is_verbose_set && _msg verbose "$@"
	return 0
}

function _success() {
    option_is_set -q || _msg success "$@"
	return 0
}

function _warning() {
    option_is_set -q || _msg warning "$@"
	return 1
}

# failure first prints the message we have passed following the catch
# of an error exit code, and then looks at the contents of erroring
# command's stderr buffer, which is printed just below our message.
# We then exit the program.
function _failure()

{
	typeset -i exitcode=${exitv:-1}

    _msg failure "$@"

    # Trim the message from any risks/risq header and print
    if [[ -n "$COMMAND_STDERR" ]]; then
        stderr=$(sed -r 's/^(risks|risq) \[[^][]*\]//' <<< "${COMMAND_STDERR}")
        stderr=$(sed -r 's/^(risks|risq)[ ]{1,}>//' <<< "${stderr}")
        stderr=$(sed -r 's/^[ ]{1,}//' <<< "${stderr}")

        _msg inline "$stderr"
    fi

	# Be sure we forget the secrets we were told
    exit "$exitcode"
}

# function _failure() {
# 	typeset -i exitcode=${exitv:-1}
#     option_is_set -q || _msg failure "$@"
# 	# be sure we forget the secrets we were told
#     exit "$exitcode"
# }

function _print() {
    option_is_set -q || _msg print "$@"
	return 0
}

# src/lib/messenger.sh

# Creates a new Messaging AppVM.
# $1 - Name to use for new VM
# $2 - Netvm for this VM

# $3 - Label
create_messenger_vm ()
{
    local msg="${1}-msg"
    local netvm="${2-$(config_get DEFAULT_NETVM)}"
    local gw_label="${3-orange}"

    local ws_template="$(config_get WHONIX_WS_TEMPLATE)"

    local -a create_command
    create_command+=(qvm-create --property netvm="$netvm" --label "$gw_label" --template "$ws_template")

    _info "Creating messaging VM (name: $msg / netvm: $netvm / template: $ws_template)"
}

# very similar to create_messenger_vm , except that we clone

# an existing AppVM instead of creating a new one from a Template.
clone_messenger_vm ()
{
    local msg="${1}-msg"
    local gw_clone="$2"
    local netvm="${3-$(config_get DEFAULT_NETVM)}"
    local gw_label="${4-orange}"

    create_command+=(qvm-clone "${gw_clone}" "${msg}")

    local label_command=(qvm-prefs "$msg" label "$gw_label")
    local netvm_command=(qvm-prefs "$msg" netvm "$netvm")

    _info "Cloning messaging VM (name: $msg / netvm: $netvm / template: $gw_clone)"
}

# src/lib/run.sh

COMMAND_STDOUT=''           # Stores a command's stdout output.
COMMAND_STDERR=''           # Stores a command's stderr output.

# do a command, splitting and storing stdout/stderr output and printing
# the former to screen only if the command is ran with verbose flag.
# Returns the command's exit code, so we can catch any errors and inform.
_run ()
{
    # The STDOUT/STDERR variables are populated, which
    # makes their content available to any subsequent call
    # to _failure, which needs STDERR output
    {
        IFS=$'\n' read -r -d '' COMMAND_STDERR;
        IFS=$'\n' read -r -d '' COMMAND_STDOUT;
        (IFS=$'\n' read -r -d '' _ERRNO_; exit "${_ERRNO_}");
    } < <((printf '\0%s\0%d\0' "$("$@")" "${?}" 1>&2) 2>&1)

    local ret="$?"

    # Output the command's result depending on the verbose mode
    # and if the command ran successfully. We check that either
    # stdout or stderr are non-empty: sometimes commands might
    # output to stderr, like wipe.
    if [[ $ret -eq 0 ]] && is_verbose_set ; then
        if [[ -n "$COMMAND_STDOUT" ]]; then
            _verbose "$COMMAND_STDOUT"
        fi
    fi

    # Return the command's exit code
    return $ret
}

# run a command in a qube
# $1 - Qube name
# $@ - Command string to run
_qrun ()

{
    local vm="$1" ; shift
    local command="$*"
    local terminal shell shell_command full_command

    # Prepare the full command
    terminal="$(config_get VM_TERMINAL)"
    shell="$(config_get VM_SHELL)"
    # shell_command='zsh -c "'"$command"'"'
    shell_command="${shell} -c '$command'"
    full_command=(qvm-run --pass-io "$vm" "$shell_command")

    _verbose "Running command: ${full_command[*]}"

    # Split io like in _run, and store the return value
    # Note that we don't double quote the $full_command variable.
    {
        IFS=$'\n' read -r -d '' COMMAND_STDERR;
        IFS=$'\n' read -r -d '' COMMAND_STDOUT;
        (IFS=$'\n' read -r -d '' _ERRNO_; exit "${_ERRNO_}");
    } < <((printf '\0%s\0%d\0' "$( "${full_command[@]}" )" "${?}" 1>&2) 2>&1)

    local ret="$?"

    # Output the command's result depending on the verbose mode
    # and if the command ran successfully like in _run also.
    if [[ $ret -eq 0 ]] && is_verbose_set ; then
        if [[ -n "$COMMAND_STDOUT" ]]; then
            _verbose "$COMMAND_STDOUT"
        fi
    fi

    return $ret
}

# _qvrun is a simplified version of _qrun, without stdout/err split & store.
_qvrun ()

{
    local vm="$1"
    shift
    local command="$*"

    # If we don't have any command arguments, we run the default terminal
    [[ -z "$command" ]] && command="$VM_TERMINAL"

    _verbose "Running command: ${command}"

    # Run the command raw, so that we get the output as it is.
    qvm-run --pass-io "$vm" "${command}"
}

# _qrun_term spawns a terminal on a target qube, with an associated command to run.
_qrun_term ()

{
    local vm="$1" ; shift
    local command="$*"
    local terminal shell shell_command

    # Prepare the full command
    terminal="$(config_get VM_TERMINAL)"
    shell="$(config_get VM_SHELL)"
    shell_command="${shell} -c '$command'"

    # Run the raw command, so that we get the output as it is.
    qvm-run --pass-io "$vm" "$terminal" -e "$shell_command"
}

# Checks the return code of a command, and if not successful,
# fails with the associated error message. Usage:
# catch $ret "hush" "Failed to execute this command"
function _catch ()
{
    local ret="$?"

    if [[ ! $ret -eq 0 ]]; then
        _failure "$@"
    fi
}

# src/lib/tor_gateway.sh

# Creates a new TOR Whonix gateway AppVM.
# $1 - Name to use for new VM
# $2 - Netvm for this gateway
# $3 - Label
create_tor_gateway ()
{
    local gw="${1}-gw"
    local netvm="${2-$(config_get DEFAULT_NETVM)}"
    local gw_label="${3-yellow}"

    local gw_template="$(config_get WHONIX_GW_TEMPLATE)"

    _verbose "Creating TOR gateway VM (name: $gw / netvm: $netvm / template: $gw_template)"
    _run qvm-create --property netvm="$netvm" --label "$gw_label" --template "$gw_template"

    # Tag the VM with its owner, and save as identity tor gateway
    _run qvm-tags "$gw" set "$IDENTITY"
    echo "$gw" >> "${IDENTITY_DIR}/tor_gw"
}

# very similar to create_tor_gateway, except that we clone an existing
# gateway AppVM instead of creating a new one from a Template.
clone_tor_gateway ()
{
    local gw="${1}-gw"
    local gw_clone="$2"
    local netvm="${3-$(config_get DEFAULT_NETVM)}"
    local gw_label="${4-yellow}"

    _verbose "Cloning TOR gateway VM (name: $gw / netvm: $netvm / template: $gw_clone)"
    _run qvm-clone "${gw_clone}" "${gw}"
    _catch "Failed to clone VM ${gw_clone}"

    # For now disposables are not allowed, since it would create too many VMs,

    # and complicate a bit the setup steps for VPNs. If the clone is a template
    # for disposables, unset it
    local disp_template
    disp_template=$(qvm-prefs "${gw}" template_for_dispvms)
    [[ "$disp_template" = "True" ]] && qvm-prefs "${gw}" template_for_dispvms False

    _info "Getting network from $netvm"
    _run qvm-prefs "$gw" netvm "$netvm"

    _verbose "Setting label to $gw_label"
    _run qvm-prefs "$gw" label "$gw_label"

    # Tag the VM with its owner, and save as identity tor gateway
    _run qvm-tags "$gw" set "$IDENTITY"
    echo "$gw" >> "${IDENTITY_DIR}/tor_gw"
}

# src/lib/utils.sh

# Return 0 if is set, 1 otherwise
option_is_set() {
	local -i r	 # the return code (0 = set, 1 = unset)

	[[ -n ${(k)OPTS[$1]} ]];
	r=$?

	[[ $2 == "out" ]] && {
		[[ $r == 0 ]] && { print 'set' } || { print 'unset' }
	}

	return $r;
}

# Retrieves the value of a variable first by looking in the risk
# config file, and optionally overrides it if the flag is set.
# $1 - Flag argument
# $2 - Key name in config
config_or_flag ()

{
    local value config_value

    config_value=$(config_get $2)   # From config
    value="${1:=$config_value}"      # overriden by flag if set

    print $value
}

# contains(string, substring)
#
# Returns 0 if the specified string contains the specified substring,
# otherwise returns 1.
contains() {
    string="$1"
    substring="$2"
    if test "${string#*$substring}" != "$string"
    then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

# src/lib/validations/validate_devices.sh

validate_device () {
    local block="$1"

    # And check not already attached to another qube
    ovm=$(qvm-block list | grep "${block}" | awk {'print $4'} | cut -d" " -f1)

    if [[ ${#ovm} -gt 0 ]]; then
        echo -e "Block ${block} is currently attached to ${ovm}."
        echo "Please umount it properly from there and rerun this program."
        return
    fi
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# src/lib/validations/validate_vm.sh

# does the vm exist?
validate_vm_exists () {
    vm=""
    for item in $(qvm-ls | grep -v dom0 | awk '{print $1}' | grep "${1}")
    do
        if [ "${item}" == "${1}" ]; then
            vm=${1}
        fi
    done
    if [ ${#vm} -eq 0 ]; then
        echo "No vm with name ${1} exists or can not be used. Aborted."
        return
    fi
}

# Checks that the vault VM obeys a few requirements, like no network
validate_valid_vaultvm () {
    vm=""
    for item in $(qvm-ls | grep -v dom0 | awk '{print $1}' | grep "${1}")
    do
        if [ "${item}" == "${1}" ]; then
            vm=${1}
        fi
    done
    if [ ${#vm} -eq 0 ]; then
        echo "No vm with name ${1} exists or can not be used. Aborted."
        return
    fi

    netvm=$(qvm-prefs "${vm}" | grep "netvm" | awk '{print $3}')
    if [ "${netvm}" != "None" ]; then
        echo "${vm} might be connected to the internet. Aborted."
        echo "Check: qvm-prefs ${vm} | grep netvm"
    fi
}

# src/lib/vm.sh

# Returns the name of the identity to which a VM belongs.
get_vm_owner ()
{
    print "$(qvm-tags "$1" "$RISK_VM_OWNER_TAG" 2>/dev/null)"
}

# Enables a VM to autostart
enable_vm_autostart ()
{
    local name="$1"
    local autostart_vms=( "$(_identity_autostart_vms)" )

    # Check if the VM is already marked autostart
    for vm in "${autostart_vms[@]}" ; do
        if [[ $vm == "$name" ]]; then
            already_enabled=true
        fi
    done

    if [[ ! $already_enabled ]]; then
        _info "Enabling VM ${name} to autostart"
        echo "$name" >> "${IDENTITY_DIR}/autostart_vms"
    else
        _info "VM ${name} is already enabled"
    fi
}

# Disables a VM to autostart
disable_vm_autostart ()
{
    local name="$1"
    _info "Disabling VM $name"
    sed -i /"$name"/d "${IDENTITY_DIR}/autostart_vms"
}

#assertRunning [vm] [start]
#Assert that the given VM is running. Will unpause paused VMs and may start shut down VMs.
#[vm]: VM for which to make sure it's running.
#[start]: If it's not running and not paused, start it (default: 0/true). If set to 1, this function will return a non-zero exit code.
#returns: A non-zero exit code, if it's not running and/or we failed to start the VM.
assertRunning ()

{
    local vm="$1"
    local start="${2:-0}"

    #make sure the VM is unpaused
    if qvm-check --paused "$vm" &> /dev/null ; then
        qvm-unpause "$vm" &> /dev/null || return 1
    else
        if [ "$start" -eq 0 ] ; then
            qvm-start --skip-if-running "$vm" &> /dev/null || return 1
        else
            #we don't attempt to start
            return 2
        fi
    fi

    return 0
}

# start_vm [vm 1] ... [vm n]
#Start the given VMs without executing any command.
start_vm ()

{
    local ret=0

    local vm=
    declare -A pids=() #VM --> pid
    for vm in "$@" ; do
        [[ "$vm" == "dom0" ]] && continue
        _verbose "Starting: $vm"
        assertRunning "$vm" &
        pids["$vm"]=$!
    done

    local failed=""
    local ret=
    for vm in "${(@k)pids}" ; do
        wait "${pids["$vm"]}"
        ret=$?
        [ $ret -ne 0 ] && failed="$failed"$'\n'"$vm ($ret)"
    done

    [ -z "$failed" ] || _verbose "Starting the following VMs failed: $failed"

    #set exit code
    [ -z "$failed" ]
}

# shutdown_vm [vm 1] ... [vm n]
#Shut the given VMs down.
shutdown_vm ()

{
    local ret=0

    if [ $# -gt 0 ] ; then
        #make sure the VMs are unpaused
        #cf. https://github.com/QubesOS/qubes-issues/issues/5967
        local vm=
        for vm in "$@" ; do
            qvm-unpause "$vm" &> /dev/null
        done

        _verbose "Shutting down: $*"
        qvm-shutdown --wait "$@"
        ret=$?
    fi

    return $ret
}

# check_network_chain verifies that the NetVM of a given VM indeed belongs
# to the same owner, and does this recursively for each NetVM found in the chain.
check_network_chain ()
{
    local vm="$1"
    local netvm
    local owner

    _verbose "Checking network chain (starting from VM $vm)"

    # If there is not network VM, there is nothing to do
    netvm="$(qvm-prefs "$vm" netvm)"
    [[ -z "$netvm" ]] && return 0

    # This call recursively checks for all netVMs
    check_valid_netvm "$netvm"
}

# check_vm_owner verifies that the VM is owned by the current identity.
check_valid_netvm ()
{
    local vm="$1"
    local owner
    local tor_gw

    # Or if the owner is either non-existant or not the good one, we must fail.
    owner="$(get_vm_owner "$vm")"
    [[ -n "$owner" ]] || _failure "VM $vm has no RISKS owner. Aborting"

    [[ "$owner" == "$IDENTITY" ]] || _failure "VM $vm does not belong to identity $IDENTITY"

    # If there is not network VM, there is nothing to do
    netvm="$(qvm-prefs "$vm" netvm)"
    [[ -z "$netvm" ]] && return 0

    # If the VM is the whonix gateway for the identity, we are done with the chain
    [[ "$vm" == "$(identity_tor_gw)" ]] && return 0

    # We also return if its the sys-firewall, which does not belong to any identity.
    [[ "$vm" == "$(config_get DEFAULT_NETVM)" ]] && return 0

    # Or check if the netVM is in one of the identity proxies, or if its the default VM
    is_proxy_vm "$netvm" || _failure "NetworkVM $vm is not listed as one of the identity's proxies"

    # Else, we go on with the netvm and do the same steps
    check_valid_netvm "$netvm"
}

# is_proxy_vm verifies that the identity's proxy VMs arrays contains a given VM.
is_proxy_vm ()
{
    local vm="$1"
    local match proxies

    match=1
    proxies=( $(_identity_proxies) )

    for proxy in "${proxies[@]}"; do
        if [[ $vm == "$proxy" ]]; then
            match=0
            break
        fi
    done

    return $match
}

# Returns an array of all VMs
all_vms ()
{
    local -a vms

    while IFS= read -r VM_NAME ; do
        vms+=("${VM_NAME}")
    done < <(qvm-ls --raw-list | sort)

    echo "${vms[@]}"
}

# check_not_netvm fails if the VM provides network to any other VM
check_not_netvm ()
{
    local vm="$1"

    local vms connected_vms

    # If it does not provide network at all, don't go further.
    [[ $(qvm-prefs "$vm" provides_network) == "True" ]] || return 0

    # Check if it provides network to any VM, and if yes, fail.
    vms=( $(all_vms) )
    for svm in "${vms[@]}" ; do
        local netvm
        if [[ "$(qvm-prefs "$svm" netvm)" == "$vm" ]]; then
            connected_vms+=( "$svm" )
        fi
    done

    [[ ${#connected_vms} -gt 0 ]] && _failure "VM $vm is netVM for [ ${connected_vms[*]} ] VMs"
}

# src/lib/vpn_gateway.sh

# Creates a new VPN gateway from a TemplateVM
create_vpn_gateway ()
{
    local gw="${1}"
    local netvm="${2-$(config_get DEFAULT_NETVM)}"
    local gw_label="${3:=blue}"
    local template="${4:=$(config_get VPN_TEMPLATE)}"

    _verbose "VPN gateway properties (name: $gw / netvm: $netvm / template: $template)"
    _run qvm-create --property netvm="$netvm" --label "$gw_label" --template "$template"

    _info "Getting network from $netvm"

    # Tag the VM with its owner, and add the gateway to the list of proxies
    _run qvm-tags "$gw" set "$IDENTITY"
    echo "$gw" >> "${IDENTITY_DIR}/proxy_vms"
}

# Creates a new VPN gateway from an existing VPN AppVM

clone_vpn_gateway ()
{
    local gw="${1}"
    local netvm="${2-$(config_get DEFAULT_NETVM)}"
    local gw_label="${3:=blue}"
    local gw_clone="$4"

    # Create the VPN
    _verbose "VPN gateway properties (name: $gw / netvm: $netvm / clone: $gw_clone)"
    _run qvm-clone "${gw_clone}" "${gw}"
    _catch "Failed to clone VM ${gw_clone}"

    # For now disposables are not allowed, since it would create too many VMs,

    # and complicate a bit the setup steps for VPNs. If the clone is a template
    # for disposables, unset it
    local disp_template
    disp_template=$(qvm-prefs "${gw}" template_for_dispvms)
    [[ "$disp_template" = "True" ]] && qvm-prefs "${gw}" template_for_dispvms False

    _info "Getting network from $netvm"
    _run qvm-prefs "$gw" netvm "$netvm"

    _verbose "Setting label to $gw_label"
    _run qvm-prefs "$gw" label "$gw_label"

    # Tag the VM with its owner, and add the gateway to the list of proxies
    _run qvm-tags "$gw" set "$IDENTITY"
    echo "$gw" >> "${IDENTITY_DIR}/proxy_vms"
}

# function to browse for one or more (as zip) VPN client configurations
# in another VM, import them in our VPN VM, and run the setup wizard if
# there is more than one configuration to choose from.
# $1 - Name of VPN VM
# $2 - Name of VM in which to browse for configuration
# $ $3 - Path to the VPN client config to which one (only) should be copied, if not a zip file
import_vpn_configs ()
{
    local name="$1"
    local config_vm="$2"
    local client_conf_path="$3"

    local config_path
    local new_path

    config_path=$(_qvrun "$config_vm" "zenity --file-selection --title='VPN configuration selection' 2>/dev/null")
    if [[ -z "$config_path" ]]; then
        _info "Canceling setup: no file selected in VM $config_vm"
    else
        _verbose "Copying file $config_path to VPN VM"
        _qvrun "$config_vm" qvm-copy-to-vm "$name" "$config_path"

        # Now our configuration is the QubesIncoming directory of our VPN,
        # so we move it where the VPN will look for when starting.
        new_path="/home/user/QubesIncoming/${config_vm}/$(basename "$config_path")"

        # If the file is a zip file, unzip it in the configs directory
        # and immediately run the setup prompt to choose one.
        if [[ $new_path:t:e == "zip" ]]; then
            local configs_dir="/rw/config/vpn/configs"

            _verbose "Unzipping files into $configs_dir"
            _qvrun "$name" mkdir -p "$configs_dir"

            _qvrun "$name" unzip -j -d "$configs_dir"

            _qvrun "$name" /usr/local/bin/setup_VPN

        else
            _verbose "Copying file directly to the VPN client config path"
            _qvrun "$name" mv "$new_path" "$client_conf_path"
        fi

        _info "Done transfering VPN client configuration to VM"
    fi

    # Add the gateway to the list of existing proxies for this identity
    echo "$gw" > "${IDENTITY_DIR}/proxy_vms"
}

# get_next_vpn_name returns a name for a new VPN VM, such as vpn-1,
# where the number is the next value after the ones found in existing
# VPN vms.
get_next_vpn_name ()
{
    local base_name="$1"

    # First get the array of ProxyVMs names
    local proxies=( $(_identity_proxies) )

    local next_number=1

    for proxy in "${proxies[@]}"; do
        if contains "$proxy" "vpn-"; then
            next_number=$((next_number + 1))
        fi
    done

    print "$base_name-vpn-$next_number"
}

# check_vm_is_proxy fails if the VM is not listed as an identity proxy.
check_vm_is_proxy ()

{
    local name="$1"
    local proxies

    proxies=($(_identity_proxies))
    for proxy in "${proxies[@]}" ; do
        if [[ $proxy == "$name" ]]; then
            found=true
        fi
    done

    if [[ ! $found ]]; then
        _info "VM $name is not listed as a VPN gateway. Aborting."
        exit 1
    fi
}

# src/lib/web.sh

# Create a web browsing VM from a template
create_browser_vm ()
{
    local web="${1}-web"
    local netvm="${2-$(config_get DEFAULT_NETVM)}"
    local web_label="${3-orange}"
    local ws_template="$(config_get WHONIX_WS_TEMPLATE)"

    _info "Creating web VM (name: $web / netvm: $netvm / template: $ws_template)"
    qvm-create --property netvm="$netvm" --label "$web_label" --template "$ws_template"
    [[ ! $? -eq 0 ]] && _warning "Failed to create browser VM $web"

    # Mark this VM as a disposable template, and tag it with our identity
    qvm-prefs "${web}" template_for_dispvms True
    qvm-tags "$web" set "$IDENTITY"
}

# Clone a web browsing VM from an existing one
clone_browser_vm ()
{
    local web="${1}-web"
    local web_clone="$2"
    local netvm="${3-$(config_get DEFAULT_NETVM)}"
    local web_label="${4-orange}"

    _info "Cloning web VM (name: $web / netvm: $netvm / template: $web_clone)"
    qvm-clone "${web_clone}" "${web}"
    [[ ! $? -eq 0 ]] && _warning "Failed to clone browser VM $web" && return

    qvm-prefs "$web" label "$web_label"
    qvm-prefs "$web" netvm "$netvm"

    # Mark this VM as a disposable template, and tag it with our identity
    qvm-prefs "${web}" template_for_dispvms True
    qvm-tags "$web" set "$IDENTITY"
}

# Create a split-browser VM from a template
create_split_browser_vm ()
{
    local web="${1}-split-web"
    local web_label="${2-gray}"
    local split_template="$(config_get SPLIT_BROWSER_TEMPLATE)"

    _info "Creating split-browser (name: $web / netvm: $netvm / template: $split_template)"
    qvm-create --property netvm=None --label "$web_label" --template "$split_template"

    qvm-tags "$web" set "$IDENTITY"
}

# Clone an existing split-browser VM, and change its dispvms
clone_split_browser_vm ()
{
    local web="${1}-split-web"
    local web_clone="$2"
    local web_label="${3-gray}"

    _info "Cloning split-browser VM (name: $web / netvm: $netvm / template: $web_clone)"
    qvm-clone "${web_clone}" "${web}"

    qvm-prefs "$web" label "$web_label"
    qvm-prefs "$web" netvm None

    qvm-tags "$web" set "$IDENTITY"
}

# :command.command_functions

# :command.function
risk_config_set_command() {
  # src/config_set_command.sh

  local key value

  key="${args['key']}"
  value="${args['value']}"

  config_set "$key" "$value"

}

# :command.function
risk_config_get_command() {
  # src/config_get_command.sh

  local key

  key="${args['key']}"

  config_get "$key"

}

# :command.function
risk_config_unset_command() {
  # src/config_unset_command.sh

  local key

  key="${args['key']}"

  config_set "$key" ""

}

# :command.function
risk_config_list_command() {
  # src/config_list_command.sh
  config_show

}

# :command.function
risk_config_keys_command() {
  # src/config_keys_command.sh
  config_keys

}

# :command.function
risk_hush_attach_command() {
  # src/hush_attach_command.sh

  local block vm
  local error_invalid_vm error_device

  block="${args['device']-$(config_get SDCARD_BLOCK)}"
  vm="${args['vault_vm']-$(config_get VAULT_VM)}"

  # If the validations were not performed because

  # we use a default environment variable for the
  # vault VM, perform them again here.
  error_invalid_vm=$(validate_valid_vaultvm "$vm")
  if [[ -n "$error_invalid_vm" ]]; then
      _failure "$error_invalid_vm"
  fi

  # Do the same for the hush device
  error_device=$(validate_device "$block")
  if [[ -n "$error_device" ]]; then
      _failure "$error_device"
  fi

  # is the vm running?
  qvm-ls | grep Running | awk {'print $1'} | grep '^'"${vm}"'$' &> /dev/null
  if [ "$?" != "0" ]; then
      _verbose "Starting VM $vm"
      qvm-start "${vm}"
  	sleep 5

  fi

  # finally attach the sdcard encrypted partition to the qube
  qvm-block attach "${vm}" "${block}"
  if [[ $? -eq 0 ]]; then
  	_success "Block ${block} has been attached to ${vm}"
  else
  	_failure "Block ${block} can not be attached to ${vm}"
  fi

  # If user wants to mount it now, do it
  if [[ ${args['--mount']} -eq 1 ]]; then
      _info "Mounting hush device"
      _qrun_term "$vm" risks hush mount
  fi

}

# :command.function
risk_hush_detach_command() {
  # src/hush_detach_command.sh

  local block vm

  block="${args['device']-$(config_get SDCARD_BLOCK)}"
  vm="${args['vault_vm']-$(config_get VAULT_VM)}"

  # First unmount the hush device in vault
  _info "Unmounting hush device before detaching"
  _qrun "$vm" risks hush umount
  _catch "Failed to unmount hush device ($block)"

  # detach the sdcard encrypted partition to the qube
  if qvm-block detach "${vm}" "${block}" &>/dev/null ; then
  	_success "Block ${block} has been detached from ${vm}"
  else
  	_failure "Block ${block} can not be detached from ${vm}"
  fi

}

# :command.function
risk_backup_attach_command() {
  # src/backup_attach_command.sh

  local block vm

  block="${args['device']-$(config_get BACKUP_BLOCK)}"
  vm="${args['vault_vm']-$(config_get VAULT_VM)}"

  local error_invalid_vm error_device

  # If the validations were not performed because

  # we use a default environment variable for the
  # vault VM, perform them again here.
  error_invalid_vm=$(validate_vm_exists "$vm")
  if [[ -n "$error_invalid_vm" ]]; then
      _failure "$error_invalid_vm"
  fi

  # Do the same for the hush device
  error_device=$(validate_device "$block")
  if [[ -n "$error_device" ]]; then
      _failure "$error_device"
  fi

  # is the vm running?
  qvm-ls | grep Running | awk {'print $1'} | grep '^'"${vm}"'$' &> /dev/null
  if [ "$?" != "0" ]; then
      _verbose "Starting VM $vm"
      qvm-start "${vm}"
  	sleep 15
  fi

  # finally attach the sdcard encrypted partition to the qube
  qvm-block attach "${vm}" "${block}"
  if [[ $? -eq 0 ]]; then
  	_success "Block ${block} has been attached to ${vm}"
  else
  	_success "Block ${block} can not be attached to ${vm}"
  fi

}

# :command.function
risk_backup_detach_command() {
  # src/backup_detach_command.sh
  local block vm

  block="${args['device']:-$(config_get BACKUP_BLOCK)}"
  vm="${args['vault_vm']-$(config_get VAULT_VM)}"

  # Always umount first
  _info "Locking/unmounting backup device before detaching"
  _qrun "$vm" risks backup umount
  _catch "Failed to unmount backup device ($block)"

  # detach the backup device
  if qvm-block detach "${vm}" "${block}" ; then
  	_success "Block ${block} has been detached from to ${vm}"
  else
  	_failure "Block ${block} can not be detached from ${vm}"
  fi

}

# :command.function
risk_identity_create_command() {
  # src/identity_create_command.sh

  # Variables setup ==========================================================

  # Variables populated from command-line args/flags
  local name="${args['identity']}"
  local email="${args['email']}"
  local expiry="${args['expiry_date']}"
  local pendrive="${args['--backup']}"

  # Other variables
  local vm_name           # Default prefix to use for newly created vm (eg. 'joe' => joe-vpn, joe-web)
  local label             # Default label color to use for all VMs, varies if not specified
  local netvm             # Entry NetVM for the identity
  local backup_args       # If identity is to be immediately backed up, this is the flag + the /dev/path in vault
  local gw_netvm          # NetVM for the tor gateway
  local web_netvm         # NetVM for the Web browser VM
  local clone             # A variable that might be overritten several times, used to assign a VM to clone.

  # Propagate the identity and its settings (in the script only)
  _set_identity "${args['identity']}"

  # Identity checks and basic setup ==========================================

  # Check no active identity is here,
  if _identity_active ; then
      _failure "Another identity ($IDENTITY) is active. Close/slam/stop it and rerun this command"
  fi

  # or that the one we want to create does not exists already
  if check_identity_exists "$IDENTITY" ; then
      _failure "Identity $IDENTITY already exists"
  fi

  # We're good to go
  _info "Creating identity $IDENTITY and infrastructure"

  # Make a directory for this identity, and store the associated VM name
  [[ -e ${IDENTITY_DIR} ]] || mkdir -p "$IDENTITY_DIR"

  # If the user wants to use a different vm_name for the VMs
  vm_name="${args['--prefix']-$IDENTITY}"
  echo "$vm_name" > "${IDENTITY_DIR}/vm_name"

  _info "Using vm_name '$name' as VM base name"

  label="${args['--label']}"
  echo "$vm_name" > "${IDENTITY_DIR}/vm_label"

  _info "Using label '$label' as VM default label"

  # Prepare the root NetVM for this identity
  netvm="${DEFAULT_NETVM}"

  # Create identity in vault =================================================

  # Simply pass the arguments to the vault
  _info "Creating identity in vault"

  if [[ -n "$pendrive" ]]; then
      backup_args=(--backup "$pendrive")
  fi

  # Create it
  _qrun_term "$VAULT_VM" risks create identity "$name" "$email" "$expiry" "${backup_args[@]}"

  _catch "Failed to create identity in vault"

  # And open it
  _qrun_term "$VAULT_VM" risks open identity "$name"
  _catch "Failed to open identity in vault"

  # If the user only wanted to create the identity in the vault, exit.
  if [[ ${args['--only']} -eq 1 ]] ; then
      _success "Successfully created identity $IDENTITY"
      _info "Skipping infrastructure setup" && exit
  fi

  # Network VMs ==============================================================
  _in_section "network" && _info "Creating network VMs:"

  # 1 - Tor gateway, if not explicitly disabled
  if [[ ${args['--no-gw']} -eq 0 ]]; then
      gw_netvm="$netvm"

      # We either clone the gateway from an existing one,
      # or we create it from a template.
      if [[ -n ${args['--clone-gw-from']} ]]; then
          clone="${args['--clone-gw-from']}"
          clone_tor_gateway "$vm_name" "$clone" "$gw_netvm" "$label"
      else
          create_tor_gateway "$vm_name" "$gw_netvm" "$label"
      fi

      # Set it as the netvm for this identity, and for the rest of the VMs
      echo "$vm_name" > "${IDENTITY_DIR}/net_vm"

  else
      _info "Skipping TOR gateway"
  fi

  # Browser VMs ==============================================================
  _in_section "web" && _info "Creating browsing VMs:"

  # Browser VMs are disposable, but we make a template for this identity,
  # since we might  either modify stuff in there, and we need them at least

  # to have a different network route.
  if [[ -n ${args['--clone-web-from']} ]]; then
      web_netvm="$(cat "${IDENTITY_DIR}/net_vm")"

      clone="${args['--clone-web-from']}"
      clone_browser_vm "$vm_name" "$clone" "$web_netvm" "$label"
  else
      create_browser_vm "$vm_name" "$web_netvm" "$label"
  fi

  # Split-browser has its own dispVMs and bookmarks
  local split_web="${vm_name}-split-web"
  if [[ -n ${args['--clone-split-from']} ]]; then
      clone="${args['--clone-split-from']}"
      clone_split_browser_vm "$split_web" "$clone" "$label"
  else
      create_split_browser_vm "$split_web" "$label"
  fi

  _success "Successfully initialized infrastructure for identity $IDENTITY"

}

# :command.function
risk_identity_equip_command() {
  # src/identity_equip_command.sh

  local name="${args['identity']}"

  # Other variables
  local vm_name           # Default prefix to use for newly created vm (eg. 'joe' => joe-vpn, joe-web)
  local label             # Default label color to use for all VMs, varies if not specified
  local netvm             # Entry NetVM for the identity
  local gw_netvm          # NetVM for the tor gateway
  local web_netvm         # NetVM for the Web browser VM
  local clone             # A variable that might be overritten several times, used to assign a VM to clone.

  # Propagate the identity and its settings (in the script only)
  _set_identity "${args['identity']}"

  # Identity checks and basic setup ==========================================

  check_identity_exists "$IDENTITY"

  _info "Creating infrastructure for identity $IDENTITY"

  # Make a directory for this identity, and store the associated VM name
  [[ -e ${IDENTITY_DIR} ]] || mkdir -p "$IDENTITY_DIR"

  # If the user wants to use a different vm_name for the VMs
  vm_name="${args['--prefix']-$IDENTITY}"
  echo "$vm_name" > "${IDENTITY_DIR}/vm_name"

  _info "Using vm_name '$name' as VM base name"

  label="${args['--label']}"
  echo "$vm_name" > "${IDENTITY_DIR}/vm_label"

  _info "Using label '$label' as VM default label"

  # Prepare the root NetVM for this identity
  netvm="${DEFAULT_NETVM}"

  # Network VMs ==============================================================
  _in_section "network" && _info "Creating network VMs:"

  # 1 - Tor gateway, if not explicitly disabled
  if [[ ${args['--no-gw']} -eq 0 ]]; then
      gw_netvm="$netvm"

      # We either clone the gateway from an existing one,
      # or we create it from a template.
      if [[ -n ${args['--clone-gw-from']} ]]; then
          clone="${args['--clone-gw-from']}"
          clone_tor_gateway "$vm_name" "$clone" "$gw_netvm" "$label"
      else
          create_tor_gateway "$vm_name" "$gw_netvm" "$label"
      fi

      # Set it as the netvm for this identity, and for the rest of the VMs
      echo "$vm_name" > "${IDENTITY_DIR}/net_vm"

  else
      _info "Skipping TOR gateway"
  fi

  # At this point we should know the vm_name of the VM to be used as NetVM
  # for the subsquent machines, such as web browsing and messaging VMs.

  # Browser VMs ==============================================================
  _in_section "web" && _info "Creating browsing VMs:"

  # Browser VMs are disposable, but we make a template for this identity,
  # since we might  either modify stuff in there, and we need them at least

  # to have a different network route.
  if [[ -n ${args['--clone-web-from']} ]]; then
      web_netvm="$(cat "${IDENTITY_DIR}/net_vm")"

      clone="${args['--clone-web-from']}"
      clone_browser_vm "$vm_name" "$clone" "$web_netvm" "$label"
  else
      create_browser_vm "$vm_name" "$web_netvm" "$label"
  fi

  # Split-browser has its own dispVMs and bookmarks
  local split_web="${vm_name}-split-web"
  if [[ -n ${args['--clone-split-from']} ]]; then
      clone="${args['--clone-split-from']}"
      clone_split_browser_vm "$split_web" "$clone" "$label"
  else
      create_split_browser_vm "$split_web" "$label"
  fi

  _success "Successfully initialized infrastructure for identity $IDENTITY"

}

# :command.function
risk_identity_delete_command() {
  # src/identity_delete_command.sh

  _set_identity "${args['identity']}"

  # First check the identity is valid

  # Check access to hush device in vault

  # Close the identity

  # Close all machines belonging to the identity

  # Delete these machines

  # Delete the identity data in the vault

  # And delete the identity directory in dom0.

  _success "Successfully deleted identity $IDENTITY"

}

# :command.function
risk_identity_open_command() {
  # src/identity_open_command.sh

  local sdcard_block="$(config_get SDCARD_BLOCK)"
  local vault_vm="$(config_get VAULT_VM)"

  _set_identity "${args['identity']}"

  # 1 - Check that hush is mounted on vault
  # TODO: change this, since it only checks for the default vault VM
  check_is_device_attached "${sdcard_block}" "${vault_vm}"

  # 2 - Check that no identity is currently opened
  # The second line should be empty, as opposed to being an encrypted coffin name
  check_no_active_identity "$IDENTITY"

  # 3 - Send commands to vault
  _info "Opening identity $IDENTITY"

  _qrun_term "$vault_vm" risks identity open "$IDENTITY"
  _catch "Failed to open identity"

  _info "Identity $IDENTITY is active"

}

# :command.function
risk_identity_close_command() {
  # src/identity_close_command.sh

  local vault_vm="$(config_get VAULT_VM)"

  # Check we have an active identity
  active_identity=$(qvm-run --pass-io "$vault_vm" 'cat .identity' 2>/dev/null)
  if [[ -z $active_identity ]]; then
      _info "No active identity to close"
      exit 0
  fi

  _info "Closing identity $active_identity"

  _qrun_term "$vault_vm" risks close identity "$active_identity"
  _catch "Failed to close identity $active_identity"

  _info "Identity $active_identity is closed"

}

# :command.function
risk_identity_start_command() {
  # src/identity_start_command.sh

  _set_identity "${args['identity']}"

  # Get the name for VMs
  local name="$(cat "${IDENTITY_DIR}/vm_name")"

  # Check the identity is valid

  # Open the identity in vault

  # Start all enabled network machines

  # Start all enabled client machines

  _success "Opened identity '$IDENTITY' and started enabled VMs"

}

# :command.function
risk_identity_stop_command() {
  # src/identity_stop_command.sh

  # Else get the active identity
  local active_identity
  active_identity=$(_identity_active_or_specified)

  _info "Stopping machines and identity $active_identity"

  # First shut down all client VMs
  read -ra client_vms "$(identity_client_vms)"
  for vm in "${client_vms[@]}" ; do
      _info "Shutting down $vm"
      shutdown_vm "$vm"
  done

  # Do the same for proxyVMs
  read -ra proxy_vms "$(identity_proxies)"
  for vm in "${proxy_vms[@]}" ; do
      _info "Shutting down $vm"
      shutdown_vm "$vm"
  done

  _success "Done"

}

# :command.function
risk_identity_current_command() {
  # src/identity_current_command.sh
  # Simply print the active identity in the vault
  _identity_active_or_specified

}

# :command.function
risk_slam_command() {
  # src/slam_command.sh

  # If no active identity to slam, nothing to do except umounting the hush device
  if ! _identity_active ; then
      _info "No active identity, only detaching hush and backup devices"
      risk_hush_detach_command
      risk_backup_detach_command
      exit 0
  fi

  # Else get the active identity, and propagate values to the script
  local active_identity
  active_identity=$(_identity_active_or_specified)
  _set_identity "$active_identity"

  _info "Slamming infrastructure, vault and devices: identity $active_identity"

  # First shut down all client VMs
  read -ra client_vms "$(identity_client_vms)"
  for vm in "${client_vms[@]}" ; do
      _info "Shutting down $vm"
      shutdown_vm "$vm"
  done

  # Do the same for proxyVMs
  read -ra proxy_vms "$(identity_proxies)"
  for vm in "${proxy_vms[@]}" ; do
      _info "Shutting down $vm"
      shutdown_vm "$vm"
  done

  # Close the identity in the vault, unmount hush and backup
  risk_identity_close_command
  risk_hush_detach_command
  risk_backup_detach_command

  _success "Done"

}

# :command.function
risk_vpn_create_command() {
  # src/vpn_create_command.sh

  _set_identity

  # Prepare some settings for this new VM
  local name netvm clone template label

  name="${args['vm']:-$(cat "${IDENTITY_DIR}/vm_name" 2>/dev/null)}"
  label="${args['--label']:=$(get_identity_label)}"
  netvm="$(config_or_flag "${args['--netvm']}" DEFAULT_NETVM)"
  clone="$(config_or_flag "${args['--from']}" VPN_VM)"
  template="$(config_or_flag "${args['--template']}" VPN_TEMPLATE)"

  # 0 - Last-time setup

  # If the --name flag is empty, this means we are using a default one,
  # either the configured default one, or the name of the identity.

  # In this case, we add 'vpn-1' to it (number varying).
  if [[ -z "${args['vm']}" ]]; then
      name="$(get_next_vpn_name "$name")"
  fi

  # 1 - Creation
  #
  # We either clone the gateway from an existing one,
  # or we create it from a template.
  if [[ "${args['--clone']}" -eq 1 ]]; then
      _info "Cloning VPN gateway (from VM $clone)"
      clone_vpn_gateway "$name" "$netvm" "$label" "$clone"

  else
      _info "Creating VPN gateway (from template $template)"
      create_vpn_gateway "$name" "$netvm" "$label" "$template"
  fi

  # Tag the VM with its owner
  _run qvm-tags "$name" "$RISK_VM_OWNER_TAG" "$IDENTITY"
  _catch "Failed to tag VM with identity"

  # 2 - Setup
  #
  # Simply run the setup command, which has access to all the flags
  # it needs to do its job. Tweak the args array for this to work.
  args['vm']="$name"
  risk_vpn_setup_command

  # If the VM is marked autostart
  if [[ -n ${args['--enable']} ]]; then

      _verbose "Enabling VM to autostart"
      risk_vpn_enable_command
  fi

  _info "Done creating VPN gateway $name"

}

# :command.function
risk_vpn_setup_command() {
  # src/vpn_setup_command.sh

  _set_identity

  local name config_vm client_conf_path netvm

  name="${args['vm']}"
  config_vm="${args['--config-in']}"
  client_conf_path="$(config_or_flag "" DEFAULT_VPN_CLIENT_CONF)"
  netvm="$(config_or_flag "${args['--netvm']}" DEFAULT_NETVM)"

  # There are different ways to setup a VPN VM, often mutually exclusive.

  # We might be asked to change the netVM, but this can be combined
  # with other settings to be handled below.
  if [[ -n "${netvm}" ]]; then
      _info "Getting network from $netvm"
      qvm-prefs "$name" netvm "$netvm"
  fi

  # If the user wants this VM to be the default NetVM for all clients
  # like browsers, messaging VMs, etc.
  if [[ ${args['--set-default']} -eq 1 ]]; then
      echo "$name" > "${IDENTITY_DIR}/net_vm"

      _info "Setting '$name' as default NetVM for all client machines"

      # Here, find all existing client VMs (not gateways)

      # and change their netVMs to this one.
      local clients=($(_identity_client_vms))
      for client in "${clients[@]}"; do
          if [[ -n "$client" ]]; then
              _verbose "Changing $client netVM"
              qvm-prefs "$client" netvm "$name"
          fi
      done
  fi

  # Client VPN Configurations
  if [[ "${args['--choose']}" -eq 1 ]]; then
      # If we are asked to choose an existing configuration in the VM
      _qvrun "$name" /usr/local/bin/setup_VPN

  elif [[ -n "${args['--config-in']}" ]]; then
      # Or if we are asked to browse one or more configuration files in another VM.
      import_vpn_configs "$name" "$config_vm" "$client_conf_path"
  fi

}

# :command.function
risk_vpn_start_command() {
  # src/vpn_start_command.sh

  local name="${args['vm']}"

  _info "Starting gateway $name in the background"

  # First check all the network VMs that will be started
  # actually belong to the identity, otherwise we fail.
  check_network_chain "$name"

  # Then start the VM, which will start all dependent ones.
  start_vm "$name"
  _catch "Failed to start $name"

  _info "Started VM $name"

}

# :command.function
risk_vpn_stop_command() {
  # src/vpn_stop_command.sh

  local name="${args['vm']}"

  _info "Shutting down gateway $name"
  shutdown_vm "$name"
  _catch "Failed to shutdown $name"
  _info "Shut down $name"

}

# :command.function
risk_vpn_enable_command() {
  # src/vpn_enable_command.sh

  _set_identity

  local name autostart_vms already_enabled

  name="${args['vm']}"

  enable_vm_autostart "$name"

}

# :command.function
risk_vpn_disable_command() {
  # src/vpn_disable_command.sh

  _set_identity

  local name="${args['vm']}"

  disable_vm_autostart "$name"

}

# :command.function
risk_vpn_delete_command() {
  # src/vpn_delete_command.sh

  local name

  name="${args['vm']}"

  _set_identity

  # Check that the selected VM is indeed one of the identity
  # proxy VMs, so that we don't accidentally delete another one.
  check_vm_is_proxy "$name"

  # Do not even attempt to delete if the VM provides network to another VM.
  check_not_netvm "$vm"

  _info "Deleting gateway VM $name"

  # If the VPN was the default NetVM for the identity,
  # update the NetVM to Whonix.
  netvm="$(identity_default_netvm)"
  if [[ $netvm == "$name" ]]; then
      _warning "Gateway $name is the default NetVM for identity clients !"

      # Check if we have a TOR gateway
      local tor_gw=$(identity_tor_gw)

      if [[ -n $tor_gw ]]; then
          _info -n "Updating the default identity NetVM to $tor_gw"
          echo "$tor_gw" > "${IDENTITY_DIR}/net_vm"

      else
          _info -n "The identity has no default NetVM anymore, please set it."
      fi
  fi

  # Check if there are some existing VMs that use this gateway as NetVM,
  # and change their netVM to None: this is unpractical, especially for
  # those that might be up, but it's better than assigning a new netVM
  # despite this presenting a security risk.

  # Delete without asking to confirm
  echo "y" | _run qvm-remove "$name"
  _catch "Failed to delete (fully or partially) VM $name"

  # Remove from VMs marked autostart
  sed -i /"$name"/d "${IDENTITY_DIR}/autostart_vms"
  # And remove from proxy VMs

  sed -i /"$name"/d "${IDENTITY_DIR}/proxy_vms"

  # Finally, delete the VM,

  _run qvm-remove "$name"
  _catch "Failed to delete VM $name:"

  _info "Deleted $name"

}

# :command.function
risk_vm_add_command() {
  # src/vm_add_command.sh

  local vm vm_owner

  vm="${args['vm']}"

  _set_identity

  # We need a valid identity
  check_identity_exists "$IDENTITY"

  # Check VM ownership
  vm_owner=$(get_vm_owner "$vm")

  # If already belongs to an identity, ask for confirmation to update the settings.
  if [[ -n "$vm_owner" ]] && [[ "$vm_owner" != "$IDENTITY" ]]; then
      _warning "VM $vm already belongs to $vm_owner"
      printf >&2 '%s ' "Do you really want to assign a new identity ($IDENTITY) to this VM ? (YES/n)"
      read ans

      if [[ "$ans" != 'YES' ]]; then
          _info "Aborting identity change. Exiting"
          exit 0
      fi
  fi

  # Tag the VM with its owner
  _run qvm-tags "$vm" set "$IDENTITY"
  _catch "Failed to tag VM with identity"

  # Change its network VM, either with the default for the identity,
  # or with the netvm flag, which has precedence.
  if [[ "$(qvm-tags "$vm" netvm)" != 'None' ]]; then
      _info "VM is networked. Updating its network VM"
      local netvm="$(identity_default_netvm)"

      # If the user overrode the default netVM, check that it belongs
      # to the identity, or ask confirmation.
      if [[ -n "${args['--netvm']}" ]]; then
          netvm_owner=$(get_vm_owner "${args['--netvm']}")
          if [[ "$vm_owner" != "$IDENTITY" ]]; then
              _warning "Network VM $vm already belongs to $vm_owner"
              printf >&2 '%s ' "Do you really want to use this VM as netvm for $vm? (YES/n)"
              read ans

              if [[ "$ans" == 'YES' ]]; then
                  netvm="${args['--netvm']}"
              fi
          fi
      fi

      _info "Setting network VM to $netvm"
      _run qvm-tags "$vm" netvm "$netvm"
      _catch "Failed to set netvm"
  fi

  # Check if the VM provides network. If yes we naturally consider

  # it to be a gateway, and we add it to the list of proxy_vms.
  if [[ "$(qvm-tags "$vm" provides_network)" == 'True' ]]; then
      _info "VM provides network. Treating it as a gateway VM"

      # Add as a proxy VM
      echo "$vm" > "${IDENTITY_DIR}/proxy_vms"

      # If the user specified to use it as the default netvm
      if [[ ${args['--set-default']} -eq 1 ]]; then
          echo "$vm" > "${IDENTITY_DIR}/net_vm"

          _info "Setting '$vm' as default NetVM for all client machines"
      fi
  fi

  # Enable autostart if asked to
  [[ "${args['--enable']}" -eq 1 ]] && enable_vm_autostart "$vm"

  _success "Succesfully set VM $vm as belonging to identity $IDENTITY"

}

# :command.function
risk_vm_delete_command() {
  # src/vm_delete_command.sh
  local vm

  vm="${args['vm']}"

  _set_identity

  # Check VM ownership

  [[ "$(get_vm_owner "$vm")" != "$IDENTITY" ]] || _failure "VM $vm does not belong to $IDENTITY"

  # Do not even attempt to delete if the VM provides network to another VM.
  check_not_netvm "$vm"

  # If the VM is a gateway, just call the VPN command to do the work.
  if is_proxy_vm "$vm" ; then
      risk_vpn_delete_command
      return
  fi

  # Remove from autostart enabled commands
  sed -i /"$vm"/d "${IDENTITY_DIR}/autostart_vms"

  # Finally, delete the VM,

  _run qvm-remove "$vm"
  _catch "Failed to delete VM $vm:"

}

# :command.function
risk_vm_enable_command() {
  # src/vm_enable_command.sh
  local vm

  vm="${args['vm']}"

  _set_identity

  # Check VM ownership

  [[ "$(get_vm_owner "$vm")" != "$IDENTITY" ]] || _failure "VM $vm does not belong to $IDENTITY"

  enable_vm_autostart "$vm"

}

# :command.function
risk_vm_disable_command() {
  # src/vm_disable_command.sh
  local vm

  vm="${args['vm']}"

  _set_identity

  # Check VM ownership

  [[ "$(get_vm_owner "$vm")" != "$IDENTITY" ]] || _failure "VM $vm does not belong to $IDENTITY"

  disable_vm_autostart "$vm"

}

# :command.function
risk_use_command() {
  # src/use_command.sh

  local vm arguments

  # Note that we concatenate all command arguments in a string (with *), to be passed to qvm-run
  vm="${args['vm']}"
  arguments="${other_args[@]}"

  local owner active_identity
  owner=$(get_vm_owner "$vm")
  active_identity="$(_identity_active_or_specified)"

  # If the VM does not belong to any identity, then we don't have
  # to interact with any of them, and this branch is skipped.
  #

  # However if the VM does not belong the active identity, we must:

  if [[ -n "$owner" ]] && [[ $owner != "$active_identity" ]]; then
      # Close the active identity
      _info "Closing identity $active_identity"
      risk_identity_close_command

      # Open the new one
      args['identity']="$owner"
      risk_identity_open_command
  fi

  # At this point everything identity-related should be cleared and done.
  _qvrun "$vm" "${arguments[@]}"
  _catch "Failed to execute command in $vm:"

}

# :command.function
risk_qubes_update_command() {
  # src/qubes_update_command.sh
  local vms="${args['vms']}"

  get_all_qubes() {
      local all_qubes
      while read VM_NAME ; do
          all_qubes+=("${VM_NAME}")
      done < <(qvm-ls --raw-list | sort)

      echo "${all_qubes[@]}"
  }

  local all_qubes
  read -ra all_qubes < "$(get_all_qubes)"

  get_all_templates() {
      local templates=()

      while read line ; do
          IFS="|" read -r name class < "${qube}"
          if [[ "$class" == "TemplateVM" ]]; then
              templates+=( "$name" )
          fi
      done < ("$(qvm-ls --raw-data --fields name,class|sort)")

      echo "${templates[@]}"
  }

  local targets
  read -ra all_templates < "$(get_all_templates)"

  for template in "${all_templates[@]}"; do
      if [[ "$template" =~ .*"$*".* ]]; then
          echo $template
      fi
  done

}

# :command.function
risk_help_command() {
  # src/help_command.sh
  command="${args[command]}"
  long_usage=yes

  if [[ -z "$command" ]]; then
    # No command argument, show the global help
    help_function=risk_usage
  else
    # Show the help for the requested command
    help_function="risk_${command}_usage"
  fi

  # Call the help function if it exists
  if [[ $(type "$help_function") ]]; then
    "$help_function"
  else
    echo "No help available for this command"
    exit 1
  fi

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        risk_usage
        exit
        ;;

      # :flag.case
      --verbose | -v)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    config)
      action="config"
      shift
      risk_config_parse_requirements "$@"
      shift $#
      ;;

    hush)
      action="hush"
      shift
      risk_hush_parse_requirements "$@"
      shift $#
      ;;

    backup)
      action="backup"
      shift
      risk_backup_parse_requirements "$@"
      shift $#
      ;;

    identity)
      action="identity"
      shift
      risk_identity_parse_requirements "$@"
      shift $#
      ;;

    slam)
      action="slam"
      shift
      risk_slam_parse_requirements "$@"
      shift $#
      ;;

    vpn)
      action="vpn"
      shift
      risk_vpn_parse_requirements "$@"
      shift $#
      ;;

    vm)
      action="vm"
      shift
      risk_vm_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      risk_use_parse_requirements "$@"
      shift $#
      ;;

    qubes)
      action="qubes"
      shift
      risk_qubes_parse_requirements "$@"
      shift $#
      ;;

    help)
      action="help"
      shift
      risk_help_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_config_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    set)
      action="set"
      shift
      risk_config_set_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      risk_config_get_parse_requirements "$@"
      shift $#
      ;;

    unset)
      action="unset"
      shift
      risk_config_unset_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      risk_config_list_parse_requirements "$@"
      shift $#
      ;;

    keys)
      action="keys"
      shift
      risk_config_keys_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_config_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_config_set_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_set_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config set"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        elif [[ -z ${args['value']+x} ]]; then

          args['value']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risk config set KEY VALUE\n" >&2
    exit 1
  fi
  if [[ -z ${args['value']+x} ]]; then
    printf "missing required argument: VALUE\nusage: risk config set KEY VALUE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_config_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risk config get KEY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_config_unset_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_unset_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config unset"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risk config unset KEY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_config_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_config_keys_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_config_keys_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config keys"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_hush_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_hush_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    attach)
      action="attach"
      shift
      risk_hush_attach_parse_requirements "$@"
      shift $#
      ;;

    detach)
      action="detach"
      shift
      risk_hush_detach_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_hush_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_hush_attach_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_hush_attach_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="hush attach"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --mount | -m)

        # :flag.case_no_arg
        args['--mount']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['device']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_device "$1") ]]; then
            printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_device "$1")" >&2
            exit 1
          fi

          args['device']=$1
          shift
        elif [[ -z ${args['vault_vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_valid_vaultvm "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")" >&2
            exit 1
          fi

          args['vault_vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_hush_detach_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_hush_detach_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="hush detach"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['device']+x} ]]; then

          args['device']=$1
          shift
        elif [[ -z ${args['vault_vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_valid_vaultvm "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")" >&2
            exit 1
          fi

          args['vault_vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_backup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_backup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    attach)
      action="attach"
      shift
      risk_backup_attach_parse_requirements "$@"
      shift $#
      ;;

    detach)
      action="detach"
      shift
      risk_backup_detach_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_backup_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_backup_attach_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_backup_attach_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="backup attach"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['device']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_device "$1") ]]; then
            printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_device "$1")" >&2
            exit 1
          fi

          args['device']=$1
          shift
        elif [[ -z ${args['vault_vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_valid_vaultvm "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")" >&2
            exit 1
          fi

          args['vault_vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_backup_detach_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_backup_detach_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="backup detach"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['device']+x} ]]; then

          args['device']=$1
          shift
        elif [[ -z ${args['vault_vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_valid_vaultvm "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")" >&2
            exit 1
          fi

          args['vault_vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_identity_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    create)
      action="create"
      shift
      risk_identity_create_parse_requirements "$@"
      shift $#
      ;;

    equip)
      action="equip"
      shift
      risk_identity_equip_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      risk_identity_delete_parse_requirements "$@"
      shift $#
      ;;

    open)
      action="open"
      shift
      risk_identity_open_parse_requirements "$@"
      shift $#
      ;;

    close)
      action="close"
      shift
      risk_identity_close_parse_requirements "$@"
      shift $#
      ;;

    start)
      action="start"
      shift
      risk_identity_start_parse_requirements "$@"
      shift $#
      ;;

    stop)
      action="stop"
      shift
      risk_identity_stop_parse_requirements "$@"
      shift $#
      ;;

    current)
      action="current"
      shift
      risk_identity_current_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_identity_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_identity_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --prefix | -P)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--prefix']="$2"
          shift
          shift
        else
          printf "%s\n" "--prefix requires an argument: --prefix, -P NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --label | -L)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--label']="$2"
          shift
          shift
        else
          printf "%s\n" "--label requires an argument: --label, -L COLOR" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --backup | -b)

        # :flag.case_no_arg
        args['--backup']=1
        shift
        ;;

      # :flag.case
      --only)

        # :flag.case_no_arg
        args['--only']=1
        shift
        ;;

      # :flag.case
      --no-gw | -G)
        # :flag.conflicts
        if [[ -n "${args['--clone-gw-from']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--clone-gw-from" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no-gw']=1
        shift
        ;;

      # :flag.case
      --clone-gw-from)
        # :flag.conflicts
        if [[ -n "${args['--no-gw']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-gw" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--clone-gw-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-gw-from requires an argument: --clone-gw-from TOR_GW" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --clone-web-from)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--clone-web-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-web-from requires an argument: --clone-web-from WEB_VM" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --clone-split-from)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--clone-split-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-split-from requires an argument: --clone-split-from SPLIT_BROWSER_VM" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        elif [[ -z ${args['email']+x} ]]; then

          args['email']=$1
          shift
        elif [[ -z ${args['expiry_date']+x} ]]; then

          args['expiry_date']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity create IDENTITY EMAIL EXPIRY_DATE [OPTIONS]\n" >&2
    exit 1
  fi
  if [[ -z ${args['email']+x} ]]; then
    printf "missing required argument: EMAIL\nusage: risk identity create IDENTITY EMAIL EXPIRY_DATE [OPTIONS]\n" >&2
    exit 1
  fi
  if [[ -z ${args['expiry_date']+x} ]]; then
    printf "missing required argument: EXPIRY_DATE\nusage: risk identity create IDENTITY EMAIL EXPIRY_DATE [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_equip_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_equip_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity equip"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --prefix | -P)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--prefix']="$2"
          shift
          shift
        else
          printf "%s\n" "--prefix requires an argument: --prefix, -P NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --label | -L)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--label']="$2"
          shift
          shift
        else
          printf "%s\n" "--label requires an argument: --label, -L COLOR" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no-gw | -G)
        # :flag.conflicts
        if [[ -n "${args['--clone-gw-from']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--clone-gw-from" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no-gw']=1
        shift
        ;;

      # :flag.case
      --clone-gw-from)
        # :flag.conflicts
        if [[ -n "${args['--no-gw']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-gw" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--clone-gw-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-gw-from requires an argument: --clone-gw-from TOR_GW" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --clone-web-from)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--clone-web-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-web-from requires an argument: --clone-web-from WEB_VM" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --clone-split-from)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--clone-split-from']="$2"
          shift
          shift
        else
          printf "%s\n" "--clone-split-from requires an argument: --clone-split-from SPLIT_BROWSER_VM" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity equip IDENTITY [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity delete IDENTITY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_open_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_open_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity open"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity open IDENTITY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_close_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_close_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity close"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_identity_start_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_start_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity start"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity start IDENTITY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_stop_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_stop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity stop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_identity_current_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_identity_current_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity current"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_slam_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_slam_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="slam"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_vpn_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    create)
      action="create"
      shift
      risk_vpn_create_parse_requirements "$@"
      shift $#
      ;;

    setup)
      action="setup"
      shift
      risk_vpn_setup_parse_requirements "$@"
      shift $#
      ;;

    start)
      action="start"
      shift
      risk_vpn_start_parse_requirements "$@"
      shift $#
      ;;

    stop)
      action="stop"
      shift
      risk_vpn_stop_parse_requirements "$@"
      shift $#
      ;;

    enable)
      action="enable"
      shift
      risk_vpn_enable_parse_requirements "$@"
      shift $#
      ;;

    disable)
      action="disable"
      shift
      risk_vpn_disable_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      risk_vpn_delete_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_vpn_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_vpn_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --name | -N)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -N NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --label | -L)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--label']="$2"
          shift
          shift
        else
          printf "%s\n" "--label requires an argument: --label, -L COLOR" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --enable | -E)

        # :flag.case_no_arg
        args['--enable']=1
        shift
        ;;

      # :flag.case
      --template | -T)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--template']="$2"
          shift
          shift
        else
          printf "%s\n" "--template requires an argument: --template, -T TEMPLATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --clone | -c)

        # :flag.case_no_arg
        args['--clone']=1
        shift
        ;;

      # :flag.case
      --from | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--from']="$2"
          shift
          shift
        else
          printf "%s\n" "--from requires an argument: --from, -f VPN_GW" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --set-default)

        # :flag.case_no_arg
        args['--set-default']=1
        shift
        ;;

      # :flag.case
      --config-in)
        # :flag.conflicts
        if [[ -n "${args['--choose']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--choose" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--config-in']="$2"
          shift
          shift
        else
          printf "%s\n" "--config-in requires an argument: --config-in CONFIG_VM" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --netvm | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--netvm']="$2"
          shift
          shift
        else
          printf "%s\n" "--netvm requires an argument: --netvm, -n VM" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risk_vpn_setup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_setup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn setup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --config-in)
        # :flag.conflicts
        if [[ -n "${args['--choose']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--choose" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--config-in']="$2"
          shift
          shift
        else
          printf "%s\n" "--config-in requires an argument: --config-in CONFIG_VM" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --set-default)

        # :flag.case_no_arg
        args['--set-default']=1
        shift
        ;;

      # :flag.case
      --netvm | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--netvm']="$2"
          shift
          shift
        else
          printf "%s\n" "--netvm requires an argument: --netvm, -n VM" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --choose)
        # :flag.conflicts
        if [[ -n "${args['--config-in']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--config-in" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--choose']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn setup VM [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_start_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_start_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn start"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn start VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_stop_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_stop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn stop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn stop VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_enable_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_enable_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn enable"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn enable VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_disable_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_disable_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn disable"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn disable VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vpn_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vpn delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_vm_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")" >&2
            exit 1
          fi

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn delete VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vm_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    add)
      action="add"
      shift
      risk_vm_add_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      risk_vm_delete_parse_requirements "$@"
      shift $#
      ;;

    enable)
      action="enable"
      shift
      risk_vm_enable_parse_requirements "$@"
      shift $#
      ;;

    disable)
      action="disable"
      shift
      risk_vm_disable_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_vm_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_vm_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vm_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vm add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --netvm | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--netvm']="$2"
          shift
          shift
        else
          printf "%s\n" "--netvm requires an argument: --netvm, -n VM" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --set-default)

        # :flag.case_no_arg
        args['--set-default']=1
        shift
        ;;

      # :flag.case
      --enable | -E)

        # :flag.case_no_arg
        args['--enable']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vm add VM [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vm_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vm_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vm delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vm delete VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vm_enable_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vm_enable_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vm enable"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vm enable VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_vm_disable_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_vm_disable_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="vm disable"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk vm disable VM\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        if [[ -z ${args['vm']+x} ]]; then

          args['vm']=$1
          shift
        else
          other_args+=("$1")
          shift
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vm']+x} ]]; then
    printf "missing required argument: VM\nusage: risk use VM [...]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_qubes_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_qubes_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    update)
      action="update"
      shift
      risk_qubes_update_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risk_qubes_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risk_qubes_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_qubes_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="qubes update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --identity | -I)

        # :flag.case_no_arg
        args['--identity']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['vms']+x} ]]; then

          args['vms']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['vms']+x} ]]; then
    printf "missing required argument: VMS\nusage: risk qubes update VMS [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risk_help_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risk_help_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="help"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['command']+x} ]]; then

          args['command']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  

  # src/initialize.sh

  # Connected terminal
  typeset -H _TTY
  GPG_TTY=$(tty)  # Needed for GPG operations
  export GPG_TTY

  # Remove verbose errors when * don't yield any match in ZSH
  setopt +o nomatch

  # The generated script makes use of BASH_REMATCH, set compat for ZSH
  setopt BASH_REMATCH


  # Don't run as root
  if [[ $EUID -eq 0 ]]; then
     echo "This script must be run as user"
     exit 2
  fi

  # Use colors unless told not to
  { ! option_is_set --no-color } && { autoload -Uz colors && colors }

  # Configuration file -------------------------------------------------------------------------------
  #
  # Working state and configurations
  typeset -rg RISK_DIR="${HOME}/.risk"                         # Directory where risk stores its state
  typeset -rg RISK_IDENTITIES_DIR="${RISK_DIR}/identities"     # Idendities store their settings here
  typeset -rg RISK_IDENTITY_FILE="${RISK_DIR}/.identity"

  # Create the risk directory if needed
  [[ -e $RISK_DIR ]] || { mkdir -p $RISK_DIR && _info "Creating RISK directory in $RISK_DIR" }
  [[ -e $RISK_IDENTITIES_DIR ]] || mkdir -p $RISK_IDENTITIES_DIR

  # Write the default configuration if it does not exist.
  config_init

  # Default filesystem settings from configuration file ----------------------------------------------
  typeset -g VAULT_VM=$(config_get VAULT_VM)
  typeset -g DEFAULT_NETVM=$(config_get DEFAULT_NETVM)

  typeset -gr DOM0_TERMINAL=$(config_get DOM0_TERMINAL)
  typeset -gr VM_TERMINAL=$(config_get VM_TERMINAL)

  # Working state variables --------------------------------------------------------------------------
  typeset -r IDENTITY            # The identity to use for this single risk execution
  typeset -g IDENTITY_DIR        # The directory where to store identity settings

}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "config")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_config_usage
      else
        risk_config_command
      fi
      ;;

    "config set")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_config_set_usage
      else
        risk_config_set_command
      fi
      ;;

    "config get")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_config_get_usage
      else
        risk_config_get_command
      fi
      ;;

    "config unset")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_config_unset_usage
      else
        risk_config_unset_command
      fi
      ;;

    "config list")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_config_list_usage
      else
        risk_config_list_command
      fi
      ;;

    "config keys")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_config_keys_usage
      else
        risk_config_keys_command
      fi
      ;;

    "hush")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_hush_usage
      else
        risk_hush_command
      fi
      ;;

    "hush attach")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_hush_attach_usage
      else
        risk_hush_attach_command
      fi
      ;;

    "hush detach")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_hush_detach_usage
      else
        risk_hush_detach_command
      fi
      ;;

    "backup")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_backup_usage
      else
        risk_backup_command
      fi
      ;;

    "backup attach")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_backup_attach_usage
      else
        risk_backup_attach_command
      fi
      ;;

    "backup detach")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_backup_detach_usage
      else
        risk_backup_detach_command
      fi
      ;;

    "identity")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_usage
      else
        risk_identity_command
      fi
      ;;

    "identity create")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_create_usage
      else
        risk_identity_create_command
      fi
      ;;

    "identity equip")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_equip_usage
      else
        risk_identity_equip_command
      fi
      ;;

    "identity delete")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_delete_usage
      else
        risk_identity_delete_command
      fi
      ;;

    "identity open")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_open_usage
      else
        risk_identity_open_command
      fi
      ;;

    "identity close")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_close_usage
      else
        risk_identity_close_command
      fi
      ;;

    "identity start")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_start_usage
      else
        risk_identity_start_command
      fi
      ;;

    "identity stop")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_stop_usage
      else
        risk_identity_stop_command
      fi
      ;;

    "identity current")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_identity_current_usage
      else
        risk_identity_current_command
      fi
      ;;

    "slam")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_slam_usage
      else
        risk_slam_command
      fi
      ;;

    "vpn")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_usage
      else
        risk_vpn_command
      fi
      ;;

    "vpn create")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_create_usage
      else
        risk_vpn_create_command
      fi
      ;;

    "vpn setup")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_setup_usage
      else
        risk_vpn_setup_command
      fi
      ;;

    "vpn start")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_start_usage
      else
        risk_vpn_start_command
      fi
      ;;

    "vpn stop")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_stop_usage
      else
        risk_vpn_stop_command
      fi
      ;;

    "vpn enable")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_enable_usage
      else
        risk_vpn_enable_command
      fi
      ;;

    "vpn disable")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_disable_usage
      else
        risk_vpn_disable_command
      fi
      ;;

    "vpn delete")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vpn_delete_usage
      else
        risk_vpn_delete_command
      fi
      ;;

    "vm")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vm_usage
      else
        risk_vm_command
      fi
      ;;

    "vm add")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vm_add_usage
      else
        risk_vm_add_command
      fi
      ;;

    "vm delete")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vm_delete_usage
      else
        risk_vm_delete_command
      fi
      ;;

    "vm enable")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vm_enable_usage
      else
        risk_vm_enable_command
      fi
      ;;

    "vm disable")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_vm_disable_usage
      else
        risk_vm_disable_command
      fi
      ;;

    "use")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_use_usage
      else
        risk_use_command
      fi
      ;;

    "qubes")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_qubes_usage
      else
        risk_qubes_command
      fi
      ;;

    "qubes update")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_qubes_update_usage
      else
        risk_qubes_update_command
      fi
      ;;

    "help")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risk_help_usage
      else
        risk_help_command
      fi
      ;;

  esac
}

initialize
run "$@"
